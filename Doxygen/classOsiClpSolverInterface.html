<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Clp: OsiClpSolverInterface Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Clp
   &#160;<span id="projectnumber">1.17.8</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#friends">Friends</a> &#124;
<a href="classOsiClpSolverInterface-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">OsiClpSolverInterface Class Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Clp Solver Interface.  
 <a href="classOsiClpSolverInterface.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for OsiClpSolverInterface:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classOsiClpSolverInterface__inherit__graph.png" border="0" usemap="#OsiClpSolverInterface_inherit__map" alt="Inheritance graph"/></div>
<map name="OsiClpSolverInterface_inherit__map" id="OsiClpSolverInterface_inherit__map">
<area shape="rect" title="Clp Solver Interface." alt="" coords="5,80,155,107"/>
<area shape="rect" title=" " alt="" coords="15,5,145,32"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<div id="dynsection-1" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-1-trigger" src="closed.png" alt="+"/> Collaboration diagram for OsiClpSolverInterface:</div>
<div id="dynsection-1-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-1-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classOsiClpSolverInterface__coll__graph.png" border="0" usemap="#OsiClpSolverInterface_coll__map" alt="Collaboration graph"/></div>
<map name="OsiClpSolverInterface_coll__map" id="OsiClpSolverInterface_coll__map">
<area shape="rect" title="Clp Solver Interface." alt="" coords="1699,352,1848,379"/>
<area shape="rect" href="classOsiClpDisasterHandler.html" title=" " alt="" coords="1997,397,2152,424"/>
<area shape="rect" title=" " alt="" coords="1433,223,1564,249"/>
<area shape="rect" href="classClpDisasterHandler.html" title="Base class for Clp disaster handling." alt="" coords="5,361,140,388"/>
<area shape="rect" href="classClpSimplex.html" title="This solves LPs using the simplex method." alt="" coords="292,316,379,343"/>
<area shape="rect" href="classClpEventHandler.html" title="Base class for Clp event handling." alt="" coords="587,649,706,676"/>
<area shape="rect" href="classClpPrimalColumnPivot.html" title="Primal Column Pivot Abstract Base Class." alt="" coords="571,440,723,467"/>
<area shape="rect" href="classClpNetworkBasis.html" title="This deals with Factorization and Updates for network structures." alt="" coords="585,147,708,173"/>
<area shape="rect" href="classClpNonLinearCost.html" title=" " alt="" coords="583,329,711,356"/>
<area shape="rect" href="classClpDualRowPivot.html" title="Dual Row Pivot Abstract Base Class." alt="" coords="585,271,708,297"/>
<area shape="rect" href="classClpSimplexProgress.html" title="For saving extra information to see if looping." alt="" coords="577,27,716,53"/>
<area shape="rect" href="classClpNodeStuff.html" title=" " alt="" coords="1449,273,1548,300"/>
<area shape="rect" href="classClpModel.html" title=" " alt="" coords="931,736,1007,763"/>
<area shape="rect" href="classClpObjective.html" title="Objective Abstract Base Class." alt="" coords="599,491,695,517"/>
<area shape="rect" href="classClpLinearObjective.html" title="Linear Objective Class." alt="" coords="1067,456,1199,483"/>
<area shape="rect" href="structClpTrustedData.html" title="For a structure to be used by trusted code." alt="" coords="591,979,703,1005"/>
<area shape="rect" href="classClpPackedMatrix.html" title=" " alt="" coords="587,831,707,857"/>
<area shape="rect" href="classClpMatrixBase.html" title="Abstract base class for Clp Matrices." alt="" coords="282,904,389,931"/>
<area shape="rect" href="classClpPackedMatrix2.html" title=" " alt="" coords="272,840,399,867"/>
<area shape="rect" href="classClpPackedMatrix3.html" title=" " alt="" coords="272,789,399,816"/>
<area shape="rect" href="structblockStruct.html" title=" " alt="" coords="29,789,117,816"/>
<area shape="rect" title="STL class." alt="" coords="296,729,375,756"/>
<area shape="rect" title=" " alt="" coords="567,708,727,735"/>
<area shape="rect" title="STL class." alt="" coords="11,722,135,763"/>
<area shape="rect" title="STL class." alt="" coords="279,671,391,697"/>
<area shape="rect" title=" " alt="" coords="53,671,92,697"/>
<area shape="rect" href="classClpFactorization.html" title="This just implements CoinFactorization when an ClpMatrixBase object is passed." alt="" coords="911,172,1026,199"/>
<area shape="rect" href="classClpNode.html" title=" " alt="" coords="1223,249,1295,276"/>
<area shape="rect" href="classClpDualRowSteepest.html" title="Dual Row Pivot Steepest Edge Algorithm Class." alt="" coords="896,288,1041,315"/>
<area shape="rect" href="structClpNode_1_1branchState.html" title=" " alt="" coords="895,237,1043,264"/>
<area shape="rect" href="classClpDataSave.html" title="This is a tiny class where data can be saved round calls." alt="" coords="1449,491,1548,517"/>
<area shape="rect" href="classClpSolve.html" title="This is a very simple class to guide algorithms." alt="" coords="1461,109,1536,136"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Solve methods</div></td></tr>
<tr class="memitem:a593ef13cc9058734bfa7d8bded2ee437"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a593ef13cc9058734bfa7d8bded2ee437">initialSolve</a> ()</td></tr>
<tr class="memdesc:a593ef13cc9058734bfa7d8bded2ee437"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve initial LP relaxation.  <a href="classOsiClpSolverInterface.html#a593ef13cc9058734bfa7d8bded2ee437">More...</a><br /></td></tr>
<tr class="separator:a593ef13cc9058734bfa7d8bded2ee437"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a770d869e0c9da633cbe54b563d925699"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a770d869e0c9da633cbe54b563d925699">resolve</a> ()</td></tr>
<tr class="memdesc:a770d869e0c9da633cbe54b563d925699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve an LP relaxation after problem modification.  <a href="classOsiClpSolverInterface.html#a770d869e0c9da633cbe54b563d925699">More...</a><br /></td></tr>
<tr class="separator:a770d869e0c9da633cbe54b563d925699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e22fefb12936c73bdfd7aca615fc001"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a3e22fefb12936c73bdfd7aca615fc001">resolveGub</a> (int needed)</td></tr>
<tr class="memdesc:a3e22fefb12936c73bdfd7aca615fc001"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resolve an LP relaxation after problem modification (try GUB)  <a href="classOsiClpSolverInterface.html#a3e22fefb12936c73bdfd7aca615fc001">More...</a><br /></td></tr>
<tr class="separator:a3e22fefb12936c73bdfd7aca615fc001"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c68bf83f32763e5512d1d8c3747a2b7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a4c68bf83f32763e5512d1d8c3747a2b7">branchAndBound</a> ()</td></tr>
<tr class="memdesc:a4c68bf83f32763e5512d1d8c3747a2b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Invoke solver's built-in enumeration algorithm.  <a href="classOsiClpSolverInterface.html#a4c68bf83f32763e5512d1d8c3747a2b7">More...</a><br /></td></tr>
<tr class="separator:a4c68bf83f32763e5512d1d8c3747a2b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782c4e8c3ca2b3352561c0613a872815"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a782c4e8c3ca2b3352561c0613a872815">crossover</a> (int options, int basis)</td></tr>
<tr class="memdesc:a782c4e8c3ca2b3352561c0613a872815"><td class="mdescLeft">&#160;</td><td class="mdescRight">Solve when primal column and dual row solutions are near-optimal options - 0 no presolve (use primal and dual) 1 presolve (just use primal) 2 no presolve (just use primal) basis - 0 use all slack basis 1 try and put some in basis.  <a href="classOsiClpSolverInterface.html#a782c4e8c3ca2b3352561c0613a872815">More...</a><br /></td></tr>
<tr class="separator:a782c4e8c3ca2b3352561c0613a872815"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">OsiSimplexInterface methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Methods for the Osi Simplex API.</p>
<p>The current implementation should work for both minimisation and maximisation in mode 1 (tableau access). In mode 2 (single pivot), only minimisation is supported as of 100907. </p>
</div></td></tr>
<tr class="memitem:a452be2c7f4978aac85991d055815f079"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a452be2c7f4978aac85991d055815f079">canDoSimplexInterface</a> () const</td></tr>
<tr class="memdesc:a452be2c7f4978aac85991d055815f079"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simplex API capability.  <a href="classOsiClpSolverInterface.html#a452be2c7f4978aac85991d055815f079">More...</a><br /></td></tr>
<tr class="separator:a452be2c7f4978aac85991d055815f079"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1322ee0dcd508677db4a05720cb380e3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1322ee0dcd508677db4a05720cb380e3">enableFactorization</a> () const</td></tr>
<tr class="memdesc:a1322ee0dcd508677db4a05720cb380e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables simplex mode 1 (tableau access)  <a href="classOsiClpSolverInterface.html#a1322ee0dcd508677db4a05720cb380e3">More...</a><br /></td></tr>
<tr class="separator:a1322ee0dcd508677db4a05720cb380e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a391d2ca359c17e5a25cf21cacab4978b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a391d2ca359c17e5a25cf21cacab4978b">disableFactorization</a> () const</td></tr>
<tr class="memdesc:a391d2ca359c17e5a25cf21cacab4978b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo any setting changes made by <a class="el" href="classOsiClpSolverInterface.html#a1322ee0dcd508677db4a05720cb380e3" title="Enables simplex mode 1 (tableau access)">enableFactorization</a>.  <a href="classOsiClpSolverInterface.html#a391d2ca359c17e5a25cf21cacab4978b">More...</a><br /></td></tr>
<tr class="separator:a391d2ca359c17e5a25cf21cacab4978b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2cc2bd18cf8e0327ae482b7f68d6192"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af2cc2bd18cf8e0327ae482b7f68d6192">basisIsAvailable</a> () const</td></tr>
<tr class="memdesc:af2cc2bd18cf8e0327ae482b7f68d6192"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if a basis is available AND problem is optimal.  <a href="classOsiClpSolverInterface.html#af2cc2bd18cf8e0327ae482b7f68d6192">More...</a><br /></td></tr>
<tr class="separator:af2cc2bd18cf8e0327ae482b7f68d6192"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af47b76241318bafd40e475bea891ca36"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af47b76241318bafd40e475bea891ca36">getBasisStatus</a> (int *cstat, int *rstat) const</td></tr>
<tr class="memdesc:af47b76241318bafd40e475bea891ca36"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following two methods may be replaced by the methods of OsiSolverInterface using OsiWarmStartBasis if:  <a href="classOsiClpSolverInterface.html#af47b76241318bafd40e475bea891ca36">More...</a><br /></td></tr>
<tr class="separator:af47b76241318bafd40e475bea891ca36"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52c9f3dea866c80b7cf3b67564902054"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a52c9f3dea866c80b7cf3b67564902054">setBasisStatus</a> (const int *cstat, const int *rstat)</td></tr>
<tr class="memdesc:a52c9f3dea866c80b7cf3b67564902054"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the status of structural/artificial variables and factorize, update solution etc.  <a href="classOsiClpSolverInterface.html#a52c9f3dea866c80b7cf3b67564902054">More...</a><br /></td></tr>
<tr class="separator:a52c9f3dea866c80b7cf3b67564902054"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac905bd4a4ad34ad6b67651757921884e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ac905bd4a4ad34ad6b67651757921884e">getReducedGradient</a> (double *columnReducedCosts, double *duals, const double *c) const</td></tr>
<tr class="memdesc:ac905bd4a4ad34ad6b67651757921884e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the reduced gradient for the cost vector c.  <a href="classOsiClpSolverInterface.html#ac905bd4a4ad34ad6b67651757921884e">More...</a><br /></td></tr>
<tr class="separator:ac905bd4a4ad34ad6b67651757921884e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3d470cefb0bddb4279a5ac1589d7223"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ac3d470cefb0bddb4279a5ac1589d7223">getBInvARow</a> (int row, double *z, double *slack=NULL) const</td></tr>
<tr class="memdesc:ac3d470cefb0bddb4279a5ac1589d7223"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a row of the tableau (slack part in slack if not NULL)  <a href="classOsiClpSolverInterface.html#ac3d470cefb0bddb4279a5ac1589d7223">More...</a><br /></td></tr>
<tr class="separator:ac3d470cefb0bddb4279a5ac1589d7223"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27c333c990adcc948d38c0e634ff1dd3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a27c333c990adcc948d38c0e634ff1dd3">getBInvARow</a> (int row, CoinIndexedVector *z, CoinIndexedVector *slack=NULL, bool keepScaled=false) const</td></tr>
<tr class="memdesc:a27c333c990adcc948d38c0e634ff1dd3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a row of the tableau (slack part in slack if not NULL) If keepScaled is true then scale factors not applied after so user has to use coding similar to what is in this method.  <a href="classOsiClpSolverInterface.html#a27c333c990adcc948d38c0e634ff1dd3">More...</a><br /></td></tr>
<tr class="separator:a27c333c990adcc948d38c0e634ff1dd3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0af218163ef426f1c4492d658ae5b5ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a0af218163ef426f1c4492d658ae5b5ea">getBInvRow</a> (int row, double *z) const</td></tr>
<tr class="memdesc:a0af218163ef426f1c4492d658ae5b5ea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a row of the basis inverse.  <a href="classOsiClpSolverInterface.html#a0af218163ef426f1c4492d658ae5b5ea">More...</a><br /></td></tr>
<tr class="separator:a0af218163ef426f1c4492d658ae5b5ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ba0b1e7c9ca131c12e85c999d96c324"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a2ba0b1e7c9ca131c12e85c999d96c324">getBInvACol</a> (int col, double *vec) const</td></tr>
<tr class="memdesc:a2ba0b1e7c9ca131c12e85c999d96c324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a column of the tableau.  <a href="classOsiClpSolverInterface.html#a2ba0b1e7c9ca131c12e85c999d96c324">More...</a><br /></td></tr>
<tr class="separator:a2ba0b1e7c9ca131c12e85c999d96c324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a455103d8131883e60eb9c5e6d55d8164"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a455103d8131883e60eb9c5e6d55d8164">getBInvACol</a> (int col, CoinIndexedVector *vec) const</td></tr>
<tr class="memdesc:a455103d8131883e60eb9c5e6d55d8164"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a column of the tableau.  <a href="classOsiClpSolverInterface.html#a455103d8131883e60eb9c5e6d55d8164">More...</a><br /></td></tr>
<tr class="separator:a455103d8131883e60eb9c5e6d55d8164"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01b50611a1fe1c2d81ca739a9f47907"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af01b50611a1fe1c2d81ca739a9f47907">getBInvACol</a> (CoinIndexedVector *vec) const</td></tr>
<tr class="memdesc:af01b50611a1fe1c2d81ca739a9f47907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Update (i.e.  <a href="classOsiClpSolverInterface.html#af01b50611a1fe1c2d81ca739a9f47907">More...</a><br /></td></tr>
<tr class="separator:af01b50611a1fe1c2d81ca739a9f47907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6459510073886e22a6ad5e983ccbb66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af6459510073886e22a6ad5e983ccbb66">getBInvCol</a> (int col, double *vec) const</td></tr>
<tr class="memdesc:af6459510073886e22a6ad5e983ccbb66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a column of the basis inverse.  <a href="classOsiClpSolverInterface.html#af6459510073886e22a6ad5e983ccbb66">More...</a><br /></td></tr>
<tr class="separator:af6459510073886e22a6ad5e983ccbb66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dc89b6917c8700bf7e0e69a75372ab4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1dc89b6917c8700bf7e0e69a75372ab4">getBasics</a> (int *index) const</td></tr>
<tr class="memdesc:a1dc89b6917c8700bf7e0e69a75372ab4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get basic indices (order of indices corresponds to the order of elements in a vector retured by <a class="el" href="classOsiClpSolverInterface.html#a2ba0b1e7c9ca131c12e85c999d96c324" title="Get a column of the tableau.">getBInvACol()</a> and <a class="el" href="classOsiClpSolverInterface.html#af6459510073886e22a6ad5e983ccbb66" title="Get a column of the basis inverse.">getBInvCol()</a>).  <a href="classOsiClpSolverInterface.html#a1dc89b6917c8700bf7e0e69a75372ab4">More...</a><br /></td></tr>
<tr class="separator:a1dc89b6917c8700bf7e0e69a75372ab4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e764316b2e7f1a129bcd4e947d6cc6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a6e764316b2e7f1a129bcd4e947d6cc6b">enableSimplexInterface</a> (bool doingPrimal)</td></tr>
<tr class="memdesc:a6e764316b2e7f1a129bcd4e947d6cc6b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables simplex mode 2 (individual pivot control)  <a href="classOsiClpSolverInterface.html#a6e764316b2e7f1a129bcd4e947d6cc6b">More...</a><br /></td></tr>
<tr class="separator:a6e764316b2e7f1a129bcd4e947d6cc6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c85c203d7204729600c276e852a51d3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a2c85c203d7204729600c276e852a51d3">disableSimplexInterface</a> ()</td></tr>
<tr class="memdesc:a2c85c203d7204729600c276e852a51d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Undo setting changes made by <a class="el" href="classOsiClpSolverInterface.html#a6e764316b2e7f1a129bcd4e947d6cc6b" title="Enables simplex mode 2 (individual pivot control)">enableSimplexInterface</a>.  <a href="classOsiClpSolverInterface.html#a2c85c203d7204729600c276e852a51d3">More...</a><br /></td></tr>
<tr class="separator:a2c85c203d7204729600c276e852a51d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a324e55fe159bec975fdcc62337f7145a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a324e55fe159bec975fdcc62337f7145a">pivot</a> (int colIn, int colOut, int outStatus)</td></tr>
<tr class="memdesc:a324e55fe159bec975fdcc62337f7145a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Perform a pivot by substituting a colIn for colOut in the basis.  <a href="classOsiClpSolverInterface.html#a324e55fe159bec975fdcc62337f7145a">More...</a><br /></td></tr>
<tr class="separator:a324e55fe159bec975fdcc62337f7145a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd182f1225ba03071bd3cdd136f4b80a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#abd182f1225ba03071bd3cdd136f4b80a">primalPivotResult</a> (int colIn, int sign, int &amp;colOut, int &amp;outStatus, double &amp;t, CoinPackedVector *dx)</td></tr>
<tr class="memdesc:abd182f1225ba03071bd3cdd136f4b80a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a result of the primal pivot Outputs: colOut &ndash; leaving column, outStatus &ndash; its status, t &ndash; step size, and, if dx!=NULL, *dx &ndash; primal ray direction.  <a href="classOsiClpSolverInterface.html#abd182f1225ba03071bd3cdd136f4b80a">More...</a><br /></td></tr>
<tr class="separator:abd182f1225ba03071bd3cdd136f4b80a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f97948775981910c54e3fa95fb437a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a90f97948775981910c54e3fa95fb437a">dualPivotResult</a> (int &amp;colIn, int &amp;sign, int colOut, int outStatus, double &amp;t, CoinPackedVector *dx)</td></tr>
<tr class="memdesc:a90f97948775981910c54e3fa95fb437a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Obtain a result of the dual pivot (similar to the previous method) Differences: entering variable and a sign of its change are now the outputs, the leaving variable and its statuts &ndash; the inputs If dx!=NULL, then *dx contains dual ray Return code: same.  <a href="classOsiClpSolverInterface.html#a90f97948775981910c54e3fa95fb437a">More...</a><br /></td></tr>
<tr class="separator:a90f97948775981910c54e3fa95fb437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Parameter set/get methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The set methods return true if the parameter was set to the given value, false otherwise.</p>
<p>There can be various reasons for failure: the given parameter is not applicable for the solver (e.g., refactorization frequency for the clp algorithm), the parameter is not yet implemented for the solver or simply the value of the parameter is out of the range the solver accepts. If a parameter setting call returns false check the details of your solver.</p>
<p>The get methods return true if the given parameter is applicable for the solver and is implemented. In this case the value of the parameter is returned in the second argument. Otherwise they return false. </p>
</div></td></tr>
<tr class="memitem:ae286206398e2a0142573d4e32e097ba7"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ae286206398e2a0142573d4e32e097ba7">setIntParam</a> (OsiIntParam key, int value)</td></tr>
<tr class="separator:ae286206398e2a0142573d4e32e097ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae1696fc6c84a72cdf054d41a4228860d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ae1696fc6c84a72cdf054d41a4228860d">setDblParam</a> (OsiDblParam key, double value)</td></tr>
<tr class="separator:ae1696fc6c84a72cdf054d41a4228860d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31fc82afd61124c58dae52cabaf9996c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a31fc82afd61124c58dae52cabaf9996c">setStrParam</a> (OsiStrParam key, const std::string &amp;value)</td></tr>
<tr class="separator:a31fc82afd61124c58dae52cabaf9996c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa382ae87fcefe98f778dc6cf4818e74e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aa382ae87fcefe98f778dc6cf4818e74e">getIntParam</a> (OsiIntParam key, int &amp;value) const</td></tr>
<tr class="separator:aa382ae87fcefe98f778dc6cf4818e74e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6c16d3a59265d6569163545767dc9ea"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aa6c16d3a59265d6569163545767dc9ea">getDblParam</a> (OsiDblParam key, double &amp;value) const</td></tr>
<tr class="separator:aa6c16d3a59265d6569163545767dc9ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af636f3a0994ef4766feebdf9d63d7173"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af636f3a0994ef4766feebdf9d63d7173">getStrParam</a> (OsiStrParam key, std::string &amp;value) const</td></tr>
<tr class="separator:af636f3a0994ef4766feebdf9d63d7173"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a77ac65edc08f0c942e59d3c0637fdbb0"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a77ac65edc08f0c942e59d3c0637fdbb0">setHintParam</a> (OsiHintParam key, bool yesNo=true, OsiHintStrength strength=OsiHintTry, void *otherInformation=NULL)</td></tr>
<tr class="separator:a77ac65edc08f0c942e59d3c0637fdbb0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods returning info on how the solution process terminated</div></td></tr>
<tr class="memitem:a70cb310cbf5ebf200d8cd2d68a491fad"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a70cb310cbf5ebf200d8cd2d68a491fad">isAbandoned</a> () const</td></tr>
<tr class="memdesc:a70cb310cbf5ebf200d8cd2d68a491fad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Are there a numerical difficulties?  <a href="classOsiClpSolverInterface.html#a70cb310cbf5ebf200d8cd2d68a491fad">More...</a><br /></td></tr>
<tr class="separator:a70cb310cbf5ebf200d8cd2d68a491fad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a465ead374ff6f9c042930648979372"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a5a465ead374ff6f9c042930648979372">isProvenOptimal</a> () const</td></tr>
<tr class="memdesc:a5a465ead374ff6f9c042930648979372"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is optimality proven?  <a href="classOsiClpSolverInterface.html#a5a465ead374ff6f9c042930648979372">More...</a><br /></td></tr>
<tr class="separator:a5a465ead374ff6f9c042930648979372"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44147763ae775e743d61c50757f53012"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a44147763ae775e743d61c50757f53012">isProvenPrimalInfeasible</a> () const</td></tr>
<tr class="memdesc:a44147763ae775e743d61c50757f53012"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is primal infeasiblity proven?  <a href="classOsiClpSolverInterface.html#a44147763ae775e743d61c50757f53012">More...</a><br /></td></tr>
<tr class="separator:a44147763ae775e743d61c50757f53012"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a050713893a284a72b547567161285042"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a050713893a284a72b547567161285042">isProvenDualInfeasible</a> () const</td></tr>
<tr class="memdesc:a050713893a284a72b547567161285042"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is dual infeasiblity proven?  <a href="classOsiClpSolverInterface.html#a050713893a284a72b547567161285042">More...</a><br /></td></tr>
<tr class="separator:a050713893a284a72b547567161285042"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2069442053d70fdd1e8eb5099719a7b9"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a2069442053d70fdd1e8eb5099719a7b9">isPrimalObjectiveLimitReached</a> () const</td></tr>
<tr class="memdesc:a2069442053d70fdd1e8eb5099719a7b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given primal objective limit reached?  <a href="classOsiClpSolverInterface.html#a2069442053d70fdd1e8eb5099719a7b9">More...</a><br /></td></tr>
<tr class="separator:a2069442053d70fdd1e8eb5099719a7b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d0fc7d43b6e79a3a3f113069a54e30"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a46d0fc7d43b6e79a3a3f113069a54e30">isDualObjectiveLimitReached</a> () const</td></tr>
<tr class="memdesc:a46d0fc7d43b6e79a3a3f113069a54e30"><td class="mdescLeft">&#160;</td><td class="mdescRight">Is the given dual objective limit reached?  <a href="classOsiClpSolverInterface.html#a46d0fc7d43b6e79a3a3f113069a54e30">More...</a><br /></td></tr>
<tr class="separator:a46d0fc7d43b6e79a3a3f113069a54e30"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15bdfd65c6daf670a71ca3eedb81ad15"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a15bdfd65c6daf670a71ca3eedb81ad15">isIterationLimitReached</a> () const</td></tr>
<tr class="memdesc:a15bdfd65c6daf670a71ca3eedb81ad15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Iteration limit reached?  <a href="classOsiClpSolverInterface.html#a15bdfd65c6daf670a71ca3eedb81ad15">More...</a><br /></td></tr>
<tr class="separator:a15bdfd65c6daf670a71ca3eedb81ad15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">WarmStart related methods</div></td></tr>
<tr class="memitem:a4fdff34a07410f9ea50823e0de1eb824"><td class="memItemLeft" align="right" valign="top">virtual CoinWarmStart *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a4fdff34a07410f9ea50823e0de1eb824">getEmptyWarmStart</a> () const</td></tr>
<tr class="memdesc:a4fdff34a07410f9ea50823e0de1eb824"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an empty warm start object.  <a href="classOsiClpSolverInterface.html#a4fdff34a07410f9ea50823e0de1eb824">More...</a><br /></td></tr>
<tr class="separator:a4fdff34a07410f9ea50823e0de1eb824"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4870c21baf589bf9e8fcebf32d3ea982"><td class="memItemLeft" align="right" valign="top">virtual CoinWarmStart *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a4870c21baf589bf9e8fcebf32d3ea982">getWarmStart</a> () const</td></tr>
<tr class="memdesc:a4870c21baf589bf9e8fcebf32d3ea982"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get warmstarting information.  <a href="classOsiClpSolverInterface.html#a4870c21baf589bf9e8fcebf32d3ea982">More...</a><br /></td></tr>
<tr class="separator:a4870c21baf589bf9e8fcebf32d3ea982"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a739b4d70b931138436d4afe7b665da93"><td class="memItemLeft" align="right" valign="top">CoinWarmStartBasis *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a739b4d70b931138436d4afe7b665da93">getPointerToWarmStart</a> ()</td></tr>
<tr class="memdesc:a739b4d70b931138436d4afe7b665da93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get warmstarting information.  <a href="classOsiClpSolverInterface.html#a739b4d70b931138436d4afe7b665da93">More...</a><br /></td></tr>
<tr class="separator:a739b4d70b931138436d4afe7b665da93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4886c80c50592a37ceee17be5baab40"><td class="memItemLeft" align="right" valign="top">const CoinWarmStartBasis *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aa4886c80c50592a37ceee17be5baab40">getConstPointerToWarmStart</a> () const</td></tr>
<tr class="memdesc:aa4886c80c50592a37ceee17be5baab40"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get warmstarting information.  <a href="classOsiClpSolverInterface.html#aa4886c80c50592a37ceee17be5baab40">More...</a><br /></td></tr>
<tr class="separator:aa4886c80c50592a37ceee17be5baab40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f8efbfc7a52b6e1b39c9ee575cab65a"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a3f8efbfc7a52b6e1b39c9ee575cab65a">setWarmStart</a> (const CoinWarmStart *warmstart)</td></tr>
<tr class="memdesc:a3f8efbfc7a52b6e1b39c9ee575cab65a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set warmstarting information.  <a href="classOsiClpSolverInterface.html#a3f8efbfc7a52b6e1b39c9ee575cab65a">More...</a><br /></td></tr>
<tr class="separator:a3f8efbfc7a52b6e1b39c9ee575cab65a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42a68c426547ccdde2a4b8b36be26e2d"><td class="memItemLeft" align="right" valign="top">virtual CoinWarmStart *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a42a68c426547ccdde2a4b8b36be26e2d">getPointerToWarmStart</a> (bool &amp;mustDelete)</td></tr>
<tr class="memdesc:a42a68c426547ccdde2a4b8b36be26e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get warm start information.  <a href="classOsiClpSolverInterface.html#a42a68c426547ccdde2a4b8b36be26e2d">More...</a><br /></td></tr>
<tr class="separator:a42a68c426547ccdde2a4b8b36be26e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7c0185ec68de7c04e3d9e5f287ed602"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ac7c0185ec68de7c04e3d9e5f287ed602">setColumnStatus</a> (int iColumn, <a class="el" href="classClpSimplex.html#a21143b50762085902b3852b103b3704f">ClpSimplex::Status</a> status)</td></tr>
<tr class="memdesc:ac7c0185ec68de7c04e3d9e5f287ed602"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set column status in <a class="el" href="classClpSimplex.html" title="This solves LPs using the simplex method.">ClpSimplex</a> and warmStart.  <a href="classOsiClpSolverInterface.html#ac7c0185ec68de7c04e3d9e5f287ed602">More...</a><br /></td></tr>
<tr class="separator:ac7c0185ec68de7c04e3d9e5f287ed602"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Hotstart related methods (primarily used in strong branching).</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The user can create a hotstart (a snapshot) of the optimization process then reoptimize over and over again always starting from there.</p>
<p><br  />
 <b>NOTE</b>: between hotstarted optimizations only bound changes are allowed. </p>
</div></td></tr>
<tr class="memitem:a25a0f5297ee91cde41e0c8d9064bb548"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a25a0f5297ee91cde41e0c8d9064bb548">markHotStart</a> ()</td></tr>
<tr class="memdesc:a25a0f5297ee91cde41e0c8d9064bb548"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a hotstart point of the optimization process.  <a href="classOsiClpSolverInterface.html#a25a0f5297ee91cde41e0c8d9064bb548">More...</a><br /></td></tr>
<tr class="separator:a25a0f5297ee91cde41e0c8d9064bb548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bf50161ab7566bedd21de17e63ba55c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1bf50161ab7566bedd21de17e63ba55c">solveFromHotStart</a> ()</td></tr>
<tr class="memdesc:a1bf50161ab7566bedd21de17e63ba55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Optimize starting from the hotstart.  <a href="classOsiClpSolverInterface.html#a1bf50161ab7566bedd21de17e63ba55c">More...</a><br /></td></tr>
<tr class="separator:a1bf50161ab7566bedd21de17e63ba55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80efbc68cded5b9cea00b1827ca605ad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a80efbc68cded5b9cea00b1827ca605ad">unmarkHotStart</a> ()</td></tr>
<tr class="memdesc:a80efbc68cded5b9cea00b1827ca605ad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the snapshot.  <a href="classOsiClpSolverInterface.html#a80efbc68cded5b9cea00b1827ca605ad">More...</a><br /></td></tr>
<tr class="separator:a80efbc68cded5b9cea00b1827ca605ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0343b260b84741212d2dabc9d95521f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aa0343b260b84741212d2dabc9d95521f">startFastDual</a> (int options)</td></tr>
<tr class="memdesc:aa0343b260b84741212d2dabc9d95521f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Start faster dual - returns negative if problems 1 if infeasible, <a class="el" href="structOptions.html" title="******** DATA to be moved into protected section of ClpInterior">Options</a> to pass to solver 1 - create external reduced costs for columns 2 - create external reduced costs for rows 4 - create external row activity (columns always done) Above only done if feasible When set resolve does less work.  <a href="classOsiClpSolverInterface.html#aa0343b260b84741212d2dabc9d95521f">More...</a><br /></td></tr>
<tr class="separator:aa0343b260b84741212d2dabc9d95521f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a716387e42841d59299d6d6c3030e9184"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a716387e42841d59299d6d6c3030e9184">stopFastDual</a> ()</td></tr>
<tr class="memdesc:a716387e42841d59299d6d6c3030e9184"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stop fast dual.  <a href="classOsiClpSolverInterface.html#a716387e42841d59299d6d6c3030e9184">More...</a><br /></td></tr>
<tr class="separator:a716387e42841d59299d6d6c3030e9184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa73f4377fc682430c2ad00b79a61db08"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aa73f4377fc682430c2ad00b79a61db08">setStuff</a> (double tolerance, double increment)</td></tr>
<tr class="memdesc:aa73f4377fc682430c2ad00b79a61db08"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets integer tolerance and increment.  <a href="classOsiClpSolverInterface.html#aa73f4377fc682430c2ad00b79a61db08">More...</a><br /></td></tr>
<tr class="separator:aa73f4377fc682430c2ad00b79a61db08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d9b718431ded5d4bdb30d1c48e4899"><td class="memItemLeft" align="right" valign="top">OsiRowCut *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ac6d9b718431ded5d4bdb30d1c48e4899">smallModelCut</a> (const double *originalLower, const double *originalUpper, int numberRowsAtContinuous, const int *whichGenerator, int typeCut=0)</td></tr>
<tr class="memdesc:ac6d9b718431ded5d4bdb30d1c48e4899"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a conflict analysis cut from small model.  <a href="classOsiClpSolverInterface.html#ac6d9b718431ded5d4bdb30d1c48e4899">More...</a><br /></td></tr>
<tr class="separator:ac6d9b718431ded5d4bdb30d1c48e4899"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33f400d6f9255faca8a290732e31fd07"><td class="memItemLeft" align="right" valign="top">OsiRowCut *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a33f400d6f9255faca8a290732e31fd07">modelCut</a> (const double *originalLower, const double *originalUpper, int numberRowsAtContinuous, const int *whichGenerator, int typeCut=0)</td></tr>
<tr class="memdesc:a33f400d6f9255faca8a290732e31fd07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a conflict analysis cut from model If type is 0 then genuine cut, if 1 then only partially processed.  <a href="classOsiClpSolverInterface.html#a33f400d6f9255faca8a290732e31fd07">More...</a><br /></td></tr>
<tr class="separator:a33f400d6f9255faca8a290732e31fd07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods related to querying the input data</div></td></tr>
<tr class="memitem:a3974c65825e426ed107a5cb032d04e92"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92">getNumCols</a> () const</td></tr>
<tr class="memdesc:a3974c65825e426ed107a5cb032d04e92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of columns.  <a href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92">More...</a><br /></td></tr>
<tr class="separator:a3974c65825e426ed107a5cb032d04e92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9264e6716986e041907e3bf6aef205c9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9">getNumRows</a> () const</td></tr>
<tr class="memdesc:a9264e6716986e041907e3bf6aef205c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of rows.  <a href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9">More...</a><br /></td></tr>
<tr class="separator:a9264e6716986e041907e3bf6aef205c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad74b987e74a865e1922c8321a02fc14"><td class="memItemLeft" align="right" valign="top">virtual CoinBigIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aad74b987e74a865e1922c8321a02fc14">getNumElements</a> () const</td></tr>
<tr class="memdesc:aad74b987e74a865e1922c8321a02fc14"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get number of nonzero elements.  <a href="classOsiClpSolverInterface.html#aad74b987e74a865e1922c8321a02fc14">More...</a><br /></td></tr>
<tr class="separator:aad74b987e74a865e1922c8321a02fc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab05c4ee6b9795138c3dd372d2793f400"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ab05c4ee6b9795138c3dd372d2793f400">getRowName</a> (int rowIndex, unsigned maxLen=static_cast&lt; unsigned &gt;(std::string::npos)) const</td></tr>
<tr class="memdesc:ab05c4ee6b9795138c3dd372d2793f400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return name of row if one exists or Rnnnnnnn maxLen is currently ignored and only there to match the signature from the base class!  <a href="classOsiClpSolverInterface.html#ab05c4ee6b9795138c3dd372d2793f400">More...</a><br /></td></tr>
<tr class="separator:ab05c4ee6b9795138c3dd372d2793f400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed5c89b743fcbf26d015ad9edabc388e"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aed5c89b743fcbf26d015ad9edabc388e">getColName</a> (int colIndex, unsigned maxLen=static_cast&lt; unsigned &gt;(std::string::npos)) const</td></tr>
<tr class="memdesc:aed5c89b743fcbf26d015ad9edabc388e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return name of column if one exists or Cnnnnnnn maxLen is currently ignored and only there to match the signature from the base class!  <a href="classOsiClpSolverInterface.html#aed5c89b743fcbf26d015ad9edabc388e">More...</a><br /></td></tr>
<tr class="separator:aed5c89b743fcbf26d015ad9edabc388e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3108016d8607d5a0aab7bce53889ad3a"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a3108016d8607d5a0aab7bce53889ad3a">getColLower</a> () const</td></tr>
<tr class="memdesc:a3108016d8607d5a0aab7bce53889ad3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] of column lower bounds.  <a href="classOsiClpSolverInterface.html#a3108016d8607d5a0aab7bce53889ad3a">More...</a><br /></td></tr>
<tr class="separator:a3108016d8607d5a0aab7bce53889ad3a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab63676a5efab85b18cc269b0c3e980f6"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ab63676a5efab85b18cc269b0c3e980f6">getColUpper</a> () const</td></tr>
<tr class="memdesc:ab63676a5efab85b18cc269b0c3e980f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] of column upper bounds.  <a href="classOsiClpSolverInterface.html#ab63676a5efab85b18cc269b0c3e980f6">More...</a><br /></td></tr>
<tr class="separator:ab63676a5efab85b18cc269b0c3e980f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9572898bcf2547863fc66e6887aefe4c"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a9572898bcf2547863fc66e6887aefe4c">getRowSense</a> () const</td></tr>
<tr class="memdesc:a9572898bcf2547863fc66e6887aefe4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of row constraint senses.  <a href="classOsiClpSolverInterface.html#a9572898bcf2547863fc66e6887aefe4c">More...</a><br /></td></tr>
<tr class="separator:a9572898bcf2547863fc66e6887aefe4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960856ba062d10bc91713055ca3081cc"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a960856ba062d10bc91713055ca3081cc">getRightHandSide</a> () const</td></tr>
<tr class="memdesc:a960856ba062d10bc91713055ca3081cc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of rows right-hand sides.  <a href="classOsiClpSolverInterface.html#a960856ba062d10bc91713055ca3081cc">More...</a><br /></td></tr>
<tr class="separator:a960856ba062d10bc91713055ca3081cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae16a03e48d74145c844d1f6a92c9a2f3"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ae16a03e48d74145c844d1f6a92c9a2f3">getRowRange</a> () const</td></tr>
<tr class="memdesc:ae16a03e48d74145c844d1f6a92c9a2f3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of row ranges.  <a href="classOsiClpSolverInterface.html#ae16a03e48d74145c844d1f6a92c9a2f3">More...</a><br /></td></tr>
<tr class="separator:ae16a03e48d74145c844d1f6a92c9a2f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aed6829ed0efaca22f5ad7ac4ea47c699"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aed6829ed0efaca22f5ad7ac4ea47c699">getRowLower</a> () const</td></tr>
<tr class="memdesc:aed6829ed0efaca22f5ad7ac4ea47c699"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of row lower bounds.  <a href="classOsiClpSolverInterface.html#aed6829ed0efaca22f5ad7ac4ea47c699">More...</a><br /></td></tr>
<tr class="separator:aed6829ed0efaca22f5ad7ac4ea47c699"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ec302bf65a5627c771ab69499353cf5"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a4ec302bf65a5627c771ab69499353cf5">getRowUpper</a> () const</td></tr>
<tr class="memdesc:a4ec302bf65a5627c771ab69499353cf5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of row upper bounds.  <a href="classOsiClpSolverInterface.html#a4ec302bf65a5627c771ab69499353cf5">More...</a><br /></td></tr>
<tr class="separator:a4ec302bf65a5627c771ab69499353cf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada8df4f17114c968593ab6d98129a9e4"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ada8df4f17114c968593ab6d98129a9e4">getObjCoefficients</a> () const</td></tr>
<tr class="memdesc:ada8df4f17114c968593ab6d98129a9e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] of objective function coefficients.  <a href="classOsiClpSolverInterface.html#ada8df4f17114c968593ab6d98129a9e4">More...</a><br /></td></tr>
<tr class="separator:ada8df4f17114c968593ab6d98129a9e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41eb185b816442f70d07179db17eadcc"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a41eb185b816442f70d07179db17eadcc">getObjSense</a> () const</td></tr>
<tr class="memdesc:a41eb185b816442f70d07179db17eadcc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get objective function sense (1 for min (default), -1 for max)  <a href="classOsiClpSolverInterface.html#a41eb185b816442f70d07179db17eadcc">More...</a><br /></td></tr>
<tr class="separator:a41eb185b816442f70d07179db17eadcc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa4a235755d36ab4c1fa0200042d8ca"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aefa4a235755d36ab4c1fa0200042d8ca">isContinuous</a> (int colNumber) const</td></tr>
<tr class="memdesc:aefa4a235755d36ab4c1fa0200042d8ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if column is continuous.  <a href="classOsiClpSolverInterface.html#aefa4a235755d36ab4c1fa0200042d8ca">More...</a><br /></td></tr>
<tr class="separator:aefa4a235755d36ab4c1fa0200042d8ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab06af3a3591898f1645f1e23d3e5241b"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ab06af3a3591898f1645f1e23d3e5241b">isBinary</a> (int colIndex) const</td></tr>
<tr class="memdesc:ab06af3a3591898f1645f1e23d3e5241b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if variable is binary.  <a href="classOsiClpSolverInterface.html#ab06af3a3591898f1645f1e23d3e5241b">More...</a><br /></td></tr>
<tr class="separator:ab06af3a3591898f1645f1e23d3e5241b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acbf97c8ee992444ea603ef616079986d"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#acbf97c8ee992444ea603ef616079986d">isInteger</a> (int colIndex) const</td></tr>
<tr class="memdesc:acbf97c8ee992444ea603ef616079986d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if column is integer.  <a href="classOsiClpSolverInterface.html#acbf97c8ee992444ea603ef616079986d">More...</a><br /></td></tr>
<tr class="separator:acbf97c8ee992444ea603ef616079986d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8149c145d1c315e449c9ff0b7082cace"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a8149c145d1c315e449c9ff0b7082cace">isIntegerNonBinary</a> (int colIndex) const</td></tr>
<tr class="memdesc:a8149c145d1c315e449c9ff0b7082cace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if variable is general integer.  <a href="classOsiClpSolverInterface.html#a8149c145d1c315e449c9ff0b7082cace">More...</a><br /></td></tr>
<tr class="separator:a8149c145d1c315e449c9ff0b7082cace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1710ae45a979601ae698e4f49e4e5ba7"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1710ae45a979601ae698e4f49e4e5ba7">isFreeBinary</a> (int colIndex) const</td></tr>
<tr class="memdesc:a1710ae45a979601ae698e4f49e4e5ba7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if variable is binary and not fixed at either bound.  <a href="classOsiClpSolverInterface.html#a1710ae45a979601ae698e4f49e4e5ba7">More...</a><br /></td></tr>
<tr class="separator:a1710ae45a979601ae698e4f49e4e5ba7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada79029eea440cc2cfaa3f4e5cca7ca8"><td class="memItemLeft" align="right" valign="top">virtual const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ada79029eea440cc2cfaa3f4e5cca7ca8">getColType</a> (bool refresh=false) const</td></tr>
<tr class="memdesc:ada79029eea440cc2cfaa3f4e5cca7ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return array of column length 0 - continuous 1 - binary (may get fixed later) 2 - general integer (may get fixed later)  <a href="classOsiClpSolverInterface.html#ada79029eea440cc2cfaa3f4e5cca7ca8">More...</a><br /></td></tr>
<tr class="separator:ada79029eea440cc2cfaa3f4e5cca7ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7bc389f903b1611f3d778cb3ab5f27b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ac7bc389f903b1611f3d778cb3ab5f27b">isOptionalInteger</a> (int colIndex) const</td></tr>
<tr class="memdesc:ac7bc389f903b1611f3d778cb3ab5f27b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true if column is integer but does not have to be declared as such.  <a href="classOsiClpSolverInterface.html#ac7bc389f903b1611f3d778cb3ab5f27b">More...</a><br /></td></tr>
<tr class="separator:ac7bc389f903b1611f3d778cb3ab5f27b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad337e31a79e1b24ae04112242b175cc5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ad337e31a79e1b24ae04112242b175cc5">setOptionalInteger</a> (int index)</td></tr>
<tr class="memdesc:ad337e31a79e1b24ae04112242b175cc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the index-th variable to be an optional integer variable.  <a href="classOsiClpSolverInterface.html#ad337e31a79e1b24ae04112242b175cc5">More...</a><br /></td></tr>
<tr class="separator:ad337e31a79e1b24ae04112242b175cc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee8578b1e3adaced3df1cb1fb0d01776"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aee8578b1e3adaced3df1cb1fb0d01776">isHeuristicInteger</a> (int colIndex) const</td></tr>
<tr class="memdesc:aee8578b1e3adaced3df1cb1fb0d01776"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return true only if integer and not optional.  <a href="classOsiClpSolverInterface.html#aee8578b1e3adaced3df1cb1fb0d01776">More...</a><br /></td></tr>
<tr class="separator:aee8578b1e3adaced3df1cb1fb0d01776"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a367ec646d066b063ab494a00b78e42"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a7a367ec646d066b063ab494a00b78e42">integerType</a> (int colIndex) const</td></tr>
<tr class="memdesc:a7a367ec646d066b063ab494a00b78e42"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return integer type (0,1,2=optional,3=sc,4=scint)  <a href="classOsiClpSolverInterface.html#a7a367ec646d066b063ab494a00b78e42">More...</a><br /></td></tr>
<tr class="separator:a7a367ec646d066b063ab494a00b78e42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae660e1a472ecfdc329afdb6e33a16bc6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ae660e1a472ecfdc329afdb6e33a16bc6">setIntegerType</a> (int colIndex, int value)</td></tr>
<tr class="memdesc:ae660e1a472ecfdc329afdb6e33a16bc6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set integer type (0,1,2=optional,3=sc,4=scint)  <a href="classOsiClpSolverInterface.html#ae660e1a472ecfdc329afdb6e33a16bc6">More...</a><br /></td></tr>
<tr class="separator:ae660e1a472ecfdc329afdb6e33a16bc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ca3e531146a9bfcfc1dd98ed1bc1d6f"><td class="memItemLeft" align="right" valign="top">virtual const CoinPackedMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a7ca3e531146a9bfcfc1dd98ed1bc1d6f">getMatrixByRow</a> () const</td></tr>
<tr class="memdesc:a7ca3e531146a9bfcfc1dd98ed1bc1d6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to row-wise copy of matrix.  <a href="classOsiClpSolverInterface.html#a7ca3e531146a9bfcfc1dd98ed1bc1d6f">More...</a><br /></td></tr>
<tr class="separator:a7ca3e531146a9bfcfc1dd98ed1bc1d6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32de030bd79988e7e1c157952df23d32"><td class="memItemLeft" align="right" valign="top">virtual const CoinPackedMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a32de030bd79988e7e1c157952df23d32">getMatrixByCol</a> () const</td></tr>
<tr class="memdesc:a32de030bd79988e7e1c157952df23d32"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to column-wise copy of matrix.  <a href="classOsiClpSolverInterface.html#a32de030bd79988e7e1c157952df23d32">More...</a><br /></td></tr>
<tr class="separator:a32de030bd79988e7e1c157952df23d32"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1405541692a9a0c7452572a3b97df0e8"><td class="memItemLeft" align="right" valign="top">virtual CoinPackedMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1405541692a9a0c7452572a3b97df0e8">getMutableMatrixByCol</a> () const</td></tr>
<tr class="memdesc:a1405541692a9a0c7452572a3b97df0e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to mutable column-wise copy of matrix.  <a href="classOsiClpSolverInterface.html#a1405541692a9a0c7452572a3b97df0e8">More...</a><br /></td></tr>
<tr class="separator:a1405541692a9a0c7452572a3b97df0e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a579966a398543bc4de25a4330baca26a"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a579966a398543bc4de25a4330baca26a">getInfinity</a> () const</td></tr>
<tr class="memdesc:a579966a398543bc4de25a4330baca26a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get solver's value for infinity.  <a href="classOsiClpSolverInterface.html#a579966a398543bc4de25a4330baca26a">More...</a><br /></td></tr>
<tr class="separator:a579966a398543bc4de25a4330baca26a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods related to querying the solution</div></td></tr>
<tr class="memitem:a80274545e65aa7f2d1886c20f3f066ca"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a80274545e65aa7f2d1886c20f3f066ca">getColSolution</a> () const</td></tr>
<tr class="memdesc:a80274545e65aa7f2d1886c20f3f066ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] of primal solution vector.  <a href="classOsiClpSolverInterface.html#a80274545e65aa7f2d1886c20f3f066ca">More...</a><br /></td></tr>
<tr class="separator:a80274545e65aa7f2d1886c20f3f066ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07e454eda2e2399afbad1f02e93ffd3f"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a07e454eda2e2399afbad1f02e93ffd3f">getRowPrice</a> () const</td></tr>
<tr class="memdesc:a07e454eda2e2399afbad1f02e93ffd3f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of dual prices.  <a href="classOsiClpSolverInterface.html#a07e454eda2e2399afbad1f02e93ffd3f">More...</a><br /></td></tr>
<tr class="separator:a07e454eda2e2399afbad1f02e93ffd3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a98cac8fa58cb64843fc0503d65af9324"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a98cac8fa58cb64843fc0503d65af9324">getReducedCost</a> () const</td></tr>
<tr class="memdesc:a98cac8fa58cb64843fc0503d65af9324"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] of reduced costs.  <a href="classOsiClpSolverInterface.html#a98cac8fa58cb64843fc0503d65af9324">More...</a><br /></td></tr>
<tr class="separator:a98cac8fa58cb64843fc0503d65af9324"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a703372e3913a64c56a45db6d35555730"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a703372e3913a64c56a45db6d35555730">getRowActivity</a> () const</td></tr>
<tr class="memdesc:a703372e3913a64c56a45db6d35555730"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of row activity levels (constraint matrix times the solution vector.  <a href="classOsiClpSolverInterface.html#a703372e3913a64c56a45db6d35555730">More...</a><br /></td></tr>
<tr class="separator:a703372e3913a64c56a45db6d35555730"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae8df7590ffcf2fd22b5cfa6677471403"><td class="memItemLeft" align="right" valign="top">virtual double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ae8df7590ffcf2fd22b5cfa6677471403">getObjValue</a> () const</td></tr>
<tr class="memdesc:ae8df7590ffcf2fd22b5cfa6677471403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get objective function value.  <a href="classOsiClpSolverInterface.html#ae8df7590ffcf2fd22b5cfa6677471403">More...</a><br /></td></tr>
<tr class="separator:ae8df7590ffcf2fd22b5cfa6677471403"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dcfb9d0053de3daf1d5f1ff6b9867e8"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a6dcfb9d0053de3daf1d5f1ff6b9867e8">getIterationCount</a> () const</td></tr>
<tr class="memdesc:a6dcfb9d0053de3daf1d5f1ff6b9867e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get how many iterations it took to solve the problem (whatever "iteration" mean to the solver.  <a href="classOsiClpSolverInterface.html#a6dcfb9d0053de3daf1d5f1ff6b9867e8">More...</a><br /></td></tr>
<tr class="separator:a6dcfb9d0053de3daf1d5f1ff6b9867e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a413048b1ff3583a4134e41fca8d52bbc"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a413048b1ff3583a4134e41fca8d52bbc">getDualRays</a> (int maxNumRays, bool fullRay=false) const</td></tr>
<tr class="memdesc:a413048b1ff3583a4134e41fca8d52bbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get as many dual rays as the solver can provide.  <a href="classOsiClpSolverInterface.html#a413048b1ff3583a4134e41fca8d52bbc">More...</a><br /></td></tr>
<tr class="separator:a413048b1ff3583a4134e41fca8d52bbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6fd7f5239e7b6336830ec6312cef4f6"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; double * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ac6fd7f5239e7b6336830ec6312cef4f6">getPrimalRays</a> (int maxNumRays) const</td></tr>
<tr class="memdesc:ac6fd7f5239e7b6336830ec6312cef4f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get as many primal rays as the solver can provide.  <a href="classOsiClpSolverInterface.html#ac6fd7f5239e7b6336830ec6312cef4f6">More...</a><br /></td></tr>
<tr class="separator:ac6fd7f5239e7b6336830ec6312cef4f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Changing bounds on variables and constraints</div></td></tr>
<tr class="memitem:acfeabd8a7955889dfe73e8943243b027"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#acfeabd8a7955889dfe73e8943243b027">setObjCoeff</a> (int elementIndex, double elementValue)</td></tr>
<tr class="memdesc:acfeabd8a7955889dfe73e8943243b027"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set an objective function coefficient.  <a href="classOsiClpSolverInterface.html#acfeabd8a7955889dfe73e8943243b027">More...</a><br /></td></tr>
<tr class="separator:acfeabd8a7955889dfe73e8943243b027"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7ad635b4dfa3ad60e2ba575c1351beb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af7ad635b4dfa3ad60e2ba575c1351beb">setColLower</a> (int elementIndex, double elementValue)</td></tr>
<tr class="memdesc:af7ad635b4dfa3ad60e2ba575c1351beb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single column lower bound<br  />
 Use -DBL_MAX for -infinity.  <a href="classOsiClpSolverInterface.html#af7ad635b4dfa3ad60e2ba575c1351beb">More...</a><br /></td></tr>
<tr class="separator:af7ad635b4dfa3ad60e2ba575c1351beb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb2521f4be78a971efee19f17d939b50"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#acb2521f4be78a971efee19f17d939b50">setColUpper</a> (int elementIndex, double elementValue)</td></tr>
<tr class="memdesc:acb2521f4be78a971efee19f17d939b50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single column upper bound<br  />
 Use DBL_MAX for infinity.  <a href="classOsiClpSolverInterface.html#acb2521f4be78a971efee19f17d939b50">More...</a><br /></td></tr>
<tr class="separator:acb2521f4be78a971efee19f17d939b50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb8599a58e34f5f3c3c803695d9e5108"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#adb8599a58e34f5f3c3c803695d9e5108">setColBounds</a> (int elementIndex, double lower, double upper)</td></tr>
<tr class="memdesc:adb8599a58e34f5f3c3c803695d9e5108"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single column lower and upper bound.  <a href="classOsiClpSolverInterface.html#adb8599a58e34f5f3c3c803695d9e5108">More...</a><br /></td></tr>
<tr class="separator:adb8599a58e34f5f3c3c803695d9e5108"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa843704c89982ad2fd47ef8f2451f888"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aa843704c89982ad2fd47ef8f2451f888">setColSetBounds</a> (const int *indexFirst, const int *indexLast, const double *boundList)</td></tr>
<tr class="memdesc:aa843704c89982ad2fd47ef8f2451f888"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounds on a number of columns simultaneously<br  />
 The default implementation just invokes <a class="el" href="classOsiClpSolverInterface.html#af7ad635b4dfa3ad60e2ba575c1351beb" title="Set a single column lower bound  Use -DBL_MAX for -infinity.">setColLower()</a> and <a class="el" href="classOsiClpSolverInterface.html#acb2521f4be78a971efee19f17d939b50" title="Set a single column upper bound  Use DBL_MAX for infinity.">setColUpper()</a> over and over again.  <a href="classOsiClpSolverInterface.html#aa843704c89982ad2fd47ef8f2451f888">More...</a><br /></td></tr>
<tr class="separator:aa843704c89982ad2fd47ef8f2451f888"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bb969c4f0a81edecc56ed50efa703ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1bb969c4f0a81edecc56ed50efa703ab">setRowLower</a> (int elementIndex, double elementValue)</td></tr>
<tr class="memdesc:a1bb969c4f0a81edecc56ed50efa703ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single row lower bound<br  />
 Use -DBL_MAX for -infinity.  <a href="classOsiClpSolverInterface.html#a1bb969c4f0a81edecc56ed50efa703ab">More...</a><br /></td></tr>
<tr class="separator:a1bb969c4f0a81edecc56ed50efa703ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0011352b97994d61eef03c82efe395"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a0c0011352b97994d61eef03c82efe395">setRowUpper</a> (int elementIndex, double elementValue)</td></tr>
<tr class="memdesc:a0c0011352b97994d61eef03c82efe395"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single row upper bound<br  />
 Use DBL_MAX for infinity.  <a href="classOsiClpSolverInterface.html#a0c0011352b97994d61eef03c82efe395">More...</a><br /></td></tr>
<tr class="separator:a0c0011352b97994d61eef03c82efe395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb778249973ea9143e73b9c2b3cc1158"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aeb778249973ea9143e73b9c2b3cc1158">setRowBounds</a> (int elementIndex, double lower, double upper)</td></tr>
<tr class="memdesc:aeb778249973ea9143e73b9c2b3cc1158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set a single row lower and upper bound.  <a href="classOsiClpSolverInterface.html#aeb778249973ea9143e73b9c2b3cc1158">More...</a><br /></td></tr>
<tr class="separator:aeb778249973ea9143e73b9c2b3cc1158"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69a9603a8fc04db3114624ec93651a0a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a69a9603a8fc04db3114624ec93651a0a">setRowType</a> (int index, char sense, double rightHandSide, double range)</td></tr>
<tr class="memdesc:a69a9603a8fc04db3114624ec93651a0a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type of a single row<br  />
  <a href="classOsiClpSolverInterface.html#a69a9603a8fc04db3114624ec93651a0a">More...</a><br /></td></tr>
<tr class="separator:a69a9603a8fc04db3114624ec93651a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69de6c070854da442eeaee0722af666f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a69de6c070854da442eeaee0722af666f">setRowSetBounds</a> (const int *indexFirst, const int *indexLast, const double *boundList)</td></tr>
<tr class="memdesc:a69de6c070854da442eeaee0722af666f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the bounds on a number of rows simultaneously<br  />
 The default implementation just invokes <a class="el" href="classOsiClpSolverInterface.html#a1bb969c4f0a81edecc56ed50efa703ab" title="Set a single row lower bound  Use -DBL_MAX for -infinity.">setRowLower()</a> and <a class="el" href="classOsiClpSolverInterface.html#a0c0011352b97994d61eef03c82efe395" title="Set a single row upper bound  Use DBL_MAX for infinity.">setRowUpper()</a> over and over again.  <a href="classOsiClpSolverInterface.html#a69de6c070854da442eeaee0722af666f">More...</a><br /></td></tr>
<tr class="separator:a69de6c070854da442eeaee0722af666f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72f1cff6f904e182a365762e50b6c203"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a72f1cff6f904e182a365762e50b6c203">setRowSetTypes</a> (const int *indexFirst, const int *indexLast, const char *senseList, const double *rhsList, const double *rangeList)</td></tr>
<tr class="memdesc:a72f1cff6f904e182a365762e50b6c203"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the type of a number of rows simultaneously<br  />
 The default implementation just invokes <a class="el" href="classOsiClpSolverInterface.html#a69a9603a8fc04db3114624ec93651a0a" title="Set the type of a single row">setRowType()</a> over and over again.  <a href="classOsiClpSolverInterface.html#a72f1cff6f904e182a365762e50b6c203">More...</a><br /></td></tr>
<tr class="separator:a72f1cff6f904e182a365762e50b6c203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71bd5744ecc5cc953e05a3f6ce39a7ca"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a71bd5744ecc5cc953e05a3f6ce39a7ca">setObjective</a> (const double *array)</td></tr>
<tr class="memdesc:a71bd5744ecc5cc953e05a3f6ce39a7ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the objective coefficients for all columns array [<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] is an array of values for the objective.  <a href="classOsiClpSolverInterface.html#a71bd5744ecc5cc953e05a3f6ce39a7ca">More...</a><br /></td></tr>
<tr class="separator:a71bd5744ecc5cc953e05a3f6ce39a7ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a752e9d78bf5013f488387032aa4699fb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a752e9d78bf5013f488387032aa4699fb">setColLower</a> (const double *array)</td></tr>
<tr class="memdesc:a752e9d78bf5013f488387032aa4699fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the lower bounds for all columns array [<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] is an array of values for the objective.  <a href="classOsiClpSolverInterface.html#a752e9d78bf5013f488387032aa4699fb">More...</a><br /></td></tr>
<tr class="separator:a752e9d78bf5013f488387032aa4699fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ae48b8f0149458c8e9ab15a4924cb27"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a7ae48b8f0149458c8e9ab15a4924cb27">setColUpper</a> (const double *array)</td></tr>
<tr class="memdesc:a7ae48b8f0149458c8e9ab15a4924cb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the upper bounds for all columns array [<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] is an array of values for the objective.  <a href="classOsiClpSolverInterface.html#a7ae48b8f0149458c8e9ab15a4924cb27">More...</a><br /></td></tr>
<tr class="separator:a7ae48b8f0149458c8e9ab15a4924cb27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a408a81bd8abe355907bf30f99ddc5b12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a408a81bd8abe355907bf30f99ddc5b12">setRowName</a> (int rowIndex, std::string name)</td></tr>
<tr class="memdesc:a408a81bd8abe355907bf30f99ddc5b12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set name of row.  <a href="classOsiClpSolverInterface.html#a408a81bd8abe355907bf30f99ddc5b12">More...</a><br /></td></tr>
<tr class="separator:a408a81bd8abe355907bf30f99ddc5b12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6acd6c25299f00078731c0571ca45fc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a6acd6c25299f00078731c0571ca45fc9">setColName</a> (int colIndex, std::string name)</td></tr>
<tr class="memdesc:a6acd6c25299f00078731c0571ca45fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set name of column.  <a href="classOsiClpSolverInterface.html#a6acd6c25299f00078731c0571ca45fc9">More...</a><br /></td></tr>
<tr class="separator:a6acd6c25299f00078731c0571ca45fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Integrality related changing methods</div></td></tr>
<tr class="memitem:a46e81d910b92594492fa80c7ca0a7707"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a46e81d910b92594492fa80c7ca0a7707">setContinuous</a> (int index)</td></tr>
<tr class="memdesc:a46e81d910b92594492fa80c7ca0a7707"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the index-th variable to be a continuous variable.  <a href="classOsiClpSolverInterface.html#a46e81d910b92594492fa80c7ca0a7707">More...</a><br /></td></tr>
<tr class="separator:a46e81d910b92594492fa80c7ca0a7707"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a54c3f7658476b76c58453a4c1078a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af5a54c3f7658476b76c58453a4c1078a">setInteger</a> (int index)</td></tr>
<tr class="memdesc:af5a54c3f7658476b76c58453a4c1078a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the index-th variable to be an integer variable.  <a href="classOsiClpSolverInterface.html#af5a54c3f7658476b76c58453a4c1078a">More...</a><br /></td></tr>
<tr class="separator:af5a54c3f7658476b76c58453a4c1078a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e186b5b794f65a55de1eb6906891fcb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a2e186b5b794f65a55de1eb6906891fcb">setContinuous</a> (const int *indices, int len)</td></tr>
<tr class="memdesc:a2e186b5b794f65a55de1eb6906891fcb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the variables listed in indices (which is of length len) to be continuous variables.  <a href="classOsiClpSolverInterface.html#a2e186b5b794f65a55de1eb6906891fcb">More...</a><br /></td></tr>
<tr class="separator:a2e186b5b794f65a55de1eb6906891fcb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a577f7cbc5f7e1cf13368e64abb9b420a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a577f7cbc5f7e1cf13368e64abb9b420a">setInteger</a> (const int *indices, int len)</td></tr>
<tr class="memdesc:a577f7cbc5f7e1cf13368e64abb9b420a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the variables listed in indices (which is of length len) to be integer variables.  <a href="classOsiClpSolverInterface.html#a577f7cbc5f7e1cf13368e64abb9b420a">More...</a><br /></td></tr>
<tr class="separator:a577f7cbc5f7e1cf13368e64abb9b420a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefa00df8c16f20d5e7e7b020c7cee677"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aefa00df8c16f20d5e7e7b020c7cee677">numberSOS</a> () const</td></tr>
<tr class="memdesc:aefa00df8c16f20d5e7e7b020c7cee677"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of SOS sets.  <a href="classOsiClpSolverInterface.html#aefa00df8c16f20d5e7e7b020c7cee677">More...</a><br /></td></tr>
<tr class="separator:aefa00df8c16f20d5e7e7b020c7cee677"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a52d913906c846882ae9a0bf9c1cd8225"><td class="memItemLeft" align="right" valign="top">const CoinSet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a52d913906c846882ae9a0bf9c1cd8225">setInfo</a> () const</td></tr>
<tr class="memdesc:a52d913906c846882ae9a0bf9c1cd8225"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOS set info.  <a href="classOsiClpSolverInterface.html#a52d913906c846882ae9a0bf9c1cd8225">More...</a><br /></td></tr>
<tr class="separator:a52d913906c846882ae9a0bf9c1cd8225"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e8ac72d8a1463dd9d85254b6ebf6bdf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a5e8ac72d8a1463dd9d85254b6ebf6bdf">replaceSetInfo</a> (int <a class="el" href="classOsiClpSolverInterface.html#aefa00df8c16f20d5e7e7b020c7cee677">numberSOS</a>, CoinSet *<a class="el" href="classOsiClpSolverInterface.html#a52d913906c846882ae9a0bf9c1cd8225">setInfo</a>)</td></tr>
<tr class="memdesc:a5e8ac72d8a1463dd9d85254b6ebf6bdf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace setInfo (takes over ownership)  <a href="classOsiClpSolverInterface.html#a5e8ac72d8a1463dd9d85254b6ebf6bdf">More...</a><br /></td></tr>
<tr class="separator:a5e8ac72d8a1463dd9d85254b6ebf6bdf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a26b649e4085c4c84774445df74bc86dd"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a26b649e4085c4c84774445df74bc86dd">findIntegersAndSOS</a> (bool justCount)</td></tr>
<tr class="memdesc:a26b649e4085c4c84774445df74bc86dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identify integer variables and SOS and create corresponding objects.  <a href="classOsiClpSolverInterface.html#a26b649e4085c4c84774445df74bc86dd">More...</a><br /></td></tr>
<tr class="separator:a26b649e4085c4c84774445df74bc86dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ae350335a84969fd61ffb39d7efb8ab"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a5ae350335a84969fd61ffb39d7efb8ab">setObjSense</a> (double s)</td></tr>
<tr class="memdesc:a5ae350335a84969fd61ffb39d7efb8ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set objective function sense (1 for min (default), -1 for max,)  <a href="classOsiClpSolverInterface.html#a5ae350335a84969fd61ffb39d7efb8ab">More...</a><br /></td></tr>
<tr class="separator:a5ae350335a84969fd61ffb39d7efb8ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80830b885caff6079556d4bdb7403ad5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a80830b885caff6079556d4bdb7403ad5">setColSolution</a> (const double *colsol)</td></tr>
<tr class="memdesc:a80830b885caff6079556d4bdb7403ad5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the primal solution column values.  <a href="classOsiClpSolverInterface.html#a80830b885caff6079556d4bdb7403ad5">More...</a><br /></td></tr>
<tr class="separator:a80830b885caff6079556d4bdb7403ad5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b00c8fdbf8f2b141fdae89e0c453b18"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a0b00c8fdbf8f2b141fdae89e0c453b18">setRowPrice</a> (const double *rowprice)</td></tr>
<tr class="memdesc:a0b00c8fdbf8f2b141fdae89e0c453b18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set dual solution vector.  <a href="classOsiClpSolverInterface.html#a0b00c8fdbf8f2b141fdae89e0c453b18">More...</a><br /></td></tr>
<tr class="separator:a0b00c8fdbf8f2b141fdae89e0c453b18"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to expand a problem.&lt;br&gt;</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Note that if a column is added then by default it will correspond to a continuous variable. </p>
</div></td></tr>
<tr class="memitem:ae1468e0c5aab6c3b3b3fe0e3010c43ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ae1468e0c5aab6c3b3b3fe0e3010c43ac">addCol</a> (const CoinPackedVectorBase &amp;vec, const double collb, const double colub, const double obj)</td></tr>
<tr class="separator:ae1468e0c5aab6c3b3b3fe0e3010c43ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a93cd285d584c3a7d9b3dc8d7697f1a6d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a93cd285d584c3a7d9b3dc8d7697f1a6d">addCol</a> (const CoinPackedVectorBase &amp;vec, const double collb, const double colub, const double obj, std::string name)</td></tr>
<tr class="memdesc:a93cd285d584c3a7d9b3dc8d7697f1a6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a named column (primal variable) to the problem.  <a href="classOsiClpSolverInterface.html#a93cd285d584c3a7d9b3dc8d7697f1a6d">More...</a><br /></td></tr>
<tr class="separator:a93cd285d584c3a7d9b3dc8d7697f1a6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae67dab111b39d36f5df74c47bed91c2b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ae67dab111b39d36f5df74c47bed91c2b">addCol</a> (int numberElements, const int *rows, const double *elements, const double collb, const double colub, const double obj)</td></tr>
<tr class="memdesc:ae67dab111b39d36f5df74c47bed91c2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a column (primal variable) to the problem.  <a href="classOsiClpSolverInterface.html#ae67dab111b39d36f5df74c47bed91c2b">More...</a><br /></td></tr>
<tr class="separator:ae67dab111b39d36f5df74c47bed91c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd8f7cfccfae51be9b8308a9b097518d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#abd8f7cfccfae51be9b8308a9b097518d">addCol</a> (int numberElements, const int *rows, const double *elements, const double collb, const double colub, const double obj, std::string name)</td></tr>
<tr class="memdesc:abd8f7cfccfae51be9b8308a9b097518d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a named column (primal variable) to the problem.  <a href="classOsiClpSolverInterface.html#abd8f7cfccfae51be9b8308a9b097518d">More...</a><br /></td></tr>
<tr class="separator:abd8f7cfccfae51be9b8308a9b097518d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96d210a3c5aaacc450616e22c9a030af"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a96d210a3c5aaacc450616e22c9a030af">addCols</a> (const int numcols, const CoinPackedVectorBase *const *cols, const double *collb, const double *colub, const double *obj)</td></tr>
<tr class="separator:a96d210a3c5aaacc450616e22c9a030af"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0329ae1907d0c1f3dc550f36dd1faf4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af0329ae1907d0c1f3dc550f36dd1faf4">addCols</a> (const int numcols, const CoinBigIndex *columnStarts, const int *rows, const double *elements, const double *collb, const double *colub, const double *obj)</td></tr>
<tr class="separator:af0329ae1907d0c1f3dc550f36dd1faf4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3940432d91d0f1b536c5a9c99d9d1560"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a3940432d91d0f1b536c5a9c99d9d1560">deleteCols</a> (const int num, const int *colIndices)</td></tr>
<tr class="separator:a3940432d91d0f1b536c5a9c99d9d1560"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea382607dd0226a0b1429c48f1d9d961"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aea382607dd0226a0b1429c48f1d9d961">addRow</a> (const CoinPackedVectorBase &amp;vec, const double rowlb, const double rowub)</td></tr>
<tr class="separator:aea382607dd0226a0b1429c48f1d9d961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ada55990289350a103c82df44c3072a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1ada55990289350a103c82df44c3072a">addRow</a> (const CoinPackedVectorBase &amp;vec, const double rowlb, const double rowub, std::string name)</td></tr>
<tr class="memdesc:a1ada55990289350a103c82df44c3072a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a named row (constraint) to the problem.  <a href="classOsiClpSolverInterface.html#a1ada55990289350a103c82df44c3072a">More...</a><br /></td></tr>
<tr class="separator:a1ada55990289350a103c82df44c3072a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae952a09cb2d96a3519d4d34f049691d6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ae952a09cb2d96a3519d4d34f049691d6">addRow</a> (const CoinPackedVectorBase &amp;vec, const char rowsen, const double rowrhs, const double rowrng)</td></tr>
<tr class="separator:ae952a09cb2d96a3519d4d34f049691d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64713b9b7038f65a6d8edc4acebde69b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a64713b9b7038f65a6d8edc4acebde69b">addRow</a> (int numberElements, const int *columns, const double *element, const double rowlb, const double rowub)</td></tr>
<tr class="memdesc:a64713b9b7038f65a6d8edc4acebde69b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a row (constraint) to the problem.  <a href="classOsiClpSolverInterface.html#a64713b9b7038f65a6d8edc4acebde69b">More...</a><br /></td></tr>
<tr class="separator:a64713b9b7038f65a6d8edc4acebde69b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12afc2fb8b9eb71f2ba38ec6d70f21fa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a12afc2fb8b9eb71f2ba38ec6d70f21fa">addRow</a> (const CoinPackedVectorBase &amp;vec, const char rowsen, const double rowrhs, const double rowrng, std::string name)</td></tr>
<tr class="memdesc:a12afc2fb8b9eb71f2ba38ec6d70f21fa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a named row (constraint) to the problem.  <a href="classOsiClpSolverInterface.html#a12afc2fb8b9eb71f2ba38ec6d70f21fa">More...</a><br /></td></tr>
<tr class="separator:a12afc2fb8b9eb71f2ba38ec6d70f21fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a481ef9b452cde75397367ee976b6a003"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a481ef9b452cde75397367ee976b6a003">addRows</a> (const int numrows, const CoinPackedVectorBase *const *rows, const double *rowlb, const double *rowub)</td></tr>
<tr class="separator:a481ef9b452cde75397367ee976b6a003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04eb479511f001d28c34fe90141e3b6b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a04eb479511f001d28c34fe90141e3b6b">addRows</a> (const int numrows, const CoinPackedVectorBase *const *rows, const char *rowsen, const double *rowrhs, const double *rowrng)</td></tr>
<tr class="separator:a04eb479511f001d28c34fe90141e3b6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c89064d8ad103b5dab917542c7fccaa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1c89064d8ad103b5dab917542c7fccaa">addRows</a> (const int numrows, const CoinBigIndex *rowStarts, const int *columns, const double *element, const double *rowlb, const double *rowub)</td></tr>
<tr class="separator:a1c89064d8ad103b5dab917542c7fccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5853c50fb27c6c56e98c5d2027fa8a1a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a5853c50fb27c6c56e98c5d2027fa8a1a">modifyCoefficient</a> (int row, int column, double newElement, bool keepZero=false)</td></tr>
<tr class="separator:a5853c50fb27c6c56e98c5d2027fa8a1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a378db4535176e47f22c06731be8b3d3c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a378db4535176e47f22c06731be8b3d3c">deleteRows</a> (const int num, const int *rowIndices)</td></tr>
<tr class="separator:a378db4535176e47f22c06731be8b3d3c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28693577027085f44c0befc067032dae"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a28693577027085f44c0befc067032dae">saveBaseModel</a> ()</td></tr>
<tr class="memdesc:a28693577027085f44c0befc067032dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">If solver wants it can save a copy of "base" (continuous) model here.  <a href="classOsiClpSolverInterface.html#a28693577027085f44c0befc067032dae">More...</a><br /></td></tr>
<tr class="separator:a28693577027085f44c0befc067032dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff5ef8d2ccfb179050c6bf7d152c7578"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aff5ef8d2ccfb179050c6bf7d152c7578">restoreBaseModel</a> (int numberRows)</td></tr>
<tr class="memdesc:aff5ef8d2ccfb179050c6bf7d152c7578"><td class="mdescLeft">&#160;</td><td class="mdescRight">Strip off rows to get to this number of rows.  <a href="classOsiClpSolverInterface.html#aff5ef8d2ccfb179050c6bf7d152c7578">More...</a><br /></td></tr>
<tr class="separator:aff5ef8d2ccfb179050c6bf7d152c7578"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6370d8bba83369f9f779402d4ce0cd59"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a6370d8bba83369f9f779402d4ce0cd59">applyRowCuts</a> (int numberCuts, const OsiRowCut *cuts)</td></tr>
<tr class="memdesc:a6370d8bba83369f9f779402d4ce0cd59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a collection of row cuts which are all effective.  <a href="classOsiClpSolverInterface.html#a6370d8bba83369f9f779402d4ce0cd59">More...</a><br /></td></tr>
<tr class="separator:a6370d8bba83369f9f779402d4ce0cd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5dd0fb25ca9258b6c96f780dce53437a"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a5dd0fb25ca9258b6c96f780dce53437a">applyRowCuts</a> (int numberCuts, const OsiRowCut **cuts)</td></tr>
<tr class="memdesc:a5dd0fb25ca9258b6c96f780dce53437a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a collection of row cuts which are all effective.  <a href="classOsiClpSolverInterface.html#a5dd0fb25ca9258b6c96f780dce53437a">More...</a><br /></td></tr>
<tr class="separator:a5dd0fb25ca9258b6c96f780dce53437a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b8335b1ecb23cbe52d28166fb9cf385"><td class="memItemLeft" align="right" valign="top">virtual ApplyCutsReturnCode&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1b8335b1ecb23cbe52d28166fb9cf385">applyCuts</a> (const OsiCuts &amp;cs, double effectivenessLb=0.0)</td></tr>
<tr class="memdesc:a1b8335b1ecb23cbe52d28166fb9cf385"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a collection of cuts.  <a href="classOsiClpSolverInterface.html#a1b8335b1ecb23cbe52d28166fb9cf385">More...</a><br /></td></tr>
<tr class="separator:a1b8335b1ecb23cbe52d28166fb9cf385"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Methods to input a problem</div></td></tr>
<tr class="memitem:a228ef777d30c109b2d9deee997340af6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a228ef777d30c109b2d9deee997340af6">loadProblem</a> (const CoinPackedMatrix &amp;matrix, const double *collb, const double *colub, const double *obj, const double *rowlb, const double *rowub)</td></tr>
<tr class="memdesc:a228ef777d30c109b2d9deee997340af6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load in an problem by copying the arguments (the constraints on the rows are given by lower and upper bounds).  <a href="classOsiClpSolverInterface.html#a228ef777d30c109b2d9deee997340af6">More...</a><br /></td></tr>
<tr class="separator:a228ef777d30c109b2d9deee997340af6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaff08407a8bebafe8b7ed913e4e6bc5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aeaff08407a8bebafe8b7ed913e4e6bc5">assignProblem</a> (CoinPackedMatrix *&amp;matrix, double *&amp;collb, double *&amp;colub, double *&amp;obj, double *&amp;rowlb, double *&amp;rowub)</td></tr>
<tr class="memdesc:aeaff08407a8bebafe8b7ed913e4e6bc5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load in an problem by assuming ownership of the arguments (the constraints on the rows are given by lower and upper bounds).  <a href="classOsiClpSolverInterface.html#aeaff08407a8bebafe8b7ed913e4e6bc5">More...</a><br /></td></tr>
<tr class="separator:aeaff08407a8bebafe8b7ed913e4e6bc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e0c384df66ab3174d0fe82e0eebcc72"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a7e0c384df66ab3174d0fe82e0eebcc72">loadProblem</a> (const CoinPackedMatrix &amp;matrix, const double *collb, const double *colub, const double *obj, const char *rowsen, const double *rowrhs, const double *rowrng)</td></tr>
<tr class="memdesc:a7e0c384df66ab3174d0fe82e0eebcc72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load in an problem by copying the arguments (the constraints on the rows are given by sense/rhs/range triplets).  <a href="classOsiClpSolverInterface.html#a7e0c384df66ab3174d0fe82e0eebcc72">More...</a><br /></td></tr>
<tr class="separator:a7e0c384df66ab3174d0fe82e0eebcc72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88ce6695fa4291f371c9dfdd9bf0113e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a88ce6695fa4291f371c9dfdd9bf0113e">assignProblem</a> (CoinPackedMatrix *&amp;matrix, double *&amp;collb, double *&amp;colub, double *&amp;obj, char *&amp;rowsen, double *&amp;rowrhs, double *&amp;rowrng)</td></tr>
<tr class="memdesc:a88ce6695fa4291f371c9dfdd9bf0113e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Load in an problem by assuming ownership of the arguments (the constraints on the rows are given by sense/rhs/range triplets).  <a href="classOsiClpSolverInterface.html#a88ce6695fa4291f371c9dfdd9bf0113e">More...</a><br /></td></tr>
<tr class="separator:a88ce6695fa4291f371c9dfdd9bf0113e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c70cc873bc5757b82b6425fe147c0cb"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a9c70cc873bc5757b82b6425fe147c0cb">loadProblem</a> (const <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a> &amp;matrix, const double *collb, const double *colub, const double *obj, const double *rowlb, const double *rowub)</td></tr>
<tr class="memdesc:a9c70cc873bc5757b82b6425fe147c0cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the other <a class="el" href="classOsiClpSolverInterface.html#a228ef777d30c109b2d9deee997340af6" title="Load in an problem by copying the arguments (the constraints on the rows are given by lower and upper...">loadProblem()</a> methods except that the matrix is given as a <a class="el" href="classClpMatrixBase.html" title="Abstract base class for Clp Matrices.">ClpMatrixBase</a>.  <a href="classOsiClpSolverInterface.html#a9c70cc873bc5757b82b6425fe147c0cb">More...</a><br /></td></tr>
<tr class="separator:a9c70cc873bc5757b82b6425fe147c0cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a735e5b67e255999e37d3cb49bef1fe1b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a735e5b67e255999e37d3cb49bef1fe1b">loadProblem</a> (const int numcols, const int numrows, const CoinBigIndex *start, const int *index, const double *value, const double *collb, const double *colub, const double *obj, const double *rowlb, const double *rowub)</td></tr>
<tr class="memdesc:a735e5b67e255999e37d3cb49bef1fe1b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the other <a class="el" href="classOsiClpSolverInterface.html#a228ef777d30c109b2d9deee997340af6" title="Load in an problem by copying the arguments (the constraints on the rows are given by lower and upper...">loadProblem()</a> methods except that the matrix is given in a standard column major ordered format (without gaps).  <a href="classOsiClpSolverInterface.html#a735e5b67e255999e37d3cb49bef1fe1b">More...</a><br /></td></tr>
<tr class="separator:a735e5b67e255999e37d3cb49bef1fe1b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ee1584ae1f0e65a97dacee30f44ad17"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a7ee1584ae1f0e65a97dacee30f44ad17">loadProblem</a> (const int numcols, const int numrows, const CoinBigIndex *start, const int *index, const double *value, const double *collb, const double *colub, const double *obj, const char *rowsen, const double *rowrhs, const double *rowrng)</td></tr>
<tr class="memdesc:a7ee1584ae1f0e65a97dacee30f44ad17"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just like the other <a class="el" href="classOsiClpSolverInterface.html#a228ef777d30c109b2d9deee997340af6" title="Load in an problem by copying the arguments (the constraints on the rows are given by lower and upper...">loadProblem()</a> methods except that the matrix is given in a standard column major ordered format (without gaps).  <a href="classOsiClpSolverInterface.html#a7ee1584ae1f0e65a97dacee30f44ad17">More...</a><br /></td></tr>
<tr class="separator:a7ee1584ae1f0e65a97dacee30f44ad17"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfeefbd150fa18f72a9507615bc4a0dc"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#acfeefbd150fa18f72a9507615bc4a0dc">loadFromCoinModel</a> (CoinModel &amp;modelObject, bool keepSolution=false)</td></tr>
<tr class="memdesc:acfeefbd150fa18f72a9507615bc4a0dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This loads a model from a coinModel object - returns number of errors.  <a href="classOsiClpSolverInterface.html#acfeefbd150fa18f72a9507615bc4a0dc">More...</a><br /></td></tr>
<tr class="separator:acfeefbd150fa18f72a9507615bc4a0dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71e6eb66d43ab27d931b71be0a0a76ec"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a71e6eb66d43ab27d931b71be0a0a76ec">readMps</a> (const char *filename, const char *extension=&quot;mps&quot;)</td></tr>
<tr class="memdesc:a71e6eb66d43ab27d931b71be0a0a76ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an mps file from the given filename (defaults to Osi reader) - returns number of errors (see OsiMpsReader class)  <a href="classOsiClpSolverInterface.html#a71e6eb66d43ab27d931b71be0a0a76ec">More...</a><br /></td></tr>
<tr class="separator:a71e6eb66d43ab27d931b71be0a0a76ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aedd68d7b3e54507a1afa0df0712f76d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aedd68d7b3e54507a1afa0df0712f76d1">readMps</a> (const char *filename, bool keepNames, bool allowErrors)</td></tr>
<tr class="memdesc:aedd68d7b3e54507a1afa0df0712f76d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an mps file from the given filename returns number of errors (see OsiMpsReader class)  <a href="classOsiClpSolverInterface.html#aedd68d7b3e54507a1afa0df0712f76d1">More...</a><br /></td></tr>
<tr class="separator:aedd68d7b3e54507a1afa0df0712f76d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b9626cb116e1dbd4bc20c70dc622c76"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1b9626cb116e1dbd4bc20c70dc622c76">readMps</a> (const char *filename, const char *extension, int &amp;numberSets, CoinSet **&amp;sets)</td></tr>
<tr class="memdesc:a1b9626cb116e1dbd4bc20c70dc622c76"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read an mps file.  <a href="classOsiClpSolverInterface.html#a1b9626cb116e1dbd4bc20c70dc622c76">More...</a><br /></td></tr>
<tr class="separator:a1b9626cb116e1dbd4bc20c70dc622c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae76540b2b75c79fb2b3172f466e134f8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ae76540b2b75c79fb2b3172f466e134f8">writeMps</a> (const char *filename, const char *extension=&quot;mps&quot;, double objSense=0.0) const</td></tr>
<tr class="memdesc:ae76540b2b75c79fb2b3172f466e134f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the problem into an mps file of the given filename.  <a href="classOsiClpSolverInterface.html#ae76540b2b75c79fb2b3172f466e134f8">More...</a><br /></td></tr>
<tr class="separator:ae76540b2b75c79fb2b3172f466e134f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad567bab4c941cc2c2952b7e5dccbe5f1"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ad567bab4c941cc2c2952b7e5dccbe5f1">writeMpsNative</a> (const char *filename, const char **rowNames, const char **columnNames, int formatType=0, int numberAcross=2, double objSense=0.0) const</td></tr>
<tr class="memdesc:ad567bab4c941cc2c2952b7e5dccbe5f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the problem into an mps file of the given filename, names may be null.  <a href="classOsiClpSolverInterface.html#ad567bab4c941cc2c2952b7e5dccbe5f1">More...</a><br /></td></tr>
<tr class="separator:ad567bab4c941cc2c2952b7e5dccbe5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad13f9e98ebaec68ce028d5aec95e6c38"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ad13f9e98ebaec68ce028d5aec95e6c38">readLp</a> (const char *filename, const double epsilon=1e-5)</td></tr>
<tr class="memdesc:ad13f9e98ebaec68ce028d5aec95e6c38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read file in LP format (with names)  <a href="classOsiClpSolverInterface.html#ad13f9e98ebaec68ce028d5aec95e6c38">More...</a><br /></td></tr>
<tr class="separator:ad13f9e98ebaec68ce028d5aec95e6c38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad552991179c48acf6568c33f02000a0b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ad552991179c48acf6568c33f02000a0b">writeLp</a> (const char *filename, const char *extension=&quot;lp&quot;, double epsilon=1e-5, int numberAcross=10, int decimals=5, double objSense=0.0, bool useRowNames=true) const</td></tr>
<tr class="memdesc:ad552991179c48acf6568c33f02000a0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the problem into an Lp file of the given filename.  <a href="classOsiClpSolverInterface.html#ad552991179c48acf6568c33f02000a0b">More...</a><br /></td></tr>
<tr class="separator:ad552991179c48acf6568c33f02000a0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af35d271b386dce75c94f224ffd9f6687"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af35d271b386dce75c94f224ffd9f6687">writeLp</a> (FILE *fp, double epsilon=1e-5, int numberAcross=10, int decimals=5, double objSense=0.0, bool useRowNames=true) const</td></tr>
<tr class="memdesc:af35d271b386dce75c94f224ffd9f6687"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the problem into the file pointed to by the parameter fp.  <a href="classOsiClpSolverInterface.html#af35d271b386dce75c94f224ffd9f6687">More...</a><br /></td></tr>
<tr class="separator:af35d271b386dce75c94f224ffd9f6687"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11d22f6ccd5410fdb8b8c71ad6af2817"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a11d22f6ccd5410fdb8b8c71ad6af2817">replaceMatrixOptional</a> (const CoinPackedMatrix &amp;matrix)</td></tr>
<tr class="memdesc:a11d22f6ccd5410fdb8b8c71ad6af2817"><td class="mdescLeft">&#160;</td><td class="mdescRight">I (JJF) am getting annoyed because I can't just replace a matrix.  <a href="classOsiClpSolverInterface.html#a11d22f6ccd5410fdb8b8c71ad6af2817">More...</a><br /></td></tr>
<tr class="separator:a11d22f6ccd5410fdb8b8c71ad6af2817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16ab3e2181d85df73c6ccd5743265fc9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a16ab3e2181d85df73c6ccd5743265fc9">replaceMatrix</a> (const CoinPackedMatrix &amp;matrix)</td></tr>
<tr class="memdesc:a16ab3e2181d85df73c6ccd5743265fc9"><td class="mdescLeft">&#160;</td><td class="mdescRight">And if it does matter (not used at present)  <a href="classOsiClpSolverInterface.html#a16ab3e2181d85df73c6ccd5743265fc9">More...</a><br /></td></tr>
<tr class="separator:a16ab3e2181d85df73c6ccd5743265fc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Message handling (extra for Clp messages).</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Normally I presume you would want the same language.</p>
<p>If not then you could use underlying model pointer </p>
</div></td></tr>
<tr class="memitem:ad553e1ca376c5e7a476e32dfcb322c66"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ad553e1ca376c5e7a476e32dfcb322c66">passInMessageHandler</a> (CoinMessageHandler *handler)</td></tr>
<tr class="memdesc:ad553e1ca376c5e7a476e32dfcb322c66"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass in a message handler.  <a href="classOsiClpSolverInterface.html#ad553e1ca376c5e7a476e32dfcb322c66">More...</a><br /></td></tr>
<tr class="separator:ad553e1ca376c5e7a476e32dfcb322c66"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7aa0b4761574324fb446a041ab577fbc"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a7aa0b4761574324fb446a041ab577fbc">newLanguage</a> (CoinMessages::Language language)</td></tr>
<tr class="memdesc:a7aa0b4761574324fb446a041ab577fbc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set language.  <a href="classOsiClpSolverInterface.html#a7aa0b4761574324fb446a041ab577fbc">More...</a><br /></td></tr>
<tr class="separator:a7aa0b4761574324fb446a041ab577fbc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb85941297ab13ddb85641ca3a20e322"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#abb85941297ab13ddb85641ca3a20e322">setLanguage</a> (CoinMessages::Language language)</td></tr>
<tr class="separator:abb85941297ab13ddb85641ca3a20e322"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2aed8d42b43ddd37032fd17381519d81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a2aed8d42b43ddd37032fd17381519d81">setLogLevel</a> (int value)</td></tr>
<tr class="memdesc:a2aed8d42b43ddd37032fd17381519d81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set log level (will also set underlying solver's log level)  <a href="classOsiClpSolverInterface.html#a2aed8d42b43ddd37032fd17381519d81">More...</a><br /></td></tr>
<tr class="separator:a2aed8d42b43ddd37032fd17381519d81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d340272124d03f6671cf0f1c6dfee13"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a6d340272124d03f6671cf0f1c6dfee13">generateCpp</a> (FILE *fp)</td></tr>
<tr class="memdesc:a6d340272124d03f6671cf0f1c6dfee13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create C++ lines to get to current state.  <a href="classOsiClpSolverInterface.html#a6d340272124d03f6671cf0f1c6dfee13">More...</a><br /></td></tr>
<tr class="separator:a6d340272124d03f6671cf0f1c6dfee13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Clp specific public interfaces</div></td></tr>
<tr class="memitem:a9577a39c03540e4ad904bb7cf121806b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a9577a39c03540e4ad904bb7cf121806b">getModelPtr</a> () const</td></tr>
<tr class="memdesc:a9577a39c03540e4ad904bb7cf121806b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get pointer to Clp model.  <a href="classOsiClpSolverInterface.html#a9577a39c03540e4ad904bb7cf121806b">More...</a><br /></td></tr>
<tr class="separator:a9577a39c03540e4ad904bb7cf121806b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa7dbf164c916541bd3cb39bee3227d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#afa7dbf164c916541bd3cb39bee3227d4">swapModelPtr</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *newModel)</td></tr>
<tr class="memdesc:afa7dbf164c916541bd3cb39bee3227d4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set pointer to Clp model and return old.  <a href="classOsiClpSolverInterface.html#afa7dbf164c916541bd3cb39bee3227d4">More...</a><br /></td></tr>
<tr class="separator:afa7dbf164c916541bd3cb39bee3227d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7dcd2092995ba51a233cb61acf16317a"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a7dcd2092995ba51a233cb61acf16317a">specialOptions</a> () const</td></tr>
<tr class="memdesc:a7dcd2092995ba51a233cb61acf16317a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get special options.  <a href="classOsiClpSolverInterface.html#a7dcd2092995ba51a233cb61acf16317a">More...</a><br /></td></tr>
<tr class="separator:a7dcd2092995ba51a233cb61acf16317a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d2dddda6180e8239d3124e41e0c37f2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a9d2dddda6180e8239d3124e41e0c37f2">setSpecialOptions</a> (unsigned int value)</td></tr>
<tr class="separator:a9d2dddda6180e8239d3124e41e0c37f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3c37219c4fa31a1c4fd809bfef80f9f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ac3c37219c4fa31a1c4fd809bfef80f9f">lastAlgorithm</a> () const</td></tr>
<tr class="memdesc:ac3c37219c4fa31a1c4fd809bfef80f9f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last algorithm used , 1 = primal, 2 = dual other unknown.  <a href="classOsiClpSolverInterface.html#ac3c37219c4fa31a1c4fd809bfef80f9f">More...</a><br /></td></tr>
<tr class="separator:ac3c37219c4fa31a1c4fd809bfef80f9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffbbbcdd1c3e960ba3dce3444e555e4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a8ffbbbcdd1c3e960ba3dce3444e555e4">setLastAlgorithm</a> (int value)</td></tr>
<tr class="memdesc:a8ffbbbcdd1c3e960ba3dce3444e555e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set last algorithm used , 1 = primal, 2 = dual other unknown.  <a href="classOsiClpSolverInterface.html#a8ffbbbcdd1c3e960ba3dce3444e555e4">More...</a><br /></td></tr>
<tr class="separator:a8ffbbbcdd1c3e960ba3dce3444e555e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a958fc25c2359f38da835c4d09711d30c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a958fc25c2359f38da835c4d09711d30c">cleanupScaling</a> () const</td></tr>
<tr class="memdesc:a958fc25c2359f38da835c4d09711d30c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get scaling action option.  <a href="classOsiClpSolverInterface.html#a958fc25c2359f38da835c4d09711d30c">More...</a><br /></td></tr>
<tr class="separator:a958fc25c2359f38da835c4d09711d30c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae27edb77b9dd2fc9ae1727963af8bc07"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ae27edb77b9dd2fc9ae1727963af8bc07">setCleanupScaling</a> (int value)</td></tr>
<tr class="memdesc:ae27edb77b9dd2fc9ae1727963af8bc07"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set Scaling option When scaling is on it is possible that the scaled problem is feasible but the unscaled is not.  <a href="classOsiClpSolverInterface.html#ae27edb77b9dd2fc9ae1727963af8bc07">More...</a><br /></td></tr>
<tr class="separator:ae27edb77b9dd2fc9ae1727963af8bc07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae16c5e2861c7d372206b4a8a81fd9ab"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aae16c5e2861c7d372206b4a8a81fd9ab">smallestElementInCut</a> () const</td></tr>
<tr class="memdesc:aae16c5e2861c7d372206b4a8a81fd9ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get smallest allowed element in cut.  <a href="classOsiClpSolverInterface.html#aae16c5e2861c7d372206b4a8a81fd9ab">More...</a><br /></td></tr>
<tr class="separator:aae16c5e2861c7d372206b4a8a81fd9ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdd9d00e96318dc9a5d55f4f5c86f26"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a9fdd9d00e96318dc9a5d55f4f5c86f26">setSmallestElementInCut</a> (double value)</td></tr>
<tr class="memdesc:a9fdd9d00e96318dc9a5d55f4f5c86f26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set smallest allowed element in cut.  <a href="classOsiClpSolverInterface.html#a9fdd9d00e96318dc9a5d55f4f5c86f26">More...</a><br /></td></tr>
<tr class="separator:a9fdd9d00e96318dc9a5d55f4f5c86f26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a531c41b4eac2898020415d84793a5d69"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a531c41b4eac2898020415d84793a5d69">smallestChangeInCut</a> () const</td></tr>
<tr class="memdesc:a531c41b4eac2898020415d84793a5d69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get smallest change in cut.  <a href="classOsiClpSolverInterface.html#a531c41b4eac2898020415d84793a5d69">More...</a><br /></td></tr>
<tr class="separator:a531c41b4eac2898020415d84793a5d69"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab14155ba949f890a974628cd585bda92"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ab14155ba949f890a974628cd585bda92">setSmallestChangeInCut</a> (double value)</td></tr>
<tr class="memdesc:ab14155ba949f890a974628cd585bda92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set smallest change in cut.  <a href="classOsiClpSolverInterface.html#ab14155ba949f890a974628cd585bda92">More...</a><br /></td></tr>
<tr class="separator:ab14155ba949f890a974628cd585bda92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea55f2e6e78b45ca0eefe96e11dd2525"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aea55f2e6e78b45ca0eefe96e11dd2525">setSolveOptions</a> (const <a class="el" href="classClpSolve.html">ClpSolve</a> &amp;options)</td></tr>
<tr class="memdesc:aea55f2e6e78b45ca0eefe96e11dd2525"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass in initial solve options.  <a href="classOsiClpSolverInterface.html#aea55f2e6e78b45ca0eefe96e11dd2525">More...</a><br /></td></tr>
<tr class="separator:aea55f2e6e78b45ca0eefe96e11dd2525"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08a48e701969bc18ccd1177d05f6d901"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a08a48e701969bc18ccd1177d05f6d901">tightenBounds</a> (int lightweight=0)</td></tr>
<tr class="memdesc:a08a48e701969bc18ccd1177d05f6d901"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tighten bounds - lightweight or very lightweight 0 - normal, 1 lightweight but just integers, 2 lightweight and all.  <a href="classOsiClpSolverInterface.html#a08a48e701969bc18ccd1177d05f6d901">More...</a><br /></td></tr>
<tr class="separator:a08a48e701969bc18ccd1177d05f6d901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06e31cd87c914e365ee2f1d3e6c36e70"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a06e31cd87c914e365ee2f1d3e6c36e70">infeasibleOtherWay</a> (char *whichWay)</td></tr>
<tr class="memdesc:a06e31cd87c914e365ee2f1d3e6c36e70"><td class="mdescLeft">&#160;</td><td class="mdescRight">See if any integer variables make infeasible other way.  <a href="classOsiClpSolverInterface.html#a06e31cd87c914e365ee2f1d3e6c36e70">More...</a><br /></td></tr>
<tr class="separator:a06e31cd87c914e365ee2f1d3e6c36e70"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a083487a2bc3bb6a6c528101af0a81678"><td class="memItemLeft" align="right" valign="top">virtual CoinBigIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a083487a2bc3bb6a6c528101af0a81678">getSizeL</a> () const</td></tr>
<tr class="memdesc:a083487a2bc3bb6a6c528101af0a81678"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of entries in L part of current factorization.  <a href="classOsiClpSolverInterface.html#a083487a2bc3bb6a6c528101af0a81678">More...</a><br /></td></tr>
<tr class="separator:a083487a2bc3bb6a6c528101af0a81678"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0e91556cf6d2fad259f30a4cdac65a2f"><td class="memItemLeft" align="right" valign="top">virtual CoinBigIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a0e91556cf6d2fad259f30a4cdac65a2f">getSizeU</a> () const</td></tr>
<tr class="memdesc:a0e91556cf6d2fad259f30a4cdac65a2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return number of entries in U part of current factorization.  <a href="classOsiClpSolverInterface.html#a0e91556cf6d2fad259f30a4cdac65a2f">More...</a><br /></td></tr>
<tr class="separator:a0e91556cf6d2fad259f30a4cdac65a2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad00b4825d3bf98d45874de1b7fdf61b9"><td class="memItemLeft" align="right" valign="top">const <a class="el" href="classOsiClpDisasterHandler.html">OsiClpDisasterHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ad00b4825d3bf98d45874de1b7fdf61b9">disasterHandler</a> () const</td></tr>
<tr class="memdesc:ad00b4825d3bf98d45874de1b7fdf61b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get disaster handler.  <a href="classOsiClpSolverInterface.html#ad00b4825d3bf98d45874de1b7fdf61b9">More...</a><br /></td></tr>
<tr class="separator:ad00b4825d3bf98d45874de1b7fdf61b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b86ec65d8000c64506f6a4f36c75d05"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a2b86ec65d8000c64506f6a4f36c75d05">passInDisasterHandler</a> (<a class="el" href="classOsiClpDisasterHandler.html">OsiClpDisasterHandler</a> *handler)</td></tr>
<tr class="memdesc:a2b86ec65d8000c64506f6a4f36c75d05"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass in disaster handler.  <a href="classOsiClpSolverInterface.html#a2b86ec65d8000c64506f6a4f36c75d05">More...</a><br /></td></tr>
<tr class="separator:a2b86ec65d8000c64506f6a4f36c75d05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7460cfa449b2dd317cf2e48c1756fb2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpLinearObjective.html">ClpLinearObjective</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af7460cfa449b2dd317cf2e48c1756fb2">fakeObjective</a> () const</td></tr>
<tr class="memdesc:af7460cfa449b2dd317cf2e48c1756fb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get fake objective.  <a href="classOsiClpSolverInterface.html#af7460cfa449b2dd317cf2e48c1756fb2">More...</a><br /></td></tr>
<tr class="separator:af7460cfa449b2dd317cf2e48c1756fb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01694cda8754fb13e5908abdc05d9bc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a01694cda8754fb13e5908abdc05d9bc7">setFakeObjective</a> (<a class="el" href="classClpLinearObjective.html">ClpLinearObjective</a> *<a class="el" href="classOsiClpSolverInterface.html#af7460cfa449b2dd317cf2e48c1756fb2">fakeObjective</a>)</td></tr>
<tr class="memdesc:a01694cda8754fb13e5908abdc05d9bc7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set fake objective (and take ownership)  <a href="classOsiClpSolverInterface.html#a01694cda8754fb13e5908abdc05d9bc7">More...</a><br /></td></tr>
<tr class="separator:a01694cda8754fb13e5908abdc05d9bc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a30869740fdf6788a5a1f43ac025de2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a0a30869740fdf6788a5a1f43ac025de2">setFakeObjective</a> (double *<a class="el" href="classOsiClpSolverInterface.html#af7460cfa449b2dd317cf2e48c1756fb2">fakeObjective</a>)</td></tr>
<tr class="memdesc:a0a30869740fdf6788a5a1f43ac025de2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set fake objective.  <a href="classOsiClpSolverInterface.html#a0a30869740fdf6788a5a1f43ac025de2">More...</a><br /></td></tr>
<tr class="separator:a0a30869740fdf6788a5a1f43ac025de2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad932fba66cd3aa626fa4875c3dfde84b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ad932fba66cd3aa626fa4875c3dfde84b">setupForRepeatedUse</a> (int senseOfAdventure=0, int printOut=0)</td></tr>
<tr class="memdesc:ad932fba66cd3aa626fa4875c3dfde84b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set up solver for repeated use by Osi interface.  <a href="classOsiClpSolverInterface.html#ad932fba66cd3aa626fa4875c3dfde84b">More...</a><br /></td></tr>
<tr class="separator:ad932fba66cd3aa626fa4875c3dfde84b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72881558f5275d18064d6dc7e17cdc7f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a72881558f5275d18064d6dc7e17cdc7f">synchronizeModel</a> ()</td></tr>
<tr class="memdesc:a72881558f5275d18064d6dc7e17cdc7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize model (really if no cuts in tree)  <a href="classOsiClpSolverInterface.html#a72881558f5275d18064d6dc7e17cdc7f">More...</a><br /></td></tr>
<tr class="separator:a72881558f5275d18064d6dc7e17cdc7f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47ada3e0f4cbd065d5569d5eba0bb942"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a47ada3e0f4cbd065d5569d5eba0bb942">setSpecialOptionsMutable</a> (unsigned int value) const</td></tr>
<tr class="memdesc:a47ada3e0f4cbd065d5569d5eba0bb942"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set special options in underlying clp solver.  <a href="classOsiClpSolverInterface.html#a47ada3e0f4cbd065d5569d5eba0bb942">More...</a><br /></td></tr>
<tr class="separator:a47ada3e0f4cbd065d5569d5eba0bb942"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Constructors and destructors</div></td></tr>
<tr class="memitem:a61222d5a8e9074b8eb7af95cd0d86dd7"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a61222d5a8e9074b8eb7af95cd0d86dd7">OsiClpSolverInterface</a> ()</td></tr>
<tr class="memdesc:a61222d5a8e9074b8eb7af95cd0d86dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default Constructor.  <a href="classOsiClpSolverInterface.html#a61222d5a8e9074b8eb7af95cd0d86dd7">More...</a><br /></td></tr>
<tr class="separator:a61222d5a8e9074b8eb7af95cd0d86dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2dc398be8a0cc03a189cca5c1234add4"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="Idiot_8hpp.html#a6ab52e0531bad8c380587f176e4360df">OsiSolverInterface</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a2dc398be8a0cc03a189cca5c1234add4">clone</a> (bool copyData=true) const</td></tr>
<tr class="memdesc:a2dc398be8a0cc03a189cca5c1234add4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clone.  <a href="classOsiClpSolverInterface.html#a2dc398be8a0cc03a189cca5c1234add4">More...</a><br /></td></tr>
<tr class="separator:a2dc398be8a0cc03a189cca5c1234add4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4534530dc04501410115568ca71190"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a2e4534530dc04501410115568ca71190">OsiClpSolverInterface</a> (const <a class="el" href="classOsiClpSolverInterface.html">OsiClpSolverInterface</a> &amp;)</td></tr>
<tr class="memdesc:a2e4534530dc04501410115568ca71190"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy constructor.  <a href="classOsiClpSolverInterface.html#a2e4534530dc04501410115568ca71190">More...</a><br /></td></tr>
<tr class="separator:a2e4534530dc04501410115568ca71190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa5ebf1382466440dfb8b44bdc1eed379"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aa5ebf1382466440dfb8b44bdc1eed379">OsiClpSolverInterface</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *rhs, bool reallyOwn=false)</td></tr>
<tr class="memdesc:aa5ebf1382466440dfb8b44bdc1eed379"><td class="mdescLeft">&#160;</td><td class="mdescRight">Borrow constructor - only delete one copy.  <a href="classOsiClpSolverInterface.html#aa5ebf1382466440dfb8b44bdc1eed379">More...</a><br /></td></tr>
<tr class="separator:aa5ebf1382466440dfb8b44bdc1eed379"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a17bffe09a1ba89c163993bc547199c8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a17bffe09a1ba89c163993bc547199c8e">releaseClp</a> ()</td></tr>
<tr class="memdesc:a17bffe09a1ba89c163993bc547199c8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Releases so won't error.  <a href="classOsiClpSolverInterface.html#a17bffe09a1ba89c163993bc547199c8e">More...</a><br /></td></tr>
<tr class="separator:a17bffe09a1ba89c163993bc547199c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4178b31ccbcf045bf822d018ad3cfa26"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOsiClpSolverInterface.html">OsiClpSolverInterface</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a4178b31ccbcf045bf822d018ad3cfa26">operator=</a> (const <a class="el" href="classOsiClpSolverInterface.html">OsiClpSolverInterface</a> &amp;rhs)</td></tr>
<tr class="memdesc:a4178b31ccbcf045bf822d018ad3cfa26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Assignment operator.  <a href="classOsiClpSolverInterface.html#a4178b31ccbcf045bf822d018ad3cfa26">More...</a><br /></td></tr>
<tr class="separator:a4178b31ccbcf045bf822d018ad3cfa26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a168cff685b6511734efce2fa3ecf3806"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a168cff685b6511734efce2fa3ecf3806">~OsiClpSolverInterface</a> ()</td></tr>
<tr class="memdesc:a168cff685b6511734efce2fa3ecf3806"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor.  <a href="classOsiClpSolverInterface.html#a168cff685b6511734efce2fa3ecf3806">More...</a><br /></td></tr>
<tr class="separator:a168cff685b6511734efce2fa3ecf3806"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab65eb7d74f48acd8848ab46ae1797403"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ab65eb7d74f48acd8848ab46ae1797403">reset</a> ()</td></tr>
<tr class="memdesc:ab65eb7d74f48acd8848ab46ae1797403"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets as if default constructor.  <a href="classOsiClpSolverInterface.html#ab65eb7d74f48acd8848ab46ae1797403">More...</a><br /></td></tr>
<tr class="separator:ab65eb7d74f48acd8848ab46ae1797403"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Protected member data</div></td></tr>
<tr class="memitem:ab2815665a2a99269e429d5113e60d1cb"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ab2815665a2a99269e429d5113e60d1cb">modelPtr_</a></td></tr>
<tr class="memdesc:ab2815665a2a99269e429d5113e60d1cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clp model represented by this class instance.  <a href="classOsiClpSolverInterface.html#ab2815665a2a99269e429d5113e60d1cb">More...</a><br /></td></tr>
<tr class="separator:ab2815665a2a99269e429d5113e60d1cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Cached information derived from the OSL model</div></td></tr>
<tr class="memitem:acbd7966521fde35de32fd8d325032900"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#acbd7966521fde35de32fd8d325032900">rowsense_</a></td></tr>
<tr class="memdesc:acbd7966521fde35de32fd8d325032900"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to dense vector of row sense indicators.  <a href="classOsiClpSolverInterface.html#acbd7966521fde35de32fd8d325032900">More...</a><br /></td></tr>
<tr class="separator:acbd7966521fde35de32fd8d325032900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d6939f2f1abb39d9e3bbddeb7b96ad4"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a6d6939f2f1abb39d9e3bbddeb7b96ad4">rhs_</a></td></tr>
<tr class="memdesc:a6d6939f2f1abb39d9e3bbddeb7b96ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to dense vector of row right-hand side values.  <a href="classOsiClpSolverInterface.html#a6d6939f2f1abb39d9e3bbddeb7b96ad4">More...</a><br /></td></tr>
<tr class="separator:a6d6939f2f1abb39d9e3bbddeb7b96ad4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cbb647af9581a777f0edce2bc18d453"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1cbb647af9581a777f0edce2bc18d453">rowrange_</a></td></tr>
<tr class="memdesc:a1cbb647af9581a777f0edce2bc18d453"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to dense vector of slack upper bounds for range constraints (undefined for non-range rows)  <a href="classOsiClpSolverInterface.html#a1cbb647af9581a777f0edce2bc18d453">More...</a><br /></td></tr>
<tr class="separator:a1cbb647af9581a777f0edce2bc18d453"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0149ee3f0cec228faff142568bca125"><td class="memItemLeft" align="right" valign="top">CoinWarmStartBasis *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ab0149ee3f0cec228faff142568bca125">ws_</a></td></tr>
<tr class="memdesc:ab0149ee3f0cec228faff142568bca125"><td class="mdescLeft">&#160;</td><td class="mdescRight">A pointer to the warmstart information to be used in the hotstarts.  <a href="classOsiClpSolverInterface.html#ab0149ee3f0cec228faff142568bca125">More...</a><br /></td></tr>
<tr class="separator:ab0149ee3f0cec228faff142568bca125"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27e6212416f58142ed7bbce0f80cde2d"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a27e6212416f58142ed7bbce0f80cde2d">rowActivity_</a></td></tr>
<tr class="memdesc:a27e6212416f58142ed7bbce0f80cde2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">also save row and column information for hot starts only used in hotstarts so can be casual  <a href="classOsiClpSolverInterface.html#a27e6212416f58142ed7bbce0f80cde2d">More...</a><br /></td></tr>
<tr class="separator:a27e6212416f58142ed7bbce0f80cde2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19b4e53082b8dbcdd2fb70f026ea641"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af19b4e53082b8dbcdd2fb70f026ea641">columnActivity_</a></td></tr>
<tr class="separator:af19b4e53082b8dbcdd2fb70f026ea641"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5edc14b61053283117c233b8749e76b8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpNodeStuff.html">ClpNodeStuff</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a5edc14b61053283117c233b8749e76b8">stuff_</a></td></tr>
<tr class="memdesc:a5edc14b61053283117c233b8749e76b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Stuff for fast dual.  <a href="classOsiClpSolverInterface.html#a5edc14b61053283117c233b8749e76b8">More...</a><br /></td></tr>
<tr class="separator:a5edc14b61053283117c233b8749e76b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef1648e5f85f60f11fcced9d401fc960"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aef1648e5f85f60f11fcced9d401fc960">numberSOS_</a></td></tr>
<tr class="memdesc:aef1648e5f85f60f11fcced9d401fc960"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of SOS sets.  <a href="classOsiClpSolverInterface.html#aef1648e5f85f60f11fcced9d401fc960">More...</a><br /></td></tr>
<tr class="separator:aef1648e5f85f60f11fcced9d401fc960"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a719c9d7cdc83a46587244d2a0233cbdd"><td class="memItemLeft" align="right" valign="top">CoinSet *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a719c9d7cdc83a46587244d2a0233cbdd">setInfo_</a></td></tr>
<tr class="memdesc:a719c9d7cdc83a46587244d2a0233cbdd"><td class="mdescLeft">&#160;</td><td class="mdescRight">SOS set info.  <a href="classOsiClpSolverInterface.html#a719c9d7cdc83a46587244d2a0233cbdd">More...</a><br /></td></tr>
<tr class="separator:a719c9d7cdc83a46587244d2a0233cbdd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abd2e756a6e20b2d99d83370c131a1fa1"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#abd2e756a6e20b2d99d83370c131a1fa1">smallModel_</a></td></tr>
<tr class="memdesc:abd2e756a6e20b2d99d83370c131a1fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Alternate model (hot starts) - but also could be permanent and used for crunch.  <a href="classOsiClpSolverInterface.html#abd2e756a6e20b2d99d83370c131a1fa1">More...</a><br /></td></tr>
<tr class="separator:abd2e756a6e20b2d99d83370c131a1fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44d477161567beb76d3df7a6aeb347f5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpFactorization.html">ClpFactorization</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a44d477161567beb76d3df7a6aeb347f5">factorization_</a></td></tr>
<tr class="memdesc:a44d477161567beb76d3df7a6aeb347f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">factorization for hot starts  <a href="classOsiClpSolverInterface.html#a44d477161567beb76d3df7a6aeb347f5">More...</a><br /></td></tr>
<tr class="separator:a44d477161567beb76d3df7a6aeb347f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab00234551a5a2d9ac7a11ab55c56f088"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ab00234551a5a2d9ac7a11ab55c56f088">smallestElementInCut_</a></td></tr>
<tr class="memdesc:ab00234551a5a2d9ac7a11ab55c56f088"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest allowed element in cut.  <a href="classOsiClpSolverInterface.html#ab00234551a5a2d9ac7a11ab55c56f088">More...</a><br /></td></tr>
<tr class="separator:ab00234551a5a2d9ac7a11ab55c56f088"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5dabc487fe74aeffb69095ffe3a2327"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ab5dabc487fe74aeffb69095ffe3a2327">smallestChangeInCut_</a></td></tr>
<tr class="memdesc:ab5dabc487fe74aeffb69095ffe3a2327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Smallest change in cut.  <a href="classOsiClpSolverInterface.html#ab5dabc487fe74aeffb69095ffe3a2327">More...</a><br /></td></tr>
<tr class="separator:ab5dabc487fe74aeffb69095ffe3a2327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34ddffd4483663d67dd36a4a5f29498b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a34ddffd4483663d67dd36a4a5f29498b">largestAway_</a></td></tr>
<tr class="memdesc:a34ddffd4483663d67dd36a4a5f29498b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Largest amount continuous away from bound.  <a href="classOsiClpSolverInterface.html#a34ddffd4483663d67dd36a4a5f29498b">More...</a><br /></td></tr>
<tr class="separator:a34ddffd4483663d67dd36a4a5f29498b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098c433d8c10eb81a1e655f917572958"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a098c433d8c10eb81a1e655f917572958">spareArrays_</a></td></tr>
<tr class="memdesc:a098c433d8c10eb81a1e655f917572958"><td class="mdescLeft">&#160;</td><td class="mdescRight">Arrays for hot starts.  <a href="classOsiClpSolverInterface.html#a098c433d8c10eb81a1e655f917572958">More...</a><br /></td></tr>
<tr class="separator:a098c433d8c10eb81a1e655f917572958"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0f42d8cbdb2af91d92568a5204a1724"><td class="memItemLeft" align="right" valign="top">CoinWarmStartBasis&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ae0f42d8cbdb2af91d92568a5204a1724">basis_</a></td></tr>
<tr class="memdesc:ae0f42d8cbdb2af91d92568a5204a1724"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warmstart information to be used in resolves.  <a href="classOsiClpSolverInterface.html#ae0f42d8cbdb2af91d92568a5204a1724">More...</a><br /></td></tr>
<tr class="separator:ae0f42d8cbdb2af91d92568a5204a1724"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525c549e0d6fc957c3fd4bde9d1cdb54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a525c549e0d6fc957c3fd4bde9d1cdb54">itlimOrig_</a></td></tr>
<tr class="memdesc:a525c549e0d6fc957c3fd4bde9d1cdb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">The original iteration limit before hotstarts started.  <a href="classOsiClpSolverInterface.html#a525c549e0d6fc957c3fd4bde9d1cdb54">More...</a><br /></td></tr>
<tr class="separator:a525c549e0d6fc957c3fd4bde9d1cdb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0affa03c5dce4d9f954705959423e5fc"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a0affa03c5dce4d9f954705959423e5fc">lastAlgorithm_</a></td></tr>
<tr class="memdesc:a0affa03c5dce4d9f954705959423e5fc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Last algorithm used.  <a href="classOsiClpSolverInterface.html#a0affa03c5dce4d9f954705959423e5fc">More...</a><br /></td></tr>
<tr class="separator:a0affa03c5dce4d9f954705959423e5fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d5b032db5b28fe0ddbdda082b414ca8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a6d5b032db5b28fe0ddbdda082b414ca8">notOwned_</a></td></tr>
<tr class="memdesc:a6d5b032db5b28fe0ddbdda082b414ca8"><td class="mdescLeft">&#160;</td><td class="mdescRight">To say if destructor should delete underlying model.  <a href="classOsiClpSolverInterface.html#a6d5b032db5b28fe0ddbdda082b414ca8">More...</a><br /></td></tr>
<tr class="separator:a6d5b032db5b28fe0ddbdda082b414ca8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa74566a1c75bb5a807dd5f514e729a1"><td class="memItemLeft" align="right" valign="top">CoinPackedMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#afa74566a1c75bb5a807dd5f514e729a1">matrixByRow_</a></td></tr>
<tr class="memdesc:afa74566a1c75bb5a807dd5f514e729a1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to row-wise copy of problem matrix coefficients.  <a href="classOsiClpSolverInterface.html#afa74566a1c75bb5a807dd5f514e729a1">More...</a><br /></td></tr>
<tr class="separator:afa74566a1c75bb5a807dd5f514e729a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab51dc36f5d12341e187a3432ef5eff0f"><td class="memItemLeft" align="right" valign="top">CoinPackedMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ab51dc36f5d12341e187a3432ef5eff0f">matrixByRowAtContinuous_</a></td></tr>
<tr class="memdesc:ab51dc36f5d12341e187a3432ef5eff0f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to row-wise copy of continuous problem matrix coefficients.  <a href="classOsiClpSolverInterface.html#ab51dc36f5d12341e187a3432ef5eff0f">More...</a><br /></td></tr>
<tr class="separator:ab51dc36f5d12341e187a3432ef5eff0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb69cea32357dec588e7b7d75ff55ce6"><td class="memItemLeft" align="right" valign="top">char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#adb69cea32357dec588e7b7d75ff55ce6">integerInformation_</a></td></tr>
<tr class="memdesc:adb69cea32357dec588e7b7d75ff55ce6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to integer information.  <a href="classOsiClpSolverInterface.html#adb69cea32357dec588e7b7d75ff55ce6">More...</a><br /></td></tr>
<tr class="separator:adb69cea32357dec588e7b7d75ff55ce6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa298fae5fd1f70c8870ceb410454282a"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aa298fae5fd1f70c8870ceb410454282a">whichRange_</a></td></tr>
<tr class="memdesc:aa298fae5fd1f70c8870ceb410454282a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pointer to variables for which we want range information The number is in [0] memory is not owned by OsiClp.  <a href="classOsiClpSolverInterface.html#aa298fae5fd1f70c8870ceb410454282a">More...</a><br /></td></tr>
<tr class="separator:aa298fae5fd1f70c8870ceb410454282a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa012f157eb1df678b34cd7ea00b3cb7a"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aa012f157eb1df678b34cd7ea00b3cb7a">fakeMinInSimplex_</a></td></tr>
<tr class="memdesc:aa012f157eb1df678b34cd7ea00b3cb7a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Faking min to get proper dual solution signs in simplex API.  <a href="classOsiClpSolverInterface.html#aa012f157eb1df678b34cd7ea00b3cb7a">More...</a><br /></td></tr>
<tr class="separator:aa012f157eb1df678b34cd7ea00b3cb7a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0005cf6cbc5263b278fa8a5df86c235b"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a0005cf6cbc5263b278fa8a5df86c235b">linearObjective_</a></td></tr>
<tr class="memdesc:a0005cf6cbc5263b278fa8a5df86c235b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linear objective.  <a href="classOsiClpSolverInterface.html#a0005cf6cbc5263b278fa8a5df86c235b">More...</a><br /></td></tr>
<tr class="separator:a0005cf6cbc5263b278fa8a5df86c235b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc5a58d87861cf4ed01b52637de09b0e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpDataSave.html">ClpDataSave</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#acc5a58d87861cf4ed01b52637de09b0e">saveData_</a></td></tr>
<tr class="memdesc:acc5a58d87861cf4ed01b52637de09b0e"><td class="mdescLeft">&#160;</td><td class="mdescRight">To save data in OsiSimplex stuff.  <a href="classOsiClpSolverInterface.html#acc5a58d87861cf4ed01b52637de09b0e">More...</a><br /></td></tr>
<tr class="separator:acc5a58d87861cf4ed01b52637de09b0e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76af8a50327a6577eba593133f544f53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpSolve.html">ClpSolve</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a76af8a50327a6577eba593133f544f53">solveOptions_</a></td></tr>
<tr class="memdesc:a76af8a50327a6577eba593133f544f53"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structOptions.html" title="******** DATA to be moved into protected section of ClpInterior">Options</a> for initialSolve.  <a href="classOsiClpSolverInterface.html#a76af8a50327a6577eba593133f544f53">More...</a><br /></td></tr>
<tr class="separator:a76af8a50327a6577eba593133f544f53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3d03de970c2dac4b22f4c60fa9e997a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af3d03de970c2dac4b22f4c60fa9e997a">cleanupScaling_</a></td></tr>
<tr class="memdesc:af3d03de970c2dac4b22f4c60fa9e997a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scaling option When scaling is on it is possible that the scaled problem is feasible but the unscaled is not.  <a href="classOsiClpSolverInterface.html#af3d03de970c2dac4b22f4c60fa9e997a">More...</a><br /></td></tr>
<tr class="separator:af3d03de970c2dac4b22f4c60fa9e997a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80902478f92e331fb967ce4ebe323e26"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a80902478f92e331fb967ce4ebe323e26">specialOptions_</a></td></tr>
<tr class="memdesc:a80902478f92e331fb967ce4ebe323e26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special options 0x80000000 off 0 simple stuff for branch and bound 1 try and keep work regions as much as possible 2 do not use any perturbation 4 allow exit before re-factorization 8 try and re-use factorization if no cuts 16 use standard strong branching rather than clp's 32 Just go to first factorization in fast dual 64 try and tighten bounds in crunch 128 Model will only change in column bounds 256 Clean up model before hot start 512 Give user direct access to Clp regions in getBInvARow etc (i.e., do not unscale, and do not return result in getBInv parameters; you have to know where to look for the answer) 1024 Don't "borrow" model in initialSolve 2048 Don't crunch 4096 quick check for optimality Bits above 8192 give where called from in Cbc At present 0 is normal, 1 doing fast hotstarts, 2 is can do quick check 65536 Keep simple i.e.  <a href="classOsiClpSolverInterface.html#a80902478f92e331fb967ce4ebe323e26">More...</a><br /></td></tr>
<tr class="separator:a80902478f92e331fb967ce4ebe323e26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a464f5511e3c6bf4657bc215274098894"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a464f5511e3c6bf4657bc215274098894">baseModel_</a></td></tr>
<tr class="memdesc:a464f5511e3c6bf4657bc215274098894"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copy of model when option 131072 set.  <a href="classOsiClpSolverInterface.html#a464f5511e3c6bf4657bc215274098894">More...</a><br /></td></tr>
<tr class="separator:a464f5511e3c6bf4657bc215274098894"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f4880eae7802d9edc15c88ddb9e6479"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a8f4880eae7802d9edc15c88ddb9e6479">lastNumberRows_</a></td></tr>
<tr class="memdesc:a8f4880eae7802d9edc15c88ddb9e6479"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows when last "scaled".  <a href="classOsiClpSolverInterface.html#a8f4880eae7802d9edc15c88ddb9e6479">More...</a><br /></td></tr>
<tr class="separator:a8f4880eae7802d9edc15c88ddb9e6479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d0270a116537eabd6b5b3b7d3096c27"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a9d0270a116537eabd6b5b3b7d3096c27">continuousModel_</a></td></tr>
<tr class="memdesc:a9d0270a116537eabd6b5b3b7d3096c27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Continuous model.  <a href="classOsiClpSolverInterface.html#a9d0270a116537eabd6b5b3b7d3096c27">More...</a><br /></td></tr>
<tr class="separator:a9d0270a116537eabd6b5b3b7d3096c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76e0f4e3ab56e46898b825091405e7df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classOsiClpDisasterHandler.html">OsiClpDisasterHandler</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a76e0f4e3ab56e46898b825091405e7df">disasterHandler_</a></td></tr>
<tr class="memdesc:a76e0f4e3ab56e46898b825091405e7df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Possible disaster handler.  <a href="classOsiClpSolverInterface.html#a76e0f4e3ab56e46898b825091405e7df">More...</a><br /></td></tr>
<tr class="separator:a76e0f4e3ab56e46898b825091405e7df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b468a1a163605fc1c8632b3bd91e4a5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpLinearObjective.html">ClpLinearObjective</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a1b468a1a163605fc1c8632b3bd91e4a5">fakeObjective_</a></td></tr>
<tr class="memdesc:a1b468a1a163605fc1c8632b3bd91e4a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fake objective.  <a href="classOsiClpSolverInterface.html#a1b468a1a163605fc1c8632b3bd91e4a5">More...</a><br /></td></tr>
<tr class="separator:a1b468a1a163605fc1c8632b3bd91e4a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a082365931cabf500cd78f80713382154"><td class="memItemLeft" align="right" valign="top">CoinDoubleArrayWithLength&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a082365931cabf500cd78f80713382154">rowScale_</a></td></tr>
<tr class="memdesc:a082365931cabf500cd78f80713382154"><td class="mdescLeft">&#160;</td><td class="mdescRight">Row scale factors (has inverse at end)  <a href="classOsiClpSolverInterface.html#a082365931cabf500cd78f80713382154">More...</a><br /></td></tr>
<tr class="separator:a082365931cabf500cd78f80713382154"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c0010566bad50980b7f7fc7386a7c6f"><td class="memItemLeft" align="right" valign="top">CoinDoubleArrayWithLength&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a9c0010566bad50980b7f7fc7386a7c6f">columnScale_</a></td></tr>
<tr class="memdesc:a9c0010566bad50980b7f7fc7386a7c6f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Column scale factors (has inverse at end)  <a href="classOsiClpSolverInterface.html#a9c0010566bad50980b7f7fc7386a7c6f">More...</a><br /></td></tr>
<tr class="separator:a9c0010566bad50980b7f7fc7386a7c6f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="friends"></a>
Friends</h2></td></tr>
<tr class="memitem:a7750ff55db8f06514b1f119b40e66526"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a7750ff55db8f06514b1f119b40e66526">OsiClpSolverInterfaceUnitTest</a> (const std::string &amp;mpsDir, const std::string &amp;netlibDir)</td></tr>
<tr class="memdesc:a7750ff55db8f06514b1f119b40e66526"><td class="mdescLeft">&#160;</td><td class="mdescRight">A function that tests the methods in the <a class="el" href="classOsiClpSolverInterface.html" title="Clp Solver Interface.">OsiClpSolverInterface</a> class.  <a href="classOsiClpSolverInterface.html#a7750ff55db8f06514b1f119b40e66526">More...</a><br /></td></tr>
<tr class="separator:a7750ff55db8f06514b1f119b40e66526"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Protected methods</h2></td></tr>
<tr class="memitem:a200f4473f1941caf32cb737743f6c93e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a200f4473f1941caf32cb737743f6c93e">setBasis</a> (const CoinWarmStartBasis &amp;basis)</td></tr>
<tr class="memdesc:a200f4473f1941caf32cb737743f6c93e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up working basis as a copy of input and puts in as basis.  <a href="classOsiClpSolverInterface.html#a200f4473f1941caf32cb737743f6c93e">More...</a><br /></td></tr>
<tr class="separator:a200f4473f1941caf32cb737743f6c93e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac03aa68cbedc4cb92c28501b83b03d20"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ac03aa68cbedc4cb92c28501b83b03d20">setBasis</a> ()</td></tr>
<tr class="memdesc:ac03aa68cbedc4cb92c28501b83b03d20"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just puts current basis_ into <a class="el" href="classClpSimplex.html" title="This solves LPs using the simplex method.">ClpSimplex</a> model.  <a href="classOsiClpSolverInterface.html#ac03aa68cbedc4cb92c28501b83b03d20">More...</a><br /></td></tr>
<tr class="separator:ac03aa68cbedc4cb92c28501b83b03d20"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a562565110ca30492b92674b02389e2"><td class="memItemLeft" align="right" valign="top">CoinWarmStartDiff *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a3a562565110ca30492b92674b02389e2">getBasisDiff</a> (const unsigned char *statusArray) const</td></tr>
<tr class="memdesc:a3a562565110ca30492b92674b02389e2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warm start difference from basis_ to statusArray.  <a href="classOsiClpSolverInterface.html#a3a562565110ca30492b92674b02389e2">More...</a><br /></td></tr>
<tr class="separator:a3a562565110ca30492b92674b02389e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6aec1ea4594bf2af1de5cc2b8e8bb1ca"><td class="memItemLeft" align="right" valign="top">CoinWarmStartBasis *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a6aec1ea4594bf2af1de5cc2b8e8bb1ca">getBasis</a> (const unsigned char *statusArray) const</td></tr>
<tr class="memdesc:a6aec1ea4594bf2af1de5cc2b8e8bb1ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warm start from statusArray.  <a href="classOsiClpSolverInterface.html#a6aec1ea4594bf2af1de5cc2b8e8bb1ca">More...</a><br /></td></tr>
<tr class="separator:a6aec1ea4594bf2af1de5cc2b8e8bb1ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ae880a854422a8af7995ab310ca9827"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a8ae880a854422a8af7995ab310ca9827">deleteScaleFactors</a> ()</td></tr>
<tr class="memdesc:a8ae880a854422a8af7995ab310ca9827"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete all scale factor stuff and reset option.  <a href="classOsiClpSolverInterface.html#a8ae880a854422a8af7995ab310ca9827">More...</a><br /></td></tr>
<tr class="separator:a8ae880a854422a8af7995ab310ca9827"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810186d89b0e10b23f3342633d894b78"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a810186d89b0e10b23f3342633d894b78">upRange</a> () const</td></tr>
<tr class="memdesc:a810186d89b0e10b23f3342633d894b78"><td class="mdescLeft">&#160;</td><td class="mdescRight">If doing fast hot start then ranges are computed.  <a href="classOsiClpSolverInterface.html#a810186d89b0e10b23f3342633d894b78">More...</a><br /></td></tr>
<tr class="separator:a810186d89b0e10b23f3342633d894b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86249d262a9159b329c2b11e3f1b7c76"><td class="memItemLeft" align="right" valign="top">const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a86249d262a9159b329c2b11e3f1b7c76">downRange</a> () const</td></tr>
<tr class="separator:a86249d262a9159b329c2b11e3f1b7c76"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa6a4b8806916c42056db588043633dd9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aa6a4b8806916c42056db588043633dd9">passInRanges</a> (int *array)</td></tr>
<tr class="memdesc:aa6a4b8806916c42056db588043633dd9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass in range array.  <a href="classOsiClpSolverInterface.html#aa6a4b8806916c42056db588043633dd9">More...</a><br /></td></tr>
<tr class="separator:aa6a4b8806916c42056db588043633dd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9ec7ce73c6741e2680eff4c61e8ce38"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ad9ec7ce73c6741e2680eff4c61e8ce38">setSOSData</a> (int <a class="el" href="classOsiClpSolverInterface.html#aefa00df8c16f20d5e7e7b020c7cee677">numberSOS</a>, const char *type, const int *start, const int *indices, const double *weights=NULL)</td></tr>
<tr class="memdesc:ad9ec7ce73c6741e2680eff4c61e8ce38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Pass in sos stuff from AMPl.  <a href="classOsiClpSolverInterface.html#ad9ec7ce73c6741e2680eff4c61e8ce38">More...</a><br /></td></tr>
<tr class="separator:ad9ec7ce73c6741e2680eff4c61e8ce38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e5cd27d720af5c03a37d3f764b78a9d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a8e5cd27d720af5c03a37d3f764b78a9d">computeLargestAway</a> ()</td></tr>
<tr class="memdesc:a8e5cd27d720af5c03a37d3f764b78a9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compute largest amount any at continuous away from bound.  <a href="classOsiClpSolverInterface.html#a8e5cd27d720af5c03a37d3f764b78a9d">More...</a><br /></td></tr>
<tr class="separator:a8e5cd27d720af5c03a37d3f764b78a9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa0a9aac86be4584291948b8b570ee4ec"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aa0a9aac86be4584291948b8b570ee4ec">largestAway</a> () const</td></tr>
<tr class="memdesc:aa0a9aac86be4584291948b8b570ee4ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get largest amount continuous away from bound.  <a href="classOsiClpSolverInterface.html#aa0a9aac86be4584291948b8b570ee4ec">More...</a><br /></td></tr>
<tr class="separator:aa0a9aac86be4584291948b8b570ee4ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a437d2168c1e3db368073a0e1498852c9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a437d2168c1e3db368073a0e1498852c9">setLargestAway</a> (double value)</td></tr>
<tr class="memdesc:a437d2168c1e3db368073a0e1498852c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set largest amount continuous away from bound.  <a href="classOsiClpSolverInterface.html#a437d2168c1e3db368073a0e1498852c9">More...</a><br /></td></tr>
<tr class="separator:a437d2168c1e3db368073a0e1498852c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a036593dd43f475097fcb98a9462ba4d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a036593dd43f475097fcb98a9462ba4d5">lexSolve</a> ()</td></tr>
<tr class="memdesc:a036593dd43f475097fcb98a9462ba4d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sort of lexicographic resolve.  <a href="classOsiClpSolverInterface.html#a036593dd43f475097fcb98a9462ba4d5">More...</a><br /></td></tr>
<tr class="separator:a036593dd43f475097fcb98a9462ba4d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abacb005c2a1b414e2fa6d024210dbd4b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#abacb005c2a1b414e2fa6d024210dbd4b">getContinuousModel</a> () const</td></tr>
<tr class="memdesc:abacb005c2a1b414e2fa6d024210dbd4b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get continuous model.  <a href="classOsiClpSolverInterface.html#abacb005c2a1b414e2fa6d024210dbd4b">More...</a><br /></td></tr>
<tr class="separator:abacb005c2a1b414e2fa6d024210dbd4b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d7f271c7576dcb4f55b8755848d607c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a3d7f271c7576dcb4f55b8755848d607c">setContinuousModel</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model)</td></tr>
<tr class="memdesc:a3d7f271c7576dcb4f55b8755848d607c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set continuous model.  <a href="classOsiClpSolverInterface.html#a3d7f271c7576dcb4f55b8755848d607c">More...</a><br /></td></tr>
<tr class="separator:a3d7f271c7576dcb4f55b8755848d607c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af099813042416bc89f15bd0cdf4ebf43"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#af099813042416bc89f15bd0cdf4ebf43">applyRowCut</a> (const OsiRowCut &amp;rc)</td></tr>
<tr class="memdesc:af099813042416bc89f15bd0cdf4ebf43"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a row cut (append to constraint matrix).  <a href="classOsiClpSolverInterface.html#af099813042416bc89f15bd0cdf4ebf43">More...</a><br /></td></tr>
<tr class="separator:af099813042416bc89f15bd0cdf4ebf43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3590567e10cb7a0f944621d9a6f38c26"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a3590567e10cb7a0f944621d9a6f38c26">applyColCut</a> (const OsiColCut &amp;cc)</td></tr>
<tr class="memdesc:a3590567e10cb7a0f944621d9a6f38c26"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a column cut (adjust one or more bounds).  <a href="classOsiClpSolverInterface.html#a3590567e10cb7a0f944621d9a6f38c26">More...</a><br /></td></tr>
<tr class="separator:a3590567e10cb7a0f944621d9a6f38c26"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad9de23527741e87af63a1a1dee8251c0"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ad9de23527741e87af63a1a1dee8251c0">gutsOfDestructor</a> ()</td></tr>
<tr class="memdesc:ad9de23527741e87af63a1a1dee8251c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">The real work of a copy constructor (used by copy and assignment)  <a href="classOsiClpSolverInterface.html#ad9de23527741e87af63a1a1dee8251c0">More...</a><br /></td></tr>
<tr class="separator:ad9de23527741e87af63a1a1dee8251c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a328b5fe77e3261419b07f1aafd68bd37"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a328b5fe77e3261419b07f1aafd68bd37">freeCachedResults</a> () const</td></tr>
<tr class="memdesc:a328b5fe77e3261419b07f1aafd68bd37"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all mutable stuff.  <a href="classOsiClpSolverInterface.html#a328b5fe77e3261419b07f1aafd68bd37">More...</a><br /></td></tr>
<tr class="separator:a328b5fe77e3261419b07f1aafd68bd37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59d4e3599dafbe0dc79e098547649d59"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a59d4e3599dafbe0dc79e098547649d59">freeCachedResults0</a> () const</td></tr>
<tr class="memdesc:a59d4e3599dafbe0dc79e098547649d59"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all mutable stuff for row ranges etc.  <a href="classOsiClpSolverInterface.html#a59d4e3599dafbe0dc79e098547649d59">More...</a><br /></td></tr>
<tr class="separator:a59d4e3599dafbe0dc79e098547649d59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852dae17dc4f3a820c4b28087492e2ba"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a852dae17dc4f3a820c4b28087492e2ba">freeCachedResults1</a> () const</td></tr>
<tr class="memdesc:a852dae17dc4f3a820c4b28087492e2ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">Deletes all mutable stuff for matrix etc.  <a href="classOsiClpSolverInterface.html#a852dae17dc4f3a820c4b28087492e2ba">More...</a><br /></td></tr>
<tr class="separator:a852dae17dc4f3a820c4b28087492e2ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a185b3a49856d7ca5158133ff6ac10d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a4a185b3a49856d7ca5158133ff6ac10d">extractSenseRhsRange</a> () const</td></tr>
<tr class="memdesc:a4a185b3a49856d7ca5158133ff6ac10d"><td class="mdescLeft">&#160;</td><td class="mdescRight">A method that fills up the rowsense_, rhs_ and rowrange_ arrays.  <a href="classOsiClpSolverInterface.html#a4a185b3a49856d7ca5158133ff6ac10d">More...</a><br /></td></tr>
<tr class="separator:a4a185b3a49856d7ca5158133ff6ac10d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95035609eb46e59c0bed6f3bac65b70b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a95035609eb46e59c0bed6f3bac65b70b">fillParamMaps</a> ()</td></tr>
<tr class="separator:a95035609eb46e59c0bed6f3bac65b70b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad23105f3c49699e3560fd3c59aaa8a54"><td class="memItemLeft" align="right" valign="top">CoinWarmStartBasis&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#ad23105f3c49699e3560fd3c59aaa8a54">getBasis</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model) const</td></tr>
<tr class="memdesc:ad23105f3c49699e3560fd3c59aaa8a54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Warm start.  <a href="classOsiClpSolverInterface.html#ad23105f3c49699e3560fd3c59aaa8a54">More...</a><br /></td></tr>
<tr class="separator:ad23105f3c49699e3560fd3c59aaa8a54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba88a55ee78067f3f01b9dc975ea0ace"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#aba88a55ee78067f3f01b9dc975ea0ace">setBasis</a> (const CoinWarmStartBasis &amp;basis, <a class="el" href="classClpSimplex.html">ClpSimplex</a> *model)</td></tr>
<tr class="memdesc:aba88a55ee78067f3f01b9dc975ea0ace"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up working basis as a copy of input.  <a href="classOsiClpSolverInterface.html#aba88a55ee78067f3f01b9dc975ea0ace">More...</a><br /></td></tr>
<tr class="separator:aba88a55ee78067f3f01b9dc975ea0ace"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04bcd068f290d0ad1e33d787442a3994"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a04bcd068f290d0ad1e33d787442a3994">crunch</a> ()</td></tr>
<tr class="memdesc:a04bcd068f290d0ad1e33d787442a3994"><td class="mdescLeft">&#160;</td><td class="mdescRight">Crunch down problem a bit.  <a href="classOsiClpSolverInterface.html#a04bcd068f290d0ad1e33d787442a3994">More...</a><br /></td></tr>
<tr class="separator:a04bcd068f290d0ad1e33d787442a3994"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15cfaf0110042166c5f218078b95b24e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classOsiClpSolverInterface.html#a15cfaf0110042166c5f218078b95b24e">redoScaleFactors</a> (int numberRows, const CoinBigIndex *starts, const int *indices, const double *elements)</td></tr>
<tr class="memdesc:a15cfaf0110042166c5f218078b95b24e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Extend scale factors.  <a href="classOsiClpSolverInterface.html#a15cfaf0110042166c5f218078b95b24e">More...</a><br /></td></tr>
<tr class="separator:a15cfaf0110042166c5f218078b95b24e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Clp Solver Interface. </p>
<p>Instantiation of <a class="el" href="classOsiClpSolverInterface.html" title="Clp Solver Interface.">OsiClpSolverInterface</a> for the Model Algorithm. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00037">37</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a61222d5a8e9074b8eb7af95cd0d86dd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61222d5a8e9074b8eb7af95cd0d86dd7">&#9670;&nbsp;</a></span>OsiClpSolverInterface() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OsiClpSolverInterface::OsiClpSolverInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Default Constructor. </p>

</div>
</div>
<a id="a2e4534530dc04501410115568ca71190"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e4534530dc04501410115568ca71190">&#9670;&nbsp;</a></span>OsiClpSolverInterface() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OsiClpSolverInterface::OsiClpSolverInterface </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOsiClpSolverInterface.html">OsiClpSolverInterface</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Copy constructor. </p>

</div>
</div>
<a id="aa5ebf1382466440dfb8b44bdc1eed379"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa5ebf1382466440dfb8b44bdc1eed379">&#9670;&nbsp;</a></span>OsiClpSolverInterface() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OsiClpSolverInterface::OsiClpSolverInterface </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>rhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>reallyOwn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Borrow constructor - only delete one copy. </p>

</div>
</div>
<a id="a168cff685b6511734efce2fa3ecf3806"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a168cff685b6511734efce2fa3ecf3806">&#9670;&nbsp;</a></span>~OsiClpSolverInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual OsiClpSolverInterface::~OsiClpSolverInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a593ef13cc9058734bfa7d8bded2ee437"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a593ef13cc9058734bfa7d8bded2ee437">&#9670;&nbsp;</a></span>initialSolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::initialSolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Solve initial LP relaxation. </p>

</div>
</div>
<a id="a770d869e0c9da633cbe54b563d925699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a770d869e0c9da633cbe54b563d925699">&#9670;&nbsp;</a></span>resolve()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::resolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve an LP relaxation after problem modification. </p>

</div>
</div>
<a id="a3e22fefb12936c73bdfd7aca615fc001"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e22fefb12936c73bdfd7aca615fc001">&#9670;&nbsp;</a></span>resolveGub()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::resolveGub </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>needed</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resolve an LP relaxation after problem modification (try GUB) </p>

</div>
</div>
<a id="a4c68bf83f32763e5512d1d8c3747a2b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4c68bf83f32763e5512d1d8c3747a2b7">&#9670;&nbsp;</a></span>branchAndBound()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::branchAndBound </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Invoke solver's built-in enumeration algorithm. </p>

</div>
</div>
<a id="a782c4e8c3ca2b3352561c0613a872815"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a782c4e8c3ca2b3352561c0613a872815">&#9670;&nbsp;</a></span>crossover()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::crossover </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>options</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>basis</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Solve when primal column and dual row solutions are near-optimal options - 0 no presolve (use primal and dual) 1 presolve (just use primal) 2 no presolve (just use primal) basis - 0 use all slack basis 1 try and put some in basis. </p>

</div>
</div>
<a id="a452be2c7f4978aac85991d055815f079"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452be2c7f4978aac85991d055815f079">&#9670;&nbsp;</a></span>canDoSimplexInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::canDoSimplexInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simplex API capability. </p>
<p>Returns</p><ul>
<li>0 if no simplex API</li>
<li>1 if can just do getBInv etc</li>
<li>2 if has all OsiSimplex methods </li>
</ul>

</div>
</div>
<a id="a1322ee0dcd508677db4a05720cb380e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1322ee0dcd508677db4a05720cb380e3">&#9670;&nbsp;</a></span>enableFactorization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::enableFactorization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables simplex mode 1 (tableau access) </p>
<p>Tells solver that calls to getBInv etc are about to take place. Underlying code may need mutable as this may be called from CglCut::generateCuts which is const. If that is too horrific then each solver e.g. BCP or CBC will have to do something outside main loop. </p>

</div>
</div>
<a id="a391d2ca359c17e5a25cf21cacab4978b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a391d2ca359c17e5a25cf21cacab4978b">&#9670;&nbsp;</a></span>disableFactorization()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::disableFactorization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Undo any setting changes made by <a class="el" href="classOsiClpSolverInterface.html#a1322ee0dcd508677db4a05720cb380e3" title="Enables simplex mode 1 (tableau access)">enableFactorization</a>. </p>

</div>
</div>
<a id="af2cc2bd18cf8e0327ae482b7f68d6192"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2cc2bd18cf8e0327ae482b7f68d6192">&#9670;&nbsp;</a></span>basisIsAvailable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::basisIsAvailable </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if a basis is available AND problem is optimal. </p>
<p>This should be used to see if the BInvARow type operations are possible and meaningful. </p>

</div>
</div>
<a id="af47b76241318bafd40e475bea891ca36"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af47b76241318bafd40e475bea891ca36">&#9670;&nbsp;</a></span>getBasisStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::getBasisStatus </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>cstat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rstat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following two methods may be replaced by the methods of OsiSolverInterface using OsiWarmStartBasis if: </p>
<ol type="1">
<li>OsiWarmStartBasis resize operation is implemented more efficiently and</li>
<li>It is ensured that effects on the solver are the same</li>
</ol>
<p>Returns a basis status of the structural/artificial variables At present as warm start i.e 0 free, 1 basic, 2 upper, 3 lower</p>
<p>NOTE artificials are treated as +1 elements so for &lt;= rhs artificial will be at lower bound if constraint is tight</p>
<p>This means that Clpsimplex flips artificials as it works in terms of row activities </p>

</div>
</div>
<a id="a52c9f3dea866c80b7cf3b67564902054"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52c9f3dea866c80b7cf3b67564902054">&#9670;&nbsp;</a></span>setBasisStatus()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::setBasisStatus </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>cstat</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>rstat</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the status of structural/artificial variables and factorize, update solution etc. </p>
<p>NOTE artificials are treated as +1 elements so for &lt;= rhs artificial will be at lower bound if constraint is tight</p>
<p>This means that Clpsimplex flips artificials as it works in terms of row activities Returns 0 if OK, 1 if problem is bad e.g. duplicate elements, too large ... </p>

</div>
</div>
<a id="ac905bd4a4ad34ad6b67651757921884e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac905bd4a4ad34ad6b67651757921884e">&#9670;&nbsp;</a></span>getReducedGradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::getReducedGradient </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>columnReducedCosts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>duals</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>c</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get the reduced gradient for the cost vector c. </p>

</div>
</div>
<a id="ac3d470cefb0bddb4279a5ac1589d7223"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3d470cefb0bddb4279a5ac1589d7223">&#9670;&nbsp;</a></span>getBInvARow() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::getBInvARow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>slack</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a row of the tableau (slack part in slack if not NULL) </p>

</div>
</div>
<a id="a27c333c990adcc948d38c0e634ff1dd3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27c333c990adcc948d38c0e634ff1dd3">&#9670;&nbsp;</a></span>getBInvARow() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::getBInvARow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>z</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>slack</em> = <code>NULL</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepScaled</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a row of the tableau (slack part in slack if not NULL) If keepScaled is true then scale factors not applied after so user has to use coding similar to what is in this method. </p>

</div>
</div>
<a id="a0af218163ef426f1c4492d658ae5b5ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0af218163ef426f1c4492d658ae5b5ea">&#9670;&nbsp;</a></span>getBInvRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::getBInvRow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a row of the basis inverse. </p>

</div>
</div>
<a id="a2ba0b1e7c9ca131c12e85c999d96c324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ba0b1e7c9ca131c12e85c999d96c324">&#9670;&nbsp;</a></span>getBInvACol() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::getBInvACol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a column of the tableau. </p>

</div>
</div>
<a id="a455103d8131883e60eb9c5e6d55d8164"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a455103d8131883e60eb9c5e6d55d8164">&#9670;&nbsp;</a></span>getBInvACol() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::getBInvACol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a column of the tableau. </p>

</div>
</div>
<a id="af01b50611a1fe1c2d81ca739a9f47907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af01b50611a1fe1c2d81ca739a9f47907">&#9670;&nbsp;</a></span>getBInvACol() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::getBInvACol </td>
          <td>(</td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>vec</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Update (i.e. </p>
<p>ftran) the vector passed in. Unscaling is applied after - can't be applied before </p>

</div>
</div>
<a id="af6459510073886e22a6ad5e983ccbb66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6459510073886e22a6ad5e983ccbb66">&#9670;&nbsp;</a></span>getBInvCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::getBInvCol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>col</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>vec</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a column of the basis inverse. </p>

</div>
</div>
<a id="a1dc89b6917c8700bf7e0e69a75372ab4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dc89b6917c8700bf7e0e69a75372ab4">&#9670;&nbsp;</a></span>getBasics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::getBasics </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get basic indices (order of indices corresponds to the order of elements in a vector retured by <a class="el" href="classOsiClpSolverInterface.html#a2ba0b1e7c9ca131c12e85c999d96c324" title="Get a column of the tableau.">getBInvACol()</a> and <a class="el" href="classOsiClpSolverInterface.html#af6459510073886e22a6ad5e983ccbb66" title="Get a column of the basis inverse.">getBInvCol()</a>). </p>

</div>
</div>
<a id="a6e764316b2e7f1a129bcd4e947d6cc6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e764316b2e7f1a129bcd4e947d6cc6b">&#9670;&nbsp;</a></span>enableSimplexInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::enableSimplexInterface </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>doingPrimal</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Enables simplex mode 2 (individual pivot control) </p>
<p>This method is supposed to ensure that all typical things (like reduced costs, etc.) are updated when individual pivots are executed and can be queried by other methods. </p>

</div>
</div>
<a id="a2c85c203d7204729600c276e852a51d3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c85c203d7204729600c276e852a51d3">&#9670;&nbsp;</a></span>disableSimplexInterface()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::disableSimplexInterface </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Undo setting changes made by <a class="el" href="classOsiClpSolverInterface.html#a6e764316b2e7f1a129bcd4e947d6cc6b" title="Enables simplex mode 2 (individual pivot control)">enableSimplexInterface</a>. </p>

</div>
</div>
<a id="a324e55fe159bec975fdcc62337f7145a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a324e55fe159bec975fdcc62337f7145a">&#9670;&nbsp;</a></span>pivot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::pivot </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outStatus</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Perform a pivot by substituting a colIn for colOut in the basis. </p>
<p>The status of the leaving variable is given in statOut. Where 1 is to upper bound, -1 to lower bound Return code is 0 for okay, 1 if inaccuracy forced re-factorization (should be okay) and -1 for singular factorization </p>

</div>
</div>
<a id="abd182f1225ba03071bd3cdd136f4b80a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd182f1225ba03071bd3cdd136f4b80a">&#9670;&nbsp;</a></span>primalPivotResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::primalPivotResult </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>colOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>outStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinPackedVector *&#160;</td>
          <td class="paramname"><em>dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a result of the primal pivot Outputs: colOut &ndash; leaving column, outStatus &ndash; its status, t &ndash; step size, and, if dx!=NULL, *dx &ndash; primal ray direction. </p>
<p>Inputs: colIn &ndash; entering column, sign &ndash; direction of its change (+/-1). Both for colIn and colOut, artificial variables are index by the negative of the row index minus 1. Return code (for now): 0 &ndash; leaving variable found, -1 &ndash; everything else? Clearly, more informative set of return values is required Primal and dual solutions are updated </p>

</div>
</div>
<a id="a90f97948775981910c54e3fa95fb437a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f97948775981910c54e3fa95fb437a">&#9670;&nbsp;</a></span>dualPivotResult()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::dualPivotResult </td>
          <td>(</td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>colIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sign</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colOut</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>outStatus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>t</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinPackedVector *&#160;</td>
          <td class="paramname"><em>dx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Obtain a result of the dual pivot (similar to the previous method) Differences: entering variable and a sign of its change are now the outputs, the leaving variable and its statuts &ndash; the inputs If dx!=NULL, then *dx contains dual ray Return code: same. </p>

</div>
</div>
<a id="ae286206398e2a0142573d4e32e097ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae286206398e2a0142573d4e32e097ba7">&#9670;&nbsp;</a></span>setIntParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OsiClpSolverInterface::setIntParam </td>
          <td>(</td>
          <td class="paramtype">OsiIntParam&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae1696fc6c84a72cdf054d41a4228860d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1696fc6c84a72cdf054d41a4228860d">&#9670;&nbsp;</a></span>setDblParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OsiClpSolverInterface::setDblParam </td>
          <td>(</td>
          <td class="paramtype">OsiDblParam&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a31fc82afd61124c58dae52cabaf9996c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31fc82afd61124c58dae52cabaf9996c">&#9670;&nbsp;</a></span>setStrParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OsiClpSolverInterface::setStrParam </td>
          <td>(</td>
          <td class="paramtype">OsiStrParam&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa382ae87fcefe98f778dc6cf4818e74e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa382ae87fcefe98f778dc6cf4818e74e">&#9670;&nbsp;</a></span>getIntParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OsiClpSolverInterface::getIntParam </td>
          <td>(</td>
          <td class="paramtype">OsiIntParam&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aa6c16d3a59265d6569163545767dc9ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6c16d3a59265d6569163545767dc9ea">&#9670;&nbsp;</a></span>getDblParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OsiClpSolverInterface::getDblParam </td>
          <td>(</td>
          <td class="paramtype">OsiDblParam&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af636f3a0994ef4766feebdf9d63d7173"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af636f3a0994ef4766feebdf9d63d7173">&#9670;&nbsp;</a></span>getStrParam()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OsiClpSolverInterface::getStrParam </td>
          <td>(</td>
          <td class="paramtype">OsiStrParam&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string &amp;&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77ac65edc08f0c942e59d3c0637fdbb0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ac65edc08f0c942e59d3c0637fdbb0">&#9670;&nbsp;</a></span>setHintParam()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::setHintParam </td>
          <td>(</td>
          <td class="paramtype">OsiHintParam&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yesNo</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">OsiHintStrength&#160;</td>
          <td class="paramname"><em>strength</em> = <code>OsiHintTry</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>otherInformation</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70cb310cbf5ebf200d8cd2d68a491fad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70cb310cbf5ebf200d8cd2d68a491fad">&#9670;&nbsp;</a></span>isAbandoned()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isAbandoned </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Are there a numerical difficulties? </p>

</div>
</div>
<a id="a5a465ead374ff6f9c042930648979372"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a465ead374ff6f9c042930648979372">&#9670;&nbsp;</a></span>isProvenOptimal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isProvenOptimal </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is optimality proven? </p>

</div>
</div>
<a id="a44147763ae775e743d61c50757f53012"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44147763ae775e743d61c50757f53012">&#9670;&nbsp;</a></span>isProvenPrimalInfeasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isProvenPrimalInfeasible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is primal infeasiblity proven? </p>

</div>
</div>
<a id="a050713893a284a72b547567161285042"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a050713893a284a72b547567161285042">&#9670;&nbsp;</a></span>isProvenDualInfeasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isProvenDualInfeasible </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is dual infeasiblity proven? </p>

</div>
</div>
<a id="a2069442053d70fdd1e8eb5099719a7b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2069442053d70fdd1e8eb5099719a7b9">&#9670;&nbsp;</a></span>isPrimalObjectiveLimitReached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isPrimalObjectiveLimitReached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the given primal objective limit reached? </p>

</div>
</div>
<a id="a46d0fc7d43b6e79a3a3f113069a54e30"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d0fc7d43b6e79a3a3f113069a54e30">&#9670;&nbsp;</a></span>isDualObjectiveLimitReached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isDualObjectiveLimitReached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Is the given dual objective limit reached? </p>

</div>
</div>
<a id="a15bdfd65c6daf670a71ca3eedb81ad15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15bdfd65c6daf670a71ca3eedb81ad15">&#9670;&nbsp;</a></span>isIterationLimitReached()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isIterationLimitReached </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Iteration limit reached? </p>

</div>
</div>
<a id="a4fdff34a07410f9ea50823e0de1eb824"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fdff34a07410f9ea50823e0de1eb824">&#9670;&nbsp;</a></span>getEmptyWarmStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CoinWarmStart* OsiClpSolverInterface::getEmptyWarmStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get an empty warm start object. </p>
<p>This routine returns an empty CoinWarmStartBasis object. Its purpose is to provide a way to give a client a warm start basis object of the appropriate type, which can resized and modified as desired. </p>

</div>
</div>
<a id="a4870c21baf589bf9e8fcebf32d3ea982"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4870c21baf589bf9e8fcebf32d3ea982">&#9670;&nbsp;</a></span>getWarmStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CoinWarmStart* OsiClpSolverInterface::getWarmStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get warmstarting information. </p>

</div>
</div>
<a id="a739b4d70b931138436d4afe7b665da93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a739b4d70b931138436d4afe7b665da93">&#9670;&nbsp;</a></span>getPointerToWarmStart() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoinWarmStartBasis* OsiClpSolverInterface::getPointerToWarmStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get warmstarting information. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00285">285</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="aa4886c80c50592a37ceee17be5baab40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4886c80c50592a37ceee17be5baab40">&#9670;&nbsp;</a></span>getConstPointerToWarmStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CoinWarmStartBasis* OsiClpSolverInterface::getConstPointerToWarmStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get warmstarting information. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00290">290</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a3f8efbfc7a52b6e1b39c9ee575cab65a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8efbfc7a52b6e1b39c9ee575cab65a">&#9670;&nbsp;</a></span>setWarmStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::setWarmStart </td>
          <td>(</td>
          <td class="paramtype">const CoinWarmStart *&#160;</td>
          <td class="paramname"><em>warmstart</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set warmstarting information. </p>
<p>Return true/false depending on whether the warmstart information was accepted or not. </p>

</div>
</div>
<a id="a42a68c426547ccdde2a4b8b36be26e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42a68c426547ccdde2a4b8b36be26e2d">&#9670;&nbsp;</a></span>getPointerToWarmStart() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CoinWarmStart* OsiClpSolverInterface::getPointerToWarmStart </td>
          <td>(</td>
          <td class="paramtype">bool &amp;&#160;</td>
          <td class="paramname"><em>mustDelete</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get warm start information. </p>
<p>Return warm start information for the current state of the solver interface. If there is no valid warm start information, an empty warm start object wil be returned. This does not necessarily create an object - may just point to one. must Delete set true if user should delete returned object. OsiClp version always returns pointer and false. </p>

</div>
</div>
<a id="ac7c0185ec68de7c04e3d9e5f287ed602"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7c0185ec68de7c04e3d9e5f287ed602">&#9670;&nbsp;</a></span>setColumnStatus()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setColumnStatus </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>iColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html#a21143b50762085902b3852b103b3704f">ClpSimplex::Status</a>&#160;</td>
          <td class="paramname"><em>status</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set column status in <a class="el" href="classClpSimplex.html" title="This solves LPs using the simplex method.">ClpSimplex</a> and warmStart. </p>

</div>
</div>
<a id="a25a0f5297ee91cde41e0c8d9064bb548"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25a0f5297ee91cde41e0c8d9064bb548">&#9670;&nbsp;</a></span>markHotStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::markHotStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a hotstart point of the optimization process. </p>

</div>
</div>
<a id="a1bf50161ab7566bedd21de17e63ba55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bf50161ab7566bedd21de17e63ba55c">&#9670;&nbsp;</a></span>solveFromHotStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::solveFromHotStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Optimize starting from the hotstart. </p>

</div>
</div>
<a id="a80efbc68cded5b9cea00b1827ca605ad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80efbc68cded5b9cea00b1827ca605ad">&#9670;&nbsp;</a></span>unmarkHotStart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::unmarkHotStart </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the snapshot. </p>

</div>
</div>
<a id="aa0343b260b84741212d2dabc9d95521f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0343b260b84741212d2dabc9d95521f">&#9670;&nbsp;</a></span>startFastDual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::startFastDual </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Start faster dual - returns negative if problems 1 if infeasible, <a class="el" href="structOptions.html" title="******** DATA to be moved into protected section of ClpInterior">Options</a> to pass to solver 1 - create external reduced costs for columns 2 - create external reduced costs for rows 4 - create external row activity (columns always done) Above only done if feasible When set resolve does less work. </p>

</div>
</div>
<a id="a716387e42841d59299d6d6c3030e9184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a716387e42841d59299d6d6c3030e9184">&#9670;&nbsp;</a></span>stopFastDual()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::stopFastDual </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Stop fast dual. </p>

</div>
</div>
<a id="aa73f4377fc682430c2ad00b79a61db08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa73f4377fc682430c2ad00b79a61db08">&#9670;&nbsp;</a></span>setStuff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setStuff </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>tolerance</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>increment</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets integer tolerance and increment. </p>

</div>
</div>
<a id="ac6d9b718431ded5d4bdb30d1c48e4899"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6d9b718431ded5d4bdb30d1c48e4899">&#9670;&nbsp;</a></span>smallModelCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OsiRowCut* OsiClpSolverInterface::smallModelCut </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>originalLower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>originalUpper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberRowsAtContinuous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>whichGenerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeCut</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a conflict analysis cut from small model. </p>

</div>
</div>
<a id="a33f400d6f9255faca8a290732e31fd07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33f400d6f9255faca8a290732e31fd07">&#9670;&nbsp;</a></span>modelCut()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">OsiRowCut* OsiClpSolverInterface::modelCut </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>originalLower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>originalUpper</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberRowsAtContinuous</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>whichGenerator</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>typeCut</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a conflict analysis cut from model If type is 0 then genuine cut, if 1 then only partially processed. </p>

</div>
</div>
<a id="a3974c65825e426ed107a5cb032d04e92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3974c65825e426ed107a5cb032d04e92">&#9670;&nbsp;</a></span>getNumCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::getNumCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of columns. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00367">367</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a9264e6716986e041907e3bf6aef205c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9264e6716986e041907e3bf6aef205c9">&#9670;&nbsp;</a></span>getNumRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::getNumRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of rows. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00373">373</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="aad74b987e74a865e1922c8321a02fc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad74b987e74a865e1922c8321a02fc14">&#9670;&nbsp;</a></span>getNumElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CoinBigIndex OsiClpSolverInterface::getNumElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get number of nonzero elements. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00379">379</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ab05c4ee6b9795138c3dd372d2793f400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab05c4ee6b9795138c3dd372d2793f400">&#9670;&nbsp;</a></span>getRowName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string OsiClpSolverInterface::getRowName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>static_cast&lt;&#160;unsigned&#160;&gt;(std::string::npos)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return name of row if one exists or Rnnnnnnn maxLen is currently ignored and only there to match the signature from the base class! </p>

</div>
</div>
<a id="aed5c89b743fcbf26d015ad9edabc388e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed5c89b743fcbf26d015ad9edabc388e">&#9670;&nbsp;</a></span>getColName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string OsiClpSolverInterface::getColName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned&#160;</td>
          <td class="paramname"><em>maxLen</em> = <code>static_cast&lt;&#160;unsigned&#160;&gt;(std::string::npos)</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return name of column if one exists or Cnnnnnnn maxLen is currently ignored and only there to match the signature from the base class! </p>

</div>
</div>
<a id="a3108016d8607d5a0aab7bce53889ad3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3108016d8607d5a0aab7bce53889ad3a">&#9670;&nbsp;</a></span>getColLower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* OsiClpSolverInterface::getColLower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] of column lower bounds. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00399">399</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ab63676a5efab85b18cc269b0c3e980f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab63676a5efab85b18cc269b0c3e980f6">&#9670;&nbsp;</a></span>getColUpper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* OsiClpSolverInterface::getColUpper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] of column upper bounds. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00402">402</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a9572898bcf2547863fc66e6887aefe4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9572898bcf2547863fc66e6887aefe4c">&#9670;&nbsp;</a></span>getRowSense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* OsiClpSolverInterface::getRowSense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of row constraint senses. </p>
<ul>
<li>
'L' &lt;= constraint </li>
<li>
'E' = constraint </li>
<li>
'G' &gt;= constraint </li>
<li>
'R' ranged constraint </li>
<li>
'N' free constraint </li>
</ul>

</div>
</div>
<a id="a960856ba062d10bc91713055ca3081cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a960856ba062d10bc91713055ca3081cc">&#9670;&nbsp;</a></span>getRightHandSide()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* OsiClpSolverInterface::getRightHandSide </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of rows right-hand sides. </p>
<ul>
<li>
if rowsense()[i] == 'L' then rhs()[i] == rowupper()[i] </li>
<li>
if rowsense()[i] == 'G' then rhs()[i] == rowlower()[i] </li>
<li>
if rowsense()[i] == 'R' then rhs()[i] == rowupper()[i] </li>
<li>
if rowsense()[i] == 'N' then rhs()[i] == 0.0 </li>
</ul>

</div>
</div>
<a id="ae16a03e48d74145c844d1f6a92c9a2f3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae16a03e48d74145c844d1f6a92c9a2f3">&#9670;&nbsp;</a></span>getRowRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* OsiClpSolverInterface::getRowRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of row ranges. </p>
<ul>
<li>
if rowsense()[i] == 'R' then rowrange()[i] == rowupper()[i] - rowlower()[i] </li>
<li>
if rowsense()[i] != 'R' then rowrange()[i] is undefined </li>
</ul>

</div>
</div>
<a id="aed6829ed0efaca22f5ad7ac4ea47c699"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aed6829ed0efaca22f5ad7ac4ea47c699">&#9670;&nbsp;</a></span>getRowLower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* OsiClpSolverInterface::getRowLower </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of row lower bounds. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00436">436</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a4ec302bf65a5627c771ab69499353cf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ec302bf65a5627c771ab69499353cf5">&#9670;&nbsp;</a></span>getRowUpper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* OsiClpSolverInterface::getRowUpper </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of row upper bounds. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00439">439</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ada8df4f17114c968593ab6d98129a9e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada8df4f17114c968593ab6d98129a9e4">&#9670;&nbsp;</a></span>getObjCoefficients()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* OsiClpSolverInterface::getObjCoefficients </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] of objective function coefficients. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00442">442</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a41eb185b816442f70d07179db17eadcc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a41eb185b816442f70d07179db17eadcc">&#9670;&nbsp;</a></span>getObjSense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double OsiClpSolverInterface::getObjSense </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get objective function sense (1 for min (default), -1 for max) </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00451">451</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="aefa4a235755d36ab4c1fa0200042d8ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa4a235755d36ab4c1fa0200042d8ca">&#9670;&nbsp;</a></span>isContinuous()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isContinuous </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colNumber</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if column is continuous. </p>

</div>
</div>
<a id="ab06af3a3591898f1645f1e23d3e5241b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab06af3a3591898f1645f1e23d3e5241b">&#9670;&nbsp;</a></span>isBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isBinary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if variable is binary. </p>

</div>
</div>
<a id="acbf97c8ee992444ea603ef616079986d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbf97c8ee992444ea603ef616079986d">&#9670;&nbsp;</a></span>isInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isInteger </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if column is integer. </p>
<p>Note: This function returns true if the the column is binary or a general integer. </p>

</div>
</div>
<a id="a8149c145d1c315e449c9ff0b7082cace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8149c145d1c315e449c9ff0b7082cace">&#9670;&nbsp;</a></span>isIntegerNonBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isIntegerNonBinary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if variable is general integer. </p>

</div>
</div>
<a id="a1710ae45a979601ae698e4f49e4e5ba7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1710ae45a979601ae698e4f49e4e5ba7">&#9670;&nbsp;</a></span>isFreeBinary()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool OsiClpSolverInterface::isFreeBinary </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true if variable is binary and not fixed at either bound. </p>

</div>
</div>
<a id="ada79029eea440cc2cfaa3f4e5cca7ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada79029eea440cc2cfaa3f4e5cca7ca8">&#9670;&nbsp;</a></span>getColType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const char* OsiClpSolverInterface::getColType </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>refresh</em> = <code>false</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return array of column length 0 - continuous 1 - binary (may get fixed later) 2 - general integer (may get fixed later) </p>

</div>
</div>
<a id="ac7bc389f903b1611f3d778cb3ab5f27b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7bc389f903b1611f3d778cb3ab5f27b">&#9670;&nbsp;</a></span>isOptionalInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool OsiClpSolverInterface::isOptionalInteger </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return true if column is integer but does not have to be declared as such. </p>
<p>Note: This function returns true if the the column is binary or a general integer. </p>

</div>
</div>
<a id="ad337e31a79e1b24ae04112242b175cc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad337e31a79e1b24ae04112242b175cc5">&#9670;&nbsp;</a></span>setOptionalInteger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setOptionalInteger </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set the index-th variable to be an optional integer variable. </p>

</div>
</div>
<a id="aee8578b1e3adaced3df1cb1fb0d01776"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee8578b1e3adaced3df1cb1fb0d01776">&#9670;&nbsp;</a></span>isHeuristicInteger()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OsiClpSolverInterface::isHeuristicInteger </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return true only if integer and not optional. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00488">488</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a7a367ec646d066b063ab494a00b78e42"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a367ec646d066b063ab494a00b78e42">&#9670;&nbsp;</a></span>integerType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::integerType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIndex</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return integer type (0,1,2=optional,3=sc,4=scint) </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00493">493</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ae660e1a472ecfdc329afdb6e33a16bc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae660e1a472ecfdc329afdb6e33a16bc6">&#9670;&nbsp;</a></span>setIntegerType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setIntegerType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set integer type (0,1,2=optional,3=sc,4=scint) </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00498">498</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a7ca3e531146a9bfcfc1dd98ed1bc1d6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ca3e531146a9bfcfc1dd98ed1bc1d6f">&#9670;&nbsp;</a></span>getMatrixByRow()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const CoinPackedMatrix* OsiClpSolverInterface::getMatrixByRow </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to row-wise copy of matrix. </p>

</div>
</div>
<a id="a32de030bd79988e7e1c157952df23d32"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32de030bd79988e7e1c157952df23d32">&#9670;&nbsp;</a></span>getMatrixByCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const CoinPackedMatrix* OsiClpSolverInterface::getMatrixByCol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to column-wise copy of matrix. </p>

</div>
</div>
<a id="a1405541692a9a0c7452572a3b97df0e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1405541692a9a0c7452572a3b97df0e8">&#9670;&nbsp;</a></span>getMutableMatrixByCol()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CoinPackedMatrix* OsiClpSolverInterface::getMutableMatrixByCol </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to mutable column-wise copy of matrix. </p>

</div>
</div>
<a id="a579966a398543bc4de25a4330baca26a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a579966a398543bc4de25a4330baca26a">&#9670;&nbsp;</a></span>getInfinity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double OsiClpSolverInterface::getInfinity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get solver's value for infinity. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00512">512</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a80274545e65aa7f2d1886c20f3f066ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80274545e65aa7f2d1886c20f3f066ca">&#9670;&nbsp;</a></span>getColSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* OsiClpSolverInterface::getColSolution </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] of primal solution vector. </p>

</div>
</div>
<a id="a07e454eda2e2399afbad1f02e93ffd3f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07e454eda2e2399afbad1f02e93ffd3f">&#9670;&nbsp;</a></span>getRowPrice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* OsiClpSolverInterface::getRowPrice </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of dual prices. </p>

</div>
</div>
<a id="a98cac8fa58cb64843fc0503d65af9324"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a98cac8fa58cb64843fc0503d65af9324">&#9670;&nbsp;</a></span>getReducedCost()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* OsiClpSolverInterface::getReducedCost </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get a pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] of reduced costs. </p>

</div>
</div>
<a id="a703372e3913a64c56a45db6d35555730"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a703372e3913a64c56a45db6d35555730">&#9670;&nbsp;</a></span>getRowActivity()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* OsiClpSolverInterface::getRowActivity </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get pointer to array[<a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a>] of row activity levels (constraint matrix times the solution vector. </p>

</div>
</div>
<a id="ae8df7590ffcf2fd22b5cfa6677471403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae8df7590ffcf2fd22b5cfa6677471403">&#9670;&nbsp;</a></span>getObjValue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double OsiClpSolverInterface::getObjValue </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get objective function value. </p>

</div>
</div>
<a id="a6dcfb9d0053de3daf1d5f1ff6b9867e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dcfb9d0053de3daf1d5f1ff6b9867e8">&#9670;&nbsp;</a></span>getIterationCount()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::getIterationCount </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get how many iterations it took to solve the problem (whatever "iteration" mean to the solver. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00535">535</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a413048b1ff3583a4134e41fca8d52bbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a413048b1ff3583a4134e41fca8d52bbc">&#9670;&nbsp;</a></span>getDualRays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; double * &gt; OsiClpSolverInterface::getDualRays </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumRays</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>fullRay</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get as many dual rays as the solver can provide. </p>
<p>(In case of proven primal infeasibility there should be at least one.)</p>
<p>The first <a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a> ray components will always be associated with the row duals (as returned by <a class="el" href="classOsiClpSolverInterface.html#a07e454eda2e2399afbad1f02e93ffd3f" title="Get pointer to array[getNumRows()] of dual prices.">getRowPrice()</a>). If <code>fullRay</code> is true, the final <a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a> entries will correspond to the ray components associated with the nonbasic variables. If the full ray is requested and the method cannot provide it, it will throw an exception.</p>
<p><b>NOTE for implementers of solver interfaces:</b> <br  />
 The double pointers in the vector should point to arrays of length <a class="el" href="classOsiClpSolverInterface.html#a9264e6716986e041907e3bf6aef205c9" title="Get number of rows.">getNumRows()</a> and they should be allocated via new[]. <br  />
</p>
<p><b>NOTE for users of solver interfaces:</b> <br  />
 It is the user's responsibility to free the double pointers in the vector using delete[]. </p>

</div>
</div>
<a id="ac6fd7f5239e7b6336830ec6312cef4f6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6fd7f5239e7b6336830ec6312cef4f6">&#9670;&nbsp;</a></span>getPrimalRays()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt; double * &gt; OsiClpSolverInterface::getPrimalRays </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxNumRays</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get as many primal rays as the solver can provide. </p>
<p>(In case of proven dual infeasibility there should be at least one.)</p>
<p><b>NOTE for implementers of solver interfaces:</b> <br  />
 The double pointers in the vector should point to arrays of length <a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a> and they should be allocated via new[]. <br  />
</p>
<p><b>NOTE for users of solver interfaces:</b> <br  />
 It is the user's responsibility to free the double pointers in the vector using delete[]. </p>

</div>
</div>
<a id="acfeabd8a7955889dfe73e8943243b027"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfeabd8a7955889dfe73e8943243b027">&#9670;&nbsp;</a></span>setObjCoeff()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setObjCoeff </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>elementValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set an objective function coefficient. </p>

</div>
</div>
<a id="af7ad635b4dfa3ad60e2ba575c1351beb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7ad635b4dfa3ad60e2ba575c1351beb">&#9670;&nbsp;</a></span>setColLower() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setColLower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>elementValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a single column lower bound<br  />
 Use -DBL_MAX for -infinity. </p>

</div>
</div>
<a id="acb2521f4be78a971efee19f17d939b50"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb2521f4be78a971efee19f17d939b50">&#9670;&nbsp;</a></span>setColUpper() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setColUpper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>elementValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a single column upper bound<br  />
 Use DBL_MAX for infinity. </p>

</div>
</div>
<a id="adb8599a58e34f5f3c3c803695d9e5108"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb8599a58e34f5f3c3c803695d9e5108">&#9670;&nbsp;</a></span>setColBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setColBounds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a single column lower and upper bound. </p>

</div>
</div>
<a id="aa843704c89982ad2fd47ef8f2451f888"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa843704c89982ad2fd47ef8f2451f888">&#9670;&nbsp;</a></span>setColSetBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setColSetBounds </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indexFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indexLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>boundList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the bounds on a number of columns simultaneously<br  />
 The default implementation just invokes <a class="el" href="classOsiClpSolverInterface.html#af7ad635b4dfa3ad60e2ba575c1351beb" title="Set a single column lower bound  Use -DBL_MAX for -infinity.">setColLower()</a> and <a class="el" href="classOsiClpSolverInterface.html#acb2521f4be78a971efee19f17d939b50" title="Set a single column upper bound  Use DBL_MAX for infinity.">setColUpper()</a> over and over again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexFirst,indexLast</td><td>pointers to the beginning and after the end of the array of the indices of the variables whose <em>either</em> bound changes </td></tr>
    <tr><td class="paramname">boundList</td><td>the new lower/upper bound pairs for the variables </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1bb969c4f0a81edecc56ed50efa703ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bb969c4f0a81edecc56ed50efa703ab">&#9670;&nbsp;</a></span>setRowLower()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setRowLower </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>elementValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a single row lower bound<br  />
 Use -DBL_MAX for -infinity. </p>

</div>
</div>
<a id="a0c0011352b97994d61eef03c82efe395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0011352b97994d61eef03c82efe395">&#9670;&nbsp;</a></span>setRowUpper()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setRowUpper </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>elementValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a single row upper bound<br  />
 Use DBL_MAX for infinity. </p>

</div>
</div>
<a id="aeb778249973ea9143e73b9c2b3cc1158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb778249973ea9143e73b9c2b3cc1158">&#9670;&nbsp;</a></span>setRowBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setRowBounds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>elementIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lower</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>upper</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set a single row lower and upper bound. </p>

</div>
</div>
<a id="a69a9603a8fc04db3114624ec93651a0a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69a9603a8fc04db3114624ec93651a0a">&#9670;&nbsp;</a></span>setRowType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setRowType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char&#160;</td>
          <td class="paramname"><em>sense</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>rightHandSide</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>range</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the type of a single row<br  />
 </p>

</div>
</div>
<a id="a69de6c070854da442eeaee0722af666f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69de6c070854da442eeaee0722af666f">&#9670;&nbsp;</a></span>setRowSetBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setRowSetBounds </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indexFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indexLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>boundList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the bounds on a number of rows simultaneously<br  />
 The default implementation just invokes <a class="el" href="classOsiClpSolverInterface.html#a1bb969c4f0a81edecc56ed50efa703ab" title="Set a single row lower bound  Use -DBL_MAX for -infinity.">setRowLower()</a> and <a class="el" href="classOsiClpSolverInterface.html#a0c0011352b97994d61eef03c82efe395" title="Set a single row upper bound  Use DBL_MAX for infinity.">setRowUpper()</a> over and over again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexFirst,indexLast</td><td>pointers to the beginning and after the end of the array of the indices of the constraints whose <em>either</em> bound changes </td></tr>
    <tr><td class="paramname">boundList</td><td>the new lower/upper bound pairs for the constraints </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a72f1cff6f904e182a365762e50b6c203"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72f1cff6f904e182a365762e50b6c203">&#9670;&nbsp;</a></span>setRowSetTypes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setRowSetTypes </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indexFirst</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indexLast</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>senseList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rhsList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rangeList</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the type of a number of rows simultaneously<br  />
 The default implementation just invokes <a class="el" href="classOsiClpSolverInterface.html#a69a9603a8fc04db3114624ec93651a0a" title="Set the type of a single row">setRowType()</a> over and over again. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">indexFirst,indexLast</td><td>pointers to the beginning and after the end of the array of the indices of the constraints whose <em>any</em> characteristics changes </td></tr>
    <tr><td class="paramname">senseList</td><td>the new senses </td></tr>
    <tr><td class="paramname">rhsList</td><td>the new right hand sides </td></tr>
    <tr><td class="paramname">rangeList</td><td>the new ranges </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a71bd5744ecc5cc953e05a3f6ce39a7ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71bd5744ecc5cc953e05a3f6ce39a7ca">&#9670;&nbsp;</a></span>setObjective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setObjective </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the objective coefficients for all columns array [<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] is an array of values for the objective. </p>
<p>This defaults to a series of set operations and is here for speed. </p>

</div>
</div>
<a id="a752e9d78bf5013f488387032aa4699fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a752e9d78bf5013f488387032aa4699fb">&#9670;&nbsp;</a></span>setColLower() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setColLower </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the lower bounds for all columns array [<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] is an array of values for the objective. </p>
<p>This defaults to a series of set operations and is here for speed. </p>

</div>
</div>
<a id="a7ae48b8f0149458c8e9ab15a4924cb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ae48b8f0149458c8e9ab15a4924cb27">&#9670;&nbsp;</a></span>setColUpper() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setColUpper </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the upper bounds for all columns array [<a class="el" href="classOsiClpSolverInterface.html#a3974c65825e426ed107a5cb032d04e92" title="Get number of columns.">getNumCols()</a>] is an array of values for the objective. </p>
<p>This defaults to a series of set operations and is here for speed. </p>

</div>
</div>
<a id="a408a81bd8abe355907bf30f99ddc5b12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a408a81bd8abe355907bf30f99ddc5b12">&#9670;&nbsp;</a></span>setRowName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setRowName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>rowIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set name of row. </p>

</div>
</div>
<a id="a6acd6c25299f00078731c0571ca45fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6acd6c25299f00078731c0571ca45fc9">&#9670;&nbsp;</a></span>setColName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setColName </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>colIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set name of column. </p>

</div>
</div>
<a id="a46e81d910b92594492fa80c7ca0a7707"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e81d910b92594492fa80c7ca0a7707">&#9670;&nbsp;</a></span>setContinuous() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setContinuous </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the index-th variable to be a continuous variable. </p>

</div>
</div>
<a id="af5a54c3f7658476b76c58453a4c1078a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a54c3f7658476b76c58453a4c1078a">&#9670;&nbsp;</a></span>setInteger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setInteger </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the index-th variable to be an integer variable. </p>

</div>
</div>
<a id="a2e186b5b794f65a55de1eb6906891fcb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e186b5b794f65a55de1eb6906891fcb">&#9670;&nbsp;</a></span>setContinuous() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setContinuous </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the variables listed in indices (which is of length len) to be continuous variables. </p>

</div>
</div>
<a id="a577f7cbc5f7e1cf13368e64abb9b420a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577f7cbc5f7e1cf13368e64abb9b420a">&#9670;&nbsp;</a></span>setInteger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setInteger </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>len</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the variables listed in indices (which is of length len) to be integer variables. </p>

</div>
</div>
<a id="aefa00df8c16f20d5e7e7b020c7cee677"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefa00df8c16f20d5e7e7b020c7cee677">&#9670;&nbsp;</a></span>numberSOS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::numberSOS </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of SOS sets. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00696">696</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a52d913906c846882ae9a0bf9c1cd8225"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a52d913906c846882ae9a0bf9c1cd8225">&#9670;&nbsp;</a></span>setInfo()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const CoinSet* OsiClpSolverInterface::setInfo </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SOS set info. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00701">701</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a5e8ac72d8a1463dd9d85254b6ebf6bdf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e8ac72d8a1463dd9d85254b6ebf6bdf">&#9670;&nbsp;</a></span>replaceSetInfo()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::replaceSetInfo </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberSOS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinSet *&#160;</td>
          <td class="paramname"><em>setInfo</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace setInfo (takes over ownership) </p>

</div>
</div>
<a id="a26b649e4085c4c84774445df74bc86dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a26b649e4085c4c84774445df74bc86dd">&#9670;&nbsp;</a></span>findIntegersAndSOS()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::findIntegersAndSOS </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>justCount</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Identify integer variables and SOS and create corresponding objects. </p>
<p>Record integer variables and create an OsiSimpleInteger object for each one. All existing OsiSimpleInteger objects will be destroyed. If the solver supports SOS then do the same for SOS. If justCount then no objects created and we just store numberIntegers_ Returns number of SOS </p>

</div>
</div>
<a id="a5ae350335a84969fd61ffb39d7efb8ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ae350335a84969fd61ffb39d7efb8ab">&#9670;&nbsp;</a></span>setObjSense()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setObjSense </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set objective function sense (1 for min (default), -1 for max,) </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00721">721</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a80830b885caff6079556d4bdb7403ad5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80830b885caff6079556d4bdb7403ad5">&#9670;&nbsp;</a></span>setColSolution()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setColSolution </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>colsol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the primal solution column values. </p>
<p>colsol[numcols()] is an array of values of the problem column variables. These values are copied to memory owned by the solver object or the solver. They will be returned as the result of colsol() until changed by another call to setColsol() or by a call to any solver routine. Whether the solver makes use of the solution in any way is solver-dependent. </p>

</div>
</div>
<a id="a0b00c8fdbf8f2b141fdae89e0c453b18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b00c8fdbf8f2b141fdae89e0c453b18">&#9670;&nbsp;</a></span>setRowPrice()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::setRowPrice </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowprice</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set dual solution vector. </p>
<p>rowprice[numrows()] is an array of values of the problem row dual variables. These values are copied to memory owned by the solver object or the solver. They will be returned as the result of rowprice() until changed by another call to setRowprice() or by a call to any solver routine. Whether the solver makes use of the solution in any way is solver-dependent. </p>

</div>
</div>
<a id="ae1468e0c5aab6c3b3b3fe0e3010c43ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae1468e0c5aab6c3b3b3fe0e3010c43ac">&#9670;&nbsp;</a></span>addCol() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addCol </td>
          <td>(</td>
          <td class="paramtype">const CoinPackedVectorBase &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a93cd285d584c3a7d9b3dc8d7697f1a6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a93cd285d584c3a7d9b3dc8d7697f1a6d">&#9670;&nbsp;</a></span>addCol() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addCol </td>
          <td>(</td>
          <td class="paramtype">const CoinPackedVectorBase &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a named column (primal variable) to the problem. </p>

</div>
</div>
<a id="ae67dab111b39d36f5df74c47bed91c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae67dab111b39d36f5df74c47bed91c2b">&#9670;&nbsp;</a></span>addCol() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addCol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a column (primal variable) to the problem. </p>

</div>
</div>
<a id="abd8f7cfccfae51be9b8308a9b097518d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd8f7cfccfae51be9b8308a9b097518d">&#9670;&nbsp;</a></span>addCol() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addCol </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a named column (primal variable) to the problem. </p>

</div>
</div>
<a id="a96d210a3c5aaacc450616e22c9a030af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a96d210a3c5aaacc450616e22c9a030af">&#9670;&nbsp;</a></span>addCols() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addCols </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numcols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinPackedVectorBase *const *&#160;</td>
          <td class="paramname"><em>cols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af0329ae1907d0c1f3dc550f36dd1faf4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0329ae1907d0c1f3dc550f36dd1faf4">&#9670;&nbsp;</a></span>addCols() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addCols </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numcols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinBigIndex *&#160;</td>
          <td class="paramname"><em>columnStarts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>elements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>obj</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3940432d91d0f1b536c5a9c99d9d1560"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3940432d91d0f1b536c5a9c99d9d1560">&#9670;&nbsp;</a></span>deleteCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::deleteCols </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>colIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aea382607dd0226a0b1429c48f1d9d961"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea382607dd0226a0b1429c48f1d9d961">&#9670;&nbsp;</a></span>addRow() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addRow </td>
          <td>(</td>
          <td class="paramtype">const CoinPackedVectorBase &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rowlb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rowub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1ada55990289350a103c82df44c3072a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ada55990289350a103c82df44c3072a">&#9670;&nbsp;</a></span>addRow() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addRow </td>
          <td>(</td>
          <td class="paramtype">const CoinPackedVectorBase &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rowlb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rowub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a named row (constraint) to the problem. </p>
<p>The default implementation adds the row, then changes the name. This can surely be made more efficient within an OsiXXX class. </p>

</div>
</div>
<a id="ae952a09cb2d96a3519d4d34f049691d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae952a09cb2d96a3519d4d34f049691d6">&#9670;&nbsp;</a></span>addRow() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addRow </td>
          <td>(</td>
          <td class="paramtype">const CoinPackedVectorBase &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>rowsen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rowrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rowrng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a64713b9b7038f65a6d8edc4acebde69b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64713b9b7038f65a6d8edc4acebde69b">&#9670;&nbsp;</a></span>addRow() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addRow </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rowlb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rowub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a row (constraint) to the problem. </p>

</div>
</div>
<a id="a12afc2fb8b9eb71f2ba38ec6d70f21fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12afc2fb8b9eb71f2ba38ec6d70f21fa">&#9670;&nbsp;</a></span>addRow() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addRow </td>
          <td>(</td>
          <td class="paramtype">const CoinPackedVectorBase &amp;&#160;</td>
          <td class="paramname"><em>vec</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char&#160;</td>
          <td class="paramname"><em>rowsen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rowrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>rowrng</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Add a named row (constraint) to the problem. </p>

</div>
</div>
<a id="a481ef9b452cde75397367ee976b6a003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a481ef9b452cde75397367ee976b6a003">&#9670;&nbsp;</a></span>addRows() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addRows </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinPackedVectorBase *const *&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowlb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a04eb479511f001d28c34fe90141e3b6b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04eb479511f001d28c34fe90141e3b6b">&#9670;&nbsp;</a></span>addRows() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addRows </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinPackedVectorBase *const *&#160;</td>
          <td class="paramname"><em>rows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rowsen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowrng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1c89064d8ad103b5dab917542c7fccaa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c89064d8ad103b5dab917542c7fccaa">&#9670;&nbsp;</a></span>addRows() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::addRows </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinBigIndex *&#160;</td>
          <td class="paramname"><em>rowStarts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>columns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowlb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a5853c50fb27c6c56e98c5d2027fa8a1a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5853c50fb27c6c56e98c5d2027fa8a1a">&#9670;&nbsp;</a></span>modifyCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::modifyCoefficient </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l00827">827</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a378db4535176e47f22c06731be8b3d3c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a378db4535176e47f22c06731be8b3d3c">&#9670;&nbsp;</a></span>deleteRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::deleteRows </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>rowIndices</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a28693577027085f44c0befc067032dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28693577027085f44c0befc067032dae">&#9670;&nbsp;</a></span>saveBaseModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::saveBaseModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If solver wants it can save a copy of "base" (continuous) model here. </p>

</div>
</div>
<a id="aff5ef8d2ccfb179050c6bf7d152c7578"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff5ef8d2ccfb179050c6bf7d152c7578">&#9670;&nbsp;</a></span>restoreBaseModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::restoreBaseModel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberRows</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Strip off rows to get to this number of rows. </p>
<p>If solver wants it can restore a copy of "base" (continuous) model here </p>

</div>
</div>
<a id="a6370d8bba83369f9f779402d4ce0cd59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6370d8bba83369f9f779402d4ce0cd59">&#9670;&nbsp;</a></span>applyRowCuts() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::applyRowCuts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberCuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsiRowCut *&#160;</td>
          <td class="paramname"><em>cuts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a collection of row cuts which are all effective. </p>
<p>applyCuts seems to do one at a time which seems inefficient. </p>

</div>
</div>
<a id="a5dd0fb25ca9258b6c96f780dce53437a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5dd0fb25ca9258b6c96f780dce53437a">&#9670;&nbsp;</a></span>applyRowCuts() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::applyRowCuts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberCuts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const OsiRowCut **&#160;</td>
          <td class="paramname"><em>cuts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a collection of row cuts which are all effective. </p>
<p>applyCuts seems to do one at a time which seems inefficient. This uses array of pointers </p>

</div>
</div>
<a id="a1b8335b1ecb23cbe52d28166fb9cf385"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b8335b1ecb23cbe52d28166fb9cf385">&#9670;&nbsp;</a></span>applyCuts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ApplyCutsReturnCode OsiClpSolverInterface::applyCuts </td>
          <td>(</td>
          <td class="paramtype">const OsiCuts &amp;&#160;</td>
          <td class="paramname"><em>cs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>effectivenessLb</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a collection of cuts. </p>
<p>Only cuts which have an <code>effectiveness &gt;= effectivenessLb</code> are applied. </p><ul>
<li>
ReturnCode.getNumineffective() &ndash; number of cuts which were not applied because they had an <code>effectiveness &lt; effectivenessLb</code> </li>
<li>
ReturnCode.getNuminconsistent() &ndash; number of invalid cuts </li>
<li>
ReturnCode.getNuminconsistentWrtIntegerModel() &ndash; number of cuts that are invalid with respect to this integer model </li>
<li>
ReturnCode.getNuminfeasible() &ndash; number of cuts that would make this integer model infeasible </li>
<li>
ReturnCode.getNumApplied() &ndash; number of integer cuts which were applied to the integer model </li>
<li>
cs.size() == getNumineffective() + getNuminconsistent() + getNuminconsistentWrtIntegerModel() + getNuminfeasible() + getNumApplied() </li>
</ul>

</div>
</div>
<a id="a228ef777d30c109b2d9deee997340af6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a228ef777d30c109b2d9deee997340af6">&#9670;&nbsp;</a></span>loadProblem() <span class="overload">[1/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::loadProblem </td>
          <td>(</td>
          <td class="paramtype">const CoinPackedMatrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowlb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load in an problem by copying the arguments (the constraints on the rows are given by lower and upper bounds). </p>
<p>If a pointer is NULL then the following values are the default: </p><ul>
<li>
<code>colub</code>: all columns have upper bound infinity </li>
<li>
<code>collb</code>: all columns have lower bound 0 </li>
<li>
<code>rowub</code>: all rows have upper bound infinity </li>
<li>
<code>rowlb</code>: all rows have lower bound -infinity </li>
<li>
<code>obj</code>: all variables have 0 objective coefficient </li>
</ul>

</div>
</div>
<a id="aeaff08407a8bebafe8b7ed913e4e6bc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaff08407a8bebafe8b7ed913e4e6bc5">&#9670;&nbsp;</a></span>assignProblem() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::assignProblem </td>
          <td>(</td>
          <td class="paramtype">CoinPackedMatrix *&amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>rowlb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>rowub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load in an problem by assuming ownership of the arguments (the constraints on the rows are given by lower and upper bounds). </p>
<p>For default values see the previous method. <br  />
 <b>WARNING</b>: The arguments passed to this method will be freed using the C++ <code>delete</code> and <code>delete[]</code> functions. </p>

</div>
</div>
<a id="a7e0c384df66ab3174d0fe82e0eebcc72"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e0c384df66ab3174d0fe82e0eebcc72">&#9670;&nbsp;</a></span>loadProblem() <span class="overload">[2/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::loadProblem </td>
          <td>(</td>
          <td class="paramtype">const CoinPackedMatrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rowsen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowrng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load in an problem by copying the arguments (the constraints on the rows are given by sense/rhs/range triplets). </p>
<p>If a pointer is NULL then the following values are the default: </p><ul>
<li>
<code>colub</code>: all columns have upper bound infinity </li>
<li>
<code>collb</code>: all columns have lower bound 0 </li>
<li>
<code>obj</code>: all variables have 0 objective coefficient </li>
<li>
<code>rowsen</code>: all rows are &gt;= </li>
<li>
<code>rowrhs</code>: all right hand sides are 0 </li>
<li>
<code>rowrng</code>: 0 for the ranged rows </li>
</ul>

</div>
</div>
<a id="a88ce6695fa4291f371c9dfdd9bf0113e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88ce6695fa4291f371c9dfdd9bf0113e">&#9670;&nbsp;</a></span>assignProblem() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::assignProblem </td>
          <td>(</td>
          <td class="paramtype">CoinPackedMatrix *&amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">char *&amp;&#160;</td>
          <td class="paramname"><em>rowsen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>rowrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&amp;&#160;</td>
          <td class="paramname"><em>rowrng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Load in an problem by assuming ownership of the arguments (the constraints on the rows are given by sense/rhs/range triplets). </p>
<p>For default values see the previous method. <br  />
 <b>WARNING</b>: The arguments passed to this method will be freed using the C++ <code>delete</code> and <code>delete[]</code> functions. </p>

</div>
</div>
<a id="a9c70cc873bc5757b82b6425fe147c0cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c70cc873bc5757b82b6425fe147c0cb">&#9670;&nbsp;</a></span>loadProblem() <span class="overload">[3/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::loadProblem </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a> &amp;&#160;</td>
          <td class="paramname"><em>matrix</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowlb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the other <a class="el" href="classOsiClpSolverInterface.html#a228ef777d30c109b2d9deee997340af6" title="Load in an problem by copying the arguments (the constraints on the rows are given by lower and upper...">loadProblem()</a> methods except that the matrix is given as a <a class="el" href="classClpMatrixBase.html" title="Abstract base class for Clp Matrices.">ClpMatrixBase</a>. </p>

</div>
</div>
<a id="a735e5b67e255999e37d3cb49bef1fe1b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a735e5b67e255999e37d3cb49bef1fe1b">&#9670;&nbsp;</a></span>loadProblem() <span class="overload">[4/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::loadProblem </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numcols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinBigIndex *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowlb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowub</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the other <a class="el" href="classOsiClpSolverInterface.html#a228ef777d30c109b2d9deee997340af6" title="Load in an problem by copying the arguments (the constraints on the rows are given by lower and upper...">loadProblem()</a> methods except that the matrix is given in a standard column major ordered format (without gaps). </p>

</div>
</div>
<a id="a7ee1584ae1f0e65a97dacee30f44ad17"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ee1584ae1f0e65a97dacee30f44ad17">&#9670;&nbsp;</a></span>loadProblem() <span class="overload">[5/5]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::loadProblem </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numcols</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinBigIndex *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>value</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>collb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>colub</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>obj</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>rowsen</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowrhs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowrng</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just like the other <a class="el" href="classOsiClpSolverInterface.html#a228ef777d30c109b2d9deee997340af6" title="Load in an problem by copying the arguments (the constraints on the rows are given by lower and upper...">loadProblem()</a> methods except that the matrix is given in a standard column major ordered format (without gaps). </p>

</div>
</div>
<a id="acfeefbd150fa18f72a9507615bc4a0dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfeefbd150fa18f72a9507615bc4a0dc">&#9670;&nbsp;</a></span>loadFromCoinModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::loadFromCoinModel </td>
          <td>(</td>
          <td class="paramtype">CoinModel &amp;&#160;</td>
          <td class="paramname"><em>modelObject</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepSolution</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This loads a model from a coinModel object - returns number of errors. </p>

</div>
</div>
<a id="a71e6eb66d43ab27d931b71be0a0a76ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71e6eb66d43ab27d931b71be0a0a76ec">&#9670;&nbsp;</a></span>readMps() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::readMps </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extension</em> = <code>&quot;mps&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an mps file from the given filename (defaults to Osi reader) - returns number of errors (see OsiMpsReader class) </p>

</div>
</div>
<a id="aedd68d7b3e54507a1afa0df0712f76d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedd68d7b3e54507a1afa0df0712f76d1">&#9670;&nbsp;</a></span>readMps() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::readMps </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>allowErrors</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read an mps file from the given filename returns number of errors (see OsiMpsReader class) </p>

</div>
</div>
<a id="a1b9626cb116e1dbd4bc20c70dc622c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b9626cb116e1dbd4bc20c70dc622c76">&#9670;&nbsp;</a></span>readMps() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::readMps </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extension</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinSet **&amp;&#160;</td>
          <td class="paramname"><em>sets</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read an mps file. </p>

</div>
</div>
<a id="ae76540b2b75c79fb2b3172f466e134f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae76540b2b75c79fb2b3172f466e134f8">&#9670;&nbsp;</a></span>writeMps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::writeMps </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extension</em> = <code>&quot;mps&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>objSense</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the problem into an mps file of the given filename. </p>
<p>If objSense is non zero then -1.0 forces the code to write a maximization objective and +1.0 to write a minimization one. If 0.0 then solver can do what it wants </p>

</div>
</div>
<a id="ad567bab4c941cc2c2952b7e5dccbe5f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad567bab4c941cc2c2952b7e5dccbe5f1">&#9670;&nbsp;</a></span>writeMpsNative()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::writeMpsNative </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>rowNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char **&#160;</td>
          <td class="paramname"><em>columnNames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>formatType</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberAcross</em> = <code>2</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>objSense</em> = <code>0.0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the problem into an mps file of the given filename, names may be null. </p>
<p>formatType is 0 - normal 1 - extra accuracy 2 - IEEE hex (later)</p>
<p>Returns non-zero on I/O error </p>

</div>
</div>
<a id="ad13f9e98ebaec68ce028d5aec95e6c38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad13f9e98ebaec68ce028d5aec95e6c38">&#9670;&nbsp;</a></span>readLp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::readLp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-5</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Read file in LP format (with names) </p>

</div>
</div>
<a id="ad552991179c48acf6568c33f02000a0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad552991179c48acf6568c33f02000a0b">&#9670;&nbsp;</a></span>writeLp() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::writeLp </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>extension</em> = <code>&quot;lp&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberAcross</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>decimals</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>objSense</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useRowNames</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the problem into an Lp file of the given filename. </p>
<p>If objSense is non zero then -1.0 forces the code to write a maximization objective and +1.0 to write a minimization one. If 0.0 then solver can do what it wants. This version calls writeLpNative with names </p>

</div>
</div>
<a id="af35d271b386dce75c94f224ffd9f6687"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af35d271b386dce75c94f224ffd9f6687">&#9670;&nbsp;</a></span>writeLp() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::writeLp </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>epsilon</em> = <code>1e-5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberAcross</em> = <code>10</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>decimals</em> = <code>5</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>objSense</em> = <code>0.0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useRowNames</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Write the problem into the file pointed to by the parameter fp. </p>
<p>Other parameters are similar to those of <a class="el" href="classOsiClpSolverInterface.html#ad552991179c48acf6568c33f02000a0b" title="Write the problem into an Lp file of the given filename.">writeLp()</a> with first parameter filename. </p>

</div>
</div>
<a id="a11d22f6ccd5410fdb8b8c71ad6af2817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11d22f6ccd5410fdb8b8c71ad6af2817">&#9670;&nbsp;</a></span>replaceMatrixOptional()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::replaceMatrixOptional </td>
          <td>(</td>
          <td class="paramtype">const CoinPackedMatrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>I (JJF) am getting annoyed because I can't just replace a matrix. </p>
<p>The default behavior of this is do nothing so only use where that would not matter e.g. strengthening a matrix for MIP </p>

</div>
</div>
<a id="a16ab3e2181d85df73c6ccd5743265fc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16ab3e2181d85df73c6ccd5743265fc9">&#9670;&nbsp;</a></span>replaceMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::replaceMatrix </td>
          <td>(</td>
          <td class="paramtype">const CoinPackedMatrix &amp;&#160;</td>
          <td class="paramname"><em>matrix</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>And if it does matter (not used at present) </p>

</div>
</div>
<a id="ad553e1ca376c5e7a476e32dfcb322c66"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad553e1ca376c5e7a476e32dfcb322c66">&#9670;&nbsp;</a></span>passInMessageHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::passInMessageHandler </td>
          <td>(</td>
          <td class="paramtype">CoinMessageHandler *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass in a message handler. </p>
<p>It is the client's responsibility to destroy a message handler installed by this routine; it will not be destroyed when the solver interface is destroyed. </p>

</div>
</div>
<a id="a7aa0b4761574324fb446a041ab577fbc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7aa0b4761574324fb446a041ab577fbc">&#9670;&nbsp;</a></span>newLanguage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::newLanguage </td>
          <td>(</td>
          <td class="paramtype">CoinMessages::Language&#160;</td>
          <td class="paramname"><em>language</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set language. </p>

</div>
</div>
<a id="abb85941297ab13ddb85641ca3a20e322"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb85941297ab13ddb85641ca3a20e322">&#9670;&nbsp;</a></span>setLanguage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setLanguage </td>
          <td>(</td>
          <td class="paramtype">CoinMessages::Language&#160;</td>
          <td class="paramname"><em>language</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01048">1048</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a2aed8d42b43ddd37032fd17381519d81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2aed8d42b43ddd37032fd17381519d81">&#9670;&nbsp;</a></span>setLogLevel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setLogLevel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set log level (will also set underlying solver's log level) </p>

</div>
</div>
<a id="a6d340272124d03f6671cf0f1c6dfee13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d340272124d03f6671cf0f1c6dfee13">&#9670;&nbsp;</a></span>generateCpp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::generateCpp </td>
          <td>(</td>
          <td class="paramtype">FILE *&#160;</td>
          <td class="paramname"><em>fp</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create C++ lines to get to current state. </p>

</div>
</div>
<a id="a9577a39c03540e4ad904bb7cf121806b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9577a39c03540e4ad904bb7cf121806b">&#9670;&nbsp;</a></span>getModelPtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpSimplex.html">ClpSimplex</a>* OsiClpSolverInterface::getModelPtr </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get pointer to Clp model. </p>

</div>
</div>
<a id="afa7dbf164c916541bd3cb39bee3227d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa7dbf164c916541bd3cb39bee3227d4">&#9670;&nbsp;</a></span>swapModelPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpSimplex.html">ClpSimplex</a>* OsiClpSolverInterface::swapModelPtr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>newModel</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set pointer to Clp model and return old. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01064">1064</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a7dcd2092995ba51a233cb61acf16317a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7dcd2092995ba51a233cb61acf16317a">&#9670;&nbsp;</a></span>specialOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int OsiClpSolverInterface::specialOptions </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get special options. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01071">1071</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a9d2dddda6180e8239d3124e41e0c37f2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d2dddda6180e8239d3124e41e0c37f2">&#9670;&nbsp;</a></span>setSpecialOptions()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setSpecialOptions </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ac3c37219c4fa31a1c4fd809bfef80f9f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3c37219c4fa31a1c4fd809bfef80f9f">&#9670;&nbsp;</a></span>lastAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::lastAlgorithm </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Last algorithm used , 1 = primal, 2 = dual other unknown. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01077">1077</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a8ffbbbcdd1c3e960ba3dce3444e555e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ffbbbcdd1c3e960ba3dce3444e555e4">&#9670;&nbsp;</a></span>setLastAlgorithm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setLastAlgorithm </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set last algorithm used , 1 = primal, 2 = dual other unknown. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01082">1082</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a958fc25c2359f38da835c4d09711d30c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a958fc25c2359f38da835c4d09711d30c">&#9670;&nbsp;</a></span>cleanupScaling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::cleanupScaling </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get scaling action option. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01087">1087</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ae27edb77b9dd2fc9ae1727963af8bc07"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae27edb77b9dd2fc9ae1727963af8bc07">&#9670;&nbsp;</a></span>setCleanupScaling()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setCleanupScaling </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set Scaling option When scaling is on it is possible that the scaled problem is feasible but the unscaled is not. </p>
<p>Clp returns a secondary status code to that effect. This option allows for a cleanup. If you use it I would suggest 1. This only affects actions when scaled optimal 0 - no action 1 - clean up using dual if primal infeasibility 2 - clean up using dual if dual infeasibility 3 - clean up using dual if primal or dual infeasibility 11,12,13 - as 1,2,3 but use primal </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01103">1103</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="aae16c5e2861c7d372206b4a8a81fd9ab"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae16c5e2861c7d372206b4a8a81fd9ab">&#9670;&nbsp;</a></span>smallestElementInCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OsiClpSolverInterface::smallestElementInCut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get smallest allowed element in cut. </p>
<p>If smaller than this then ignored </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01109">1109</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a9fdd9d00e96318dc9a5d55f4f5c86f26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdd9d00e96318dc9a5d55f4f5c86f26">&#9670;&nbsp;</a></span>setSmallestElementInCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setSmallestElementInCut </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set smallest allowed element in cut. </p>
<p>If smaller than this then ignored </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01115">1115</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a531c41b4eac2898020415d84793a5d69"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a531c41b4eac2898020415d84793a5d69">&#9670;&nbsp;</a></span>smallestChangeInCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OsiClpSolverInterface::smallestChangeInCut </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get smallest change in cut. </p>
<p>If (upper-lower)*element &lt; this then element is taken out and cut relaxed. (upper-lower) is taken to be at least 1.0 and this is assumed &gt;= smallestElementInCut_ </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01125">1125</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ab14155ba949f890a974628cd585bda92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab14155ba949f890a974628cd585bda92">&#9670;&nbsp;</a></span>setSmallestChangeInCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setSmallestChangeInCut </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set smallest change in cut. </p>
<p>If (upper-lower)*element &lt; this then element is taken out and cut relaxed. (upper-lower) is taken to be at least 1.0 and this is assumed &gt;= smallestElementInCut_ </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01135">1135</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="aea55f2e6e78b45ca0eefe96e11dd2525"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aea55f2e6e78b45ca0eefe96e11dd2525">&#9670;&nbsp;</a></span>setSolveOptions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setSolveOptions </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSolve.html">ClpSolve</a> &amp;&#160;</td>
          <td class="paramname"><em>options</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass in initial solve options. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01140">1140</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a08a48e701969bc18ccd1177d05f6d901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08a48e701969bc18ccd1177d05f6d901">&#9670;&nbsp;</a></span>tightenBounds()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int OsiClpSolverInterface::tightenBounds </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>lightweight</em> = <code>0</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Tighten bounds - lightweight or very lightweight 0 - normal, 1 lightweight but just integers, 2 lightweight and all. </p>

</div>
</div>
<a id="a06e31cd87c914e365ee2f1d3e6c36e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06e31cd87c914e365ee2f1d3e6c36e70">&#9670;&nbsp;</a></span>infeasibleOtherWay()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::infeasibleOtherWay </td>
          <td>(</td>
          <td class="paramtype">char *&#160;</td>
          <td class="paramname"><em>whichWay</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>See if any integer variables make infeasible other way. </p>

</div>
</div>
<a id="a083487a2bc3bb6a6c528101af0a81678"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a083487a2bc3bb6a6c528101af0a81678">&#9670;&nbsp;</a></span>getSizeL()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CoinBigIndex OsiClpSolverInterface::getSizeL </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of entries in L part of current factorization. </p>

</div>
</div>
<a id="a0e91556cf6d2fad259f30a4cdac65a2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0e91556cf6d2fad259f30a4cdac65a2f">&#9670;&nbsp;</a></span>getSizeU()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CoinBigIndex OsiClpSolverInterface::getSizeU </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return number of entries in U part of current factorization. </p>

</div>
</div>
<a id="ad00b4825d3bf98d45874de1b7fdf61b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad00b4825d3bf98d45874de1b7fdf61b9">&#9670;&nbsp;</a></span>disasterHandler()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const <a class="el" href="classOsiClpDisasterHandler.html">OsiClpDisasterHandler</a>* OsiClpSolverInterface::disasterHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get disaster handler. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01155">1155</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a2b86ec65d8000c64506f6a4f36c75d05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b86ec65d8000c64506f6a4f36c75d05">&#9670;&nbsp;</a></span>passInDisasterHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::passInDisasterHandler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classOsiClpDisasterHandler.html">OsiClpDisasterHandler</a> *&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass in disaster handler. </p>

</div>
</div>
<a id="af7460cfa449b2dd317cf2e48c1756fb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7460cfa449b2dd317cf2e48c1756fb2">&#9670;&nbsp;</a></span>fakeObjective()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpLinearObjective.html">ClpLinearObjective</a>* OsiClpSolverInterface::fakeObjective </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get fake objective. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01162">1162</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a01694cda8754fb13e5908abdc05d9bc7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01694cda8754fb13e5908abdc05d9bc7">&#9670;&nbsp;</a></span>setFakeObjective() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setFakeObjective </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpLinearObjective.html">ClpLinearObjective</a> *&#160;</td>
          <td class="paramname"><em>fakeObjective</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set fake objective (and take ownership) </p>

</div>
</div>
<a id="a0a30869740fdf6788a5a1f43ac025de2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a30869740fdf6788a5a1f43ac025de2">&#9670;&nbsp;</a></span>setFakeObjective() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setFakeObjective </td>
          <td>(</td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>fakeObjective</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set fake objective. </p>

</div>
</div>
<a id="ad932fba66cd3aa626fa4875c3dfde84b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad932fba66cd3aa626fa4875c3dfde84b">&#9670;&nbsp;</a></span>setupForRepeatedUse()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setupForRepeatedUse </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>senseOfAdventure</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>printOut</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set up solver for repeated use by Osi interface. </p>
<p>The normal usage does things like keeping factorization around so can be used. Will also do things like keep scaling and row copy of matrix if matrix does not change.</p>
<p><code>senseOfAdventure:</code> </p><ul>
<li>0 - safe stuff as above</li>
<li>1 - will take more risks - if it does not work then bug which will be fixed</li>
<li>2 - don't bother doing most extreme termination checks e.g. don't bother re-factorizing if less than 20 iterations.</li>
<li>3 - Actually safer than 1 (mainly just keeps factorization)</li>
</ul>
<p><code>printOut</code> </p><ul>
<li>-1 always skip round common messages instead of doing some work</li>
<li>0 skip if normal defaults</li>
<li>1 leaves </li>
</ul>

</div>
</div>
<a id="a72881558f5275d18064d6dc7e17cdc7f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72881558f5275d18064d6dc7e17cdc7f">&#9670;&nbsp;</a></span>synchronizeModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::synchronizeModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Synchronize model (really if no cuts in tree) </p>

</div>
</div>
<a id="a47ada3e0f4cbd065d5569d5eba0bb942"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a47ada3e0f4cbd065d5569d5eba0bb942">&#9670;&nbsp;</a></span>setSpecialOptionsMutable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setSpecialOptionsMutable </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Set special options in underlying clp solver. </p>
<p>Safe as const because <a class="el" href="classOsiClpSolverInterface.html#ab2815665a2a99269e429d5113e60d1cb" title="Clp model represented by this class instance.">modelPtr_</a> is mutable. </p>

</div>
</div>
<a id="a2dc398be8a0cc03a189cca5c1234add4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2dc398be8a0cc03a189cca5c1234add4">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="Idiot_8hpp.html#a6ab52e0531bad8c380587f176e4360df">OsiSolverInterface</a>* OsiClpSolverInterface::clone </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>copyData</em> = <code>true</code></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clone. </p>

</div>
</div>
<a id="a17bffe09a1ba89c163993bc547199c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a17bffe09a1ba89c163993bc547199c8e">&#9670;&nbsp;</a></span>releaseClp()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::releaseClp </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Releases so won't error. </p>

</div>
</div>
<a id="a4178b31ccbcf045bf822d018ad3cfa26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4178b31ccbcf045bf822d018ad3cfa26">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOsiClpSolverInterface.html">OsiClpSolverInterface</a>&amp; OsiClpSolverInterface::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classOsiClpSolverInterface.html">OsiClpSolverInterface</a> &amp;&#160;</td>
          <td class="paramname"><em>rhs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Assignment operator. </p>

</div>
</div>
<a id="ab65eb7d74f48acd8848ab46ae1797403"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab65eb7d74f48acd8848ab46ae1797403">&#9670;&nbsp;</a></span>reset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::reset </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resets as if default constructor. </p>

</div>
</div>
<a id="af099813042416bc89f15bd0cdf4ebf43"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af099813042416bc89f15bd0cdf4ebf43">&#9670;&nbsp;</a></span>applyRowCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::applyRowCut </td>
          <td>(</td>
          <td class="paramtype">const OsiRowCut &amp;&#160;</td>
          <td class="paramname"><em>rc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a row cut (append to constraint matrix). </p>

</div>
</div>
<a id="a3590567e10cb7a0f944621d9a6f38c26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3590567e10cb7a0f944621d9a6f38c26">&#9670;&nbsp;</a></span>applyColCut()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void OsiClpSolverInterface::applyColCut </td>
          <td>(</td>
          <td class="paramtype">const OsiColCut &amp;&#160;</td>
          <td class="paramname"><em>cc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Apply a column cut (adjust one or more bounds). </p>

</div>
</div>
<a id="ad9de23527741e87af63a1a1dee8251c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9de23527741e87af63a1a1dee8251c0">&#9670;&nbsp;</a></span>gutsOfDestructor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::gutsOfDestructor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The real work of a copy constructor (used by copy and assignment) </p>

</div>
</div>
<a id="a328b5fe77e3261419b07f1aafd68bd37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a328b5fe77e3261419b07f1aafd68bd37">&#9670;&nbsp;</a></span>freeCachedResults()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::freeCachedResults </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all mutable stuff. </p>

</div>
</div>
<a id="a59d4e3599dafbe0dc79e098547649d59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59d4e3599dafbe0dc79e098547649d59">&#9670;&nbsp;</a></span>freeCachedResults0()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::freeCachedResults0 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all mutable stuff for row ranges etc. </p>

</div>
</div>
<a id="a852dae17dc4f3a820c4b28087492e2ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852dae17dc4f3a820c4b28087492e2ba">&#9670;&nbsp;</a></span>freeCachedResults1()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::freeCachedResults1 </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Deletes all mutable stuff for matrix etc. </p>

</div>
</div>
<a id="a4a185b3a49856d7ca5158133ff6ac10d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a185b3a49856d7ca5158133ff6ac10d">&#9670;&nbsp;</a></span>extractSenseRhsRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::extractSenseRhsRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A method that fills up the rowsense_, rhs_ and rowrange_ arrays. </p>

</div>
</div>
<a id="a95035609eb46e59c0bed6f3bac65b70b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95035609eb46e59c0bed6f3bac65b70b">&#9670;&nbsp;</a></span>fillParamMaps()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::fillParamMaps </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad23105f3c49699e3560fd3c59aaa8a54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad23105f3c49699e3560fd3c59aaa8a54">&#9670;&nbsp;</a></span>getBasis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoinWarmStartBasis OsiClpSolverInterface::getBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Warm start. </p>
<p>NOTE artificials are treated as +1 elements so for &lt;= rhs artificial will be at lower bound if constraint is tight</p>
<p>This means that Clpsimplex flips artificials as it works in terms of row activities </p>

</div>
</div>
<a id="aba88a55ee78067f3f01b9dc975ea0ace"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba88a55ee78067f3f01b9dc975ea0ace">&#9670;&nbsp;</a></span>setBasis() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setBasis </td>
          <td>(</td>
          <td class="paramtype">const CoinWarmStartBasis &amp;&#160;</td>
          <td class="paramname"><em>basis</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets up working basis as a copy of input. </p>
<p>NOTE artificials are treated as +1 elements so for &lt;= rhs artificial will be at lower bound if constraint is tight</p>
<p>This means that Clpsimplex flips artificials as it works in terms of row activities </p>

</div>
</div>
<a id="a04bcd068f290d0ad1e33d787442a3994"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04bcd068f290d0ad1e33d787442a3994">&#9670;&nbsp;</a></span>crunch()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::crunch </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Crunch down problem a bit. </p>

</div>
</div>
<a id="a15cfaf0110042166c5f218078b95b24e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15cfaf0110042166c5f218078b95b24e">&#9670;&nbsp;</a></span>redoScaleFactors()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::redoScaleFactors </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinBigIndex *&#160;</td>
          <td class="paramname"><em>starts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>elements</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Extend scale factors. </p>

</div>
</div>
<a id="a200f4473f1941caf32cb737743f6c93e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a200f4473f1941caf32cb737743f6c93e">&#9670;&nbsp;</a></span>setBasis() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setBasis </td>
          <td>(</td>
          <td class="paramtype">const CoinWarmStartBasis &amp;&#160;</td>
          <td class="paramname"><em>basis</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up working basis as a copy of input and puts in as basis. </p>

</div>
</div>
<a id="ac03aa68cbedc4cb92c28501b83b03d20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac03aa68cbedc4cb92c28501b83b03d20">&#9670;&nbsp;</a></span>setBasis() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setBasis </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just puts current basis_ into <a class="el" href="classClpSimplex.html" title="This solves LPs using the simplex method.">ClpSimplex</a> model. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01292">1292</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a3a562565110ca30492b92674b02389e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3a562565110ca30492b92674b02389e2">&#9670;&nbsp;</a></span>getBasisDiff()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CoinWarmStartDiff* OsiClpSolverInterface::getBasisDiff </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>statusArray</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Warm start difference from basis_ to statusArray. </p>

</div>
</div>
<a id="a6aec1ea4594bf2af1de5cc2b8e8bb1ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6aec1ea4594bf2af1de5cc2b8e8bb1ca">&#9670;&nbsp;</a></span>getBasis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">CoinWarmStartBasis* OsiClpSolverInterface::getBasis </td>
          <td>(</td>
          <td class="paramtype">const unsigned char *&#160;</td>
          <td class="paramname"><em>statusArray</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Warm start from statusArray. </p>

</div>
</div>
<a id="a8ae880a854422a8af7995ab310ca9827"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae880a854422a8af7995ab310ca9827">&#9670;&nbsp;</a></span>deleteScaleFactors()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::deleteScaleFactors </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete all scale factor stuff and reset option. </p>

</div>
</div>
<a id="a810186d89b0e10b23f3342633d894b78"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810186d89b0e10b23f3342633d894b78">&#9670;&nbsp;</a></span>upRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double* OsiClpSolverInterface::upRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If doing fast hot start then ranges are computed. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01303">1303</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a86249d262a9159b329c2b11e3f1b7c76"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86249d262a9159b329c2b11e3f1b7c76">&#9670;&nbsp;</a></span>downRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const double* OsiClpSolverInterface::downRange </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01307">1307</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="aa6a4b8806916c42056db588043633dd9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa6a4b8806916c42056db588043633dd9">&#9670;&nbsp;</a></span>passInRanges()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::passInRanges </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>array</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pass in range array. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01312">1312</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ad9ec7ce73c6741e2680eff4c61e8ce38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad9ec7ce73c6741e2680eff4c61e8ce38">&#9670;&nbsp;</a></span>setSOSData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setSOSData </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberSOS</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indices</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>weights</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Pass in sos stuff from AMPl. </p>

</div>
</div>
<a id="a8e5cd27d720af5c03a37d3f764b78a9d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e5cd27d720af5c03a37d3f764b78a9d">&#9670;&nbsp;</a></span>computeLargestAway()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::computeLargestAway </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Compute largest amount any at continuous away from bound. </p>

</div>
</div>
<a id="aa0a9aac86be4584291948b8b570ee4ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa0a9aac86be4584291948b8b570ee4ec">&#9670;&nbsp;</a></span>largestAway()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OsiClpSolverInterface::largestAway </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get largest amount continuous away from bound. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01322">1322</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a437d2168c1e3db368073a0e1498852c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a437d2168c1e3db368073a0e1498852c9">&#9670;&nbsp;</a></span>setLargestAway()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setLargestAway </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set largest amount continuous away from bound. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01327">1327</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a036593dd43f475097fcb98a9462ba4d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a036593dd43f475097fcb98a9462ba4d5">&#9670;&nbsp;</a></span>lexSolve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::lexSolve </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sort of lexicographic resolve. </p>

</div>
</div>
<a id="abacb005c2a1b414e2fa6d024210dbd4b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abacb005c2a1b414e2fa6d024210dbd4b">&#9670;&nbsp;</a></span>getContinuousModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpSimplex.html">ClpSimplex</a>* OsiClpSolverInterface::getContinuousModel </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Get continuous model. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01334">1334</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a3d7f271c7576dcb4f55b8755848d607c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d7f271c7576dcb4f55b8755848d607c">&#9670;&nbsp;</a></span>setContinuousModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterface::setContinuousModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set continuous model. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01339">1339</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Friends And Related Function Documentation</h2>
<a id="a7750ff55db8f06514b1f119b40e66526"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7750ff55db8f06514b1f119b40e66526">&#9670;&nbsp;</a></span>OsiClpSolverInterfaceUnitTest</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void OsiClpSolverInterfaceUnitTest </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>mpsDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>netlibDir</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">friend</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A function that tests the methods in the <a class="el" href="classOsiClpSolverInterface.html" title="Clp Solver Interface.">OsiClpSolverInterface</a> class. </p>

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ab2815665a2a99269e429d5113e60d1cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab2815665a2a99269e429d5113e60d1cb">&#9670;&nbsp;</a></span>modelPtr_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpSimplex.html">ClpSimplex</a>* OsiClpSolverInterface::modelPtr_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clp model represented by this class instance. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01349">1349</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="acbd7966521fde35de32fd8d325032900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acbd7966521fde35de32fd8d325032900">&#9670;&nbsp;</a></span>rowsense_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* OsiClpSolverInterface::rowsense_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to dense vector of row sense indicators. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01354">1354</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a6d6939f2f1abb39d9e3bbddeb7b96ad4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d6939f2f1abb39d9e3bbddeb7b96ad4">&#9670;&nbsp;</a></span>rhs_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* OsiClpSolverInterface::rhs_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to dense vector of row right-hand side values. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01357">1357</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a1cbb647af9581a777f0edce2bc18d453"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1cbb647af9581a777f0edce2bc18d453">&#9670;&nbsp;</a></span>rowrange_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* OsiClpSolverInterface::rowrange_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to dense vector of slack upper bounds for range constraints (undefined for non-range rows) </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01362">1362</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ab0149ee3f0cec228faff142568bca125"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0149ee3f0cec228faff142568bca125">&#9670;&nbsp;</a></span>ws_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoinWarmStartBasis* OsiClpSolverInterface::ws_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A pointer to the warmstart information to be used in the hotstarts. </p>
<p>This is NOT efficient and more thought should be given to it... </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01366">1366</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a27e6212416f58142ed7bbce0f80cde2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27e6212416f58142ed7bbce0f80cde2d">&#9670;&nbsp;</a></span>rowActivity_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* OsiClpSolverInterface::rowActivity_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>also save row and column information for hot starts only used in hotstarts so can be casual </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01369">1369</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="af19b4e53082b8dbcdd2fb70f026ea641"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19b4e53082b8dbcdd2fb70f026ea641">&#9670;&nbsp;</a></span>columnActivity_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* OsiClpSolverInterface::columnActivity_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01370">1370</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a5edc14b61053283117c233b8749e76b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5edc14b61053283117c233b8749e76b8">&#9670;&nbsp;</a></span>stuff_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpNodeStuff.html">ClpNodeStuff</a> OsiClpSolverInterface::stuff_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Stuff for fast dual. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01372">1372</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="aef1648e5f85f60f11fcced9d401fc960"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aef1648e5f85f60f11fcced9d401fc960">&#9670;&nbsp;</a></span>numberSOS_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::numberSOS_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of SOS sets. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01374">1374</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a719c9d7cdc83a46587244d2a0233cbdd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a719c9d7cdc83a46587244d2a0233cbdd">&#9670;&nbsp;</a></span>setInfo_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoinSet* OsiClpSolverInterface::setInfo_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>SOS set info. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01376">1376</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="abd2e756a6e20b2d99d83370c131a1fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abd2e756a6e20b2d99d83370c131a1fa1">&#9670;&nbsp;</a></span>smallModel_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpSimplex.html">ClpSimplex</a>* OsiClpSolverInterface::smallModel_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Alternate model (hot starts) - but also could be permanent and used for crunch. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01378">1378</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a44d477161567beb76d3df7a6aeb347f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44d477161567beb76d3df7a6aeb347f5">&#9670;&nbsp;</a></span>factorization_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpFactorization.html">ClpFactorization</a>* OsiClpSolverInterface::factorization_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>factorization for hot starts </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01380">1380</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ab00234551a5a2d9ac7a11ab55c56f088"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab00234551a5a2d9ac7a11ab55c56f088">&#9670;&nbsp;</a></span>smallestElementInCut_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OsiClpSolverInterface::smallestElementInCut_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Smallest allowed element in cut. </p>
<p>If smaller than this then ignored </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01383">1383</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ab5dabc487fe74aeffb69095ffe3a2327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5dabc487fe74aeffb69095ffe3a2327">&#9670;&nbsp;</a></span>smallestChangeInCut_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OsiClpSolverInterface::smallestChangeInCut_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Smallest change in cut. </p>
<p>If (upper-lower)*element &lt; this then element is taken out and cut relaxed. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01387">1387</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a34ddffd4483663d67dd36a4a5f29498b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34ddffd4483663d67dd36a4a5f29498b">&#9670;&nbsp;</a></span>largestAway_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double OsiClpSolverInterface::largestAway_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Largest amount continuous away from bound. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01389">1389</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a098c433d8c10eb81a1e655f917572958"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a098c433d8c10eb81a1e655f917572958">&#9670;&nbsp;</a></span>spareArrays_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* OsiClpSolverInterface::spareArrays_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Arrays for hot starts. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01391">1391</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ae0f42d8cbdb2af91d92568a5204a1724"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0f42d8cbdb2af91d92568a5204a1724">&#9670;&nbsp;</a></span>basis_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoinWarmStartBasis OsiClpSolverInterface::basis_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Warmstart information to be used in resolves. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01393">1393</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a525c549e0d6fc957c3fd4bde9d1cdb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525c549e0d6fc957c3fd4bde9d1cdb54">&#9670;&nbsp;</a></span>itlimOrig_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::itlimOrig_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The original iteration limit before hotstarts started. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01395">1395</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a0affa03c5dce4d9f954705959423e5fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0affa03c5dce4d9f954705959423e5fc">&#9670;&nbsp;</a></span>lastAlgorithm_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::lastAlgorithm_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Last algorithm used. </p>
<p>Coded as</p><ul>
<li>0 invalid</li>
<li>1 primal</li>
<li>2 dual</li>
<li>-911 disaster in the algorithm that was attempted</li>
<li>999 current solution no longer optimal due to change in problem or basis </li>
</ul>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01407">1407</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a6d5b032db5b28fe0ddbdda082b414ca8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d5b032db5b28fe0ddbdda082b414ca8">&#9670;&nbsp;</a></span>notOwned_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OsiClpSolverInterface::notOwned_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To say if destructor should delete underlying model. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01410">1410</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="afa74566a1c75bb5a807dd5f514e729a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa74566a1c75bb5a807dd5f514e729a1">&#9670;&nbsp;</a></span>matrixByRow_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoinPackedMatrix* OsiClpSolverInterface::matrixByRow_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to row-wise copy of problem matrix coefficients. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01413">1413</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="ab51dc36f5d12341e187a3432ef5eff0f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab51dc36f5d12341e187a3432ef5eff0f">&#9670;&nbsp;</a></span>matrixByRowAtContinuous_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoinPackedMatrix* OsiClpSolverInterface::matrixByRowAtContinuous_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to row-wise copy of continuous problem matrix coefficients. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01416">1416</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="adb69cea32357dec588e7b7d75ff55ce6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb69cea32357dec588e7b7d75ff55ce6">&#9670;&nbsp;</a></span>integerInformation_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">char* OsiClpSolverInterface::integerInformation_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to integer information. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01419">1419</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="aa298fae5fd1f70c8870ceb410454282a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa298fae5fd1f70c8870ceb410454282a">&#9670;&nbsp;</a></span>whichRange_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int* OsiClpSolverInterface::whichRange_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Pointer to variables for which we want range information The number is in [0] memory is not owned by OsiClp. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01425">1425</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="aa012f157eb1df678b34cd7ea00b3cb7a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa012f157eb1df678b34cd7ea00b3cb7a">&#9670;&nbsp;</a></span>fakeMinInSimplex_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool OsiClpSolverInterface::fakeMinInSimplex_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Faking min to get proper dual solution signs in simplex API. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01432">1432</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a0005cf6cbc5263b278fa8a5df86c235b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0005cf6cbc5263b278fa8a5df86c235b">&#9670;&nbsp;</a></span>linearObjective_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* OsiClpSolverInterface::linearObjective_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linear objective. </p>
<p>Normally a pointer to the linear coefficient array in the clp objective. An independent copy when <a class="el" href="classOsiClpSolverInterface.html#aa012f157eb1df678b34cd7ea00b3cb7a" title="Faking min to get proper dual solution signs in simplex API.">fakeMinInSimplex_</a> is true, because we need something permanent to point to when <a class="el" href="classOsiClpSolverInterface.html#ada8df4f17114c968593ab6d98129a9e4" title="Get pointer to array[getNumCols()] of objective function coefficients.">getObjCoefficients</a> is called. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01439">1439</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="acc5a58d87861cf4ed01b52637de09b0e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc5a58d87861cf4ed01b52637de09b0e">&#9670;&nbsp;</a></span>saveData_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpDataSave.html">ClpDataSave</a> OsiClpSolverInterface::saveData_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>To save data in OsiSimplex stuff. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01442">1442</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a76af8a50327a6577eba593133f544f53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76af8a50327a6577eba593133f544f53">&#9670;&nbsp;</a></span>solveOptions_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpSolve.html">ClpSolve</a> OsiClpSolverInterface::solveOptions_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p><a class="el" href="structOptions.html" title="******** DATA to be moved into protected section of ClpInterior">Options</a> for initialSolve. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01444">1444</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="af3d03de970c2dac4b22f4c60fa9e997a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3d03de970c2dac4b22f4c60fa9e997a">&#9670;&nbsp;</a></span>cleanupScaling_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::cleanupScaling_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scaling option When scaling is on it is possible that the scaled problem is feasible but the unscaled is not. </p>
<p>Clp returns a secondary status code to that effect. This option allows for a cleanup. If you use it I would suggest 1. This only affects actions when scaled optimal 0 - no action 1 - clean up using dual if primal infeasibility 2 - clean up using dual if dual infeasibility 3 - clean up using dual if primal or dual infeasibility 11,12,13 - as 1,2,3 but use primal </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01457">1457</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a80902478f92e331fb967ce4ebe323e26"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80902478f92e331fb967ce4ebe323e26">&#9670;&nbsp;</a></span>specialOptions_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int OsiClpSolverInterface::specialOptions_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">mutable</span><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Special options 0x80000000 off 0 simple stuff for branch and bound 1 try and keep work regions as much as possible 2 do not use any perturbation 4 allow exit before re-factorization 8 try and re-use factorization if no cuts 16 use standard strong branching rather than clp's 32 Just go to first factorization in fast dual 64 try and tighten bounds in crunch 128 Model will only change in column bounds 256 Clean up model before hot start 512 Give user direct access to Clp regions in getBInvARow etc (i.e., do not unscale, and do not return result in getBInv parameters; you have to know where to look for the answer) 1024 Don't "borrow" model in initialSolve 2048 Don't crunch 4096 quick check for optimality Bits above 8192 give where called from in Cbc At present 0 is normal, 1 doing fast hotstarts, 2 is can do quick check 65536 Keep simple i.e. </p>
<p>no crunch etc 131072 Try and keep scaling factors around 262144 Don't try and tighten bounds (funny global cuts) 524288 Fake objective and 0-1 1048576 Don't recompute ray after crunch 2097152 8388608 Odd integers e.g. semi-continuous </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01486">1486</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a464f5511e3c6bf4657bc215274098894"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a464f5511e3c6bf4657bc215274098894">&#9670;&nbsp;</a></span>baseModel_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpSimplex.html">ClpSimplex</a>* OsiClpSolverInterface::baseModel_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copy of model when option 131072 set. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01488">1488</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a8f4880eae7802d9edc15c88ddb9e6479"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f4880eae7802d9edc15c88ddb9e6479">&#9670;&nbsp;</a></span>lastNumberRows_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int OsiClpSolverInterface::lastNumberRows_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of rows when last "scaled". </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01490">1490</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a9d0270a116537eabd6b5b3b7d3096c27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d0270a116537eabd6b5b3b7d3096c27">&#9670;&nbsp;</a></span>continuousModel_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpSimplex.html">ClpSimplex</a>* OsiClpSolverInterface::continuousModel_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Continuous model. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01492">1492</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a76e0f4e3ab56e46898b825091405e7df"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76e0f4e3ab56e46898b825091405e7df">&#9670;&nbsp;</a></span>disasterHandler_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classOsiClpDisasterHandler.html">OsiClpDisasterHandler</a>* OsiClpSolverInterface::disasterHandler_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Possible disaster handler. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01494">1494</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a1b468a1a163605fc1c8632b3bd91e4a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b468a1a163605fc1c8632b3bd91e4a5">&#9670;&nbsp;</a></span>fakeObjective_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpLinearObjective.html">ClpLinearObjective</a>* OsiClpSolverInterface::fakeObjective_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fake objective. </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01496">1496</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a082365931cabf500cd78f80713382154"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a082365931cabf500cd78f80713382154">&#9670;&nbsp;</a></span>rowScale_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoinDoubleArrayWithLength OsiClpSolverInterface::rowScale_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Row scale factors (has inverse at end) </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01498">1498</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<a id="a9c0010566bad50980b7f7fc7386a7c6f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c0010566bad50980b7f7fc7386a7c6f">&#9670;&nbsp;</a></span>columnScale_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">CoinDoubleArrayWithLength OsiClpSolverInterface::columnScale_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Column scale factors (has inverse at end) </p>

<p class="definition">Definition at line <a class="el" href="OsiClpSolverInterface_8hpp_source.html#l01500">1500</a> of file <a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/ted/tmp/tmp/Clp/Clp/src/OsiClp/<a class="el" href="OsiClpSolverInterface_8hpp_source.html">OsiClpSolverInterface.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
