<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Clp: ClpMatrixBase Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Clp
   &#160;<span id="projectnumber">1.17.9</span>
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="classClpMatrixBase-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">ClpMatrixBase Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>Abstract base class for Clp Matrices.  
 <a href="classClpMatrixBase.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>&gt;</code></p>
<div id="dynsection-0" onclick="return toggleVisibility(this)" class="dynheader closed" style="cursor:pointer;">
  <img id="dynsection-0-trigger" src="closed.png" alt="+"/> Inheritance diagram for ClpMatrixBase:</div>
<div id="dynsection-0-summary" class="dynsummary" style="display:block;">
</div>
<div id="dynsection-0-content" class="dyncontent" style="display:none;">
<div class="center"><img src="classClpMatrixBase__inherit__graph.png" border="0" usemap="#ClpMatrixBase_inherit__map" alt="Inheritance graph"/></div>
<map name="ClpMatrixBase_inherit__map" id="ClpMatrixBase_inherit__map">
<area shape="rect" title="Abstract base class for Clp Matrices." alt="" coords="232,5,339,32"/>
<area shape="rect" href="classClpDummyMatrix.html" title="This implements a dummy matrix as derived from ClpMatrixBase." alt="" coords="5,80,125,107"/>
<area shape="rect" href="classClpNetworkMatrix.html" title="This implements a simple network matrix as derived from ClpMatrixBase." alt="" coords="149,80,275,107"/>
<area shape="rect" href="classClpPackedMatrix.html" title=" " alt="" coords="299,80,419,107"/>
<area shape="rect" href="classClpPlusMinusOneMatrix.html" title="This implements a simple +&#45; one matrix as derived from ClpMatrixBase." alt="" coords="443,80,605,107"/>
<area shape="rect" href="classClpDynamicMatrix.html" title="This implements a dynamic matrix when we have a limit on the number of &quot;interesting rows&quot;." alt="" coords="221,155,347,181"/>
<area shape="rect" href="classClpGubMatrix.html" title="This implements Gub rows plus a ClpPackedMatrix." alt="" coords="383,155,483,181"/>
<area shape="rect" href="classClpDynamicExampleMatrix.html" title="This implements a dynamic matrix when we have a limit on the number of &quot;interesting rows&quot;." alt="" coords="173,229,347,256"/>
<area shape="rect" href="classClpGubDynamicMatrix.html" title="This implements Gub rows plus a ClpPackedMatrix." alt="" coords="371,229,522,256"/>
</map>
<center><span class="legend">[<a href="graph_legend.html">legend</a>]</span></center></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Virtual methods that the derived classes must provide</div></td></tr>
<tr class="memitem:a7eb12e49df620c3edbc0e81bb66ea450"><td class="memItemLeft" align="right" valign="top">virtual CoinPackedMatrix *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a7eb12e49df620c3edbc0e81bb66ea450">getPackedMatrix</a> () const =0</td></tr>
<tr class="memdesc:a7eb12e49df620c3edbc0e81bb66ea450"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a complete CoinPackedMatrix.  <a href="classClpMatrixBase.html#a7eb12e49df620c3edbc0e81bb66ea450">More...</a><br /></td></tr>
<tr class="separator:a7eb12e49df620c3edbc0e81bb66ea450"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a088831eed7341859efc7a1b5b7232008"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a088831eed7341859efc7a1b5b7232008">isColOrdered</a> () const =0</td></tr>
<tr class="memdesc:a088831eed7341859efc7a1b5b7232008"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the packed matrix is column major ordered or not.  <a href="classClpMatrixBase.html#a088831eed7341859efc7a1b5b7232008">More...</a><br /></td></tr>
<tr class="separator:a088831eed7341859efc7a1b5b7232008"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adefaf54f23059c4b1047969659fdffbb"><td class="memItemLeft" align="right" valign="top">virtual CoinBigIndex&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#adefaf54f23059c4b1047969659fdffbb">getNumElements</a> () const =0</td></tr>
<tr class="memdesc:adefaf54f23059c4b1047969659fdffbb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of entries in the packed matrix.  <a href="classClpMatrixBase.html#adefaf54f23059c4b1047969659fdffbb">More...</a><br /></td></tr>
<tr class="separator:adefaf54f23059c4b1047969659fdffbb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a589d4c8e29abb80e291e6cfd118b4b0c"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a589d4c8e29abb80e291e6cfd118b4b0c">getNumCols</a> () const =0</td></tr>
<tr class="memdesc:a589d4c8e29abb80e291e6cfd118b4b0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of columns.  <a href="classClpMatrixBase.html#a589d4c8e29abb80e291e6cfd118b4b0c">More...</a><br /></td></tr>
<tr class="separator:a589d4c8e29abb80e291e6cfd118b4b0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a762b6a8bb910b9eb96302b5b0f488ca9"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a762b6a8bb910b9eb96302b5b0f488ca9">getNumRows</a> () const =0</td></tr>
<tr class="memdesc:a762b6a8bb910b9eb96302b5b0f488ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Number of rows.  <a href="classClpMatrixBase.html#a762b6a8bb910b9eb96302b5b0f488ca9">More...</a><br /></td></tr>
<tr class="separator:a762b6a8bb910b9eb96302b5b0f488ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ba58cedc63a044d5bbd6c4ec18455e3"><td class="memItemLeft" align="right" valign="top">virtual const double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a5ba58cedc63a044d5bbd6c4ec18455e3">getElements</a> () const =0</td></tr>
<tr class="memdesc:a5ba58cedc63a044d5bbd6c4ec18455e3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing the elements in the packed matrix.  <a href="classClpMatrixBase.html#a5ba58cedc63a044d5bbd6c4ec18455e3">More...</a><br /></td></tr>
<tr class="separator:a5ba58cedc63a044d5bbd6c4ec18455e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e1b52ec1ec8c783e9cf23296bcafbc3"><td class="memItemLeft" align="right" valign="top">virtual const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a3e1b52ec1ec8c783e9cf23296bcafbc3">getIndices</a> () const =0</td></tr>
<tr class="memdesc:a3e1b52ec1ec8c783e9cf23296bcafbc3"><td class="mdescLeft">&#160;</td><td class="mdescRight">A vector containing the minor indices of the elements in the packed matrix.  <a href="classClpMatrixBase.html#a3e1b52ec1ec8c783e9cf23296bcafbc3">More...</a><br /></td></tr>
<tr class="separator:a3e1b52ec1ec8c783e9cf23296bcafbc3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7f3fa1d27854d956a0bc0066d3ec14f"><td class="memItemLeft" align="right" valign="top">virtual const CoinBigIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ac7f3fa1d27854d956a0bc0066d3ec14f">getVectorStarts</a> () const =0</td></tr>
<tr class="separator:ac7f3fa1d27854d956a0bc0066d3ec14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a226ded31086afc0d1389983c5f4b80ba"><td class="memItemLeft" align="right" valign="top">virtual const int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a226ded31086afc0d1389983c5f4b80ba">getVectorLengths</a> () const =0</td></tr>
<tr class="memdesc:a226ded31086afc0d1389983c5f4b80ba"><td class="mdescLeft">&#160;</td><td class="mdescRight">The lengths of the major-dimension vectors.  <a href="classClpMatrixBase.html#a226ded31086afc0d1389983c5f4b80ba">More...</a><br /></td></tr>
<tr class="separator:a226ded31086afc0d1389983c5f4b80ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb0f30bce468c4b831c3cee13eb166be"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#aeb0f30bce468c4b831c3cee13eb166be">getVectorLength</a> (int index) const</td></tr>
<tr class="memdesc:aeb0f30bce468c4b831c3cee13eb166be"><td class="mdescLeft">&#160;</td><td class="mdescRight">The length of a single major-dimension vector.  <a href="classClpMatrixBase.html#aeb0f30bce468c4b831c3cee13eb166be">More...</a><br /></td></tr>
<tr class="separator:aeb0f30bce468c4b831c3cee13eb166be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd825f0c98597cc0459c70e6829be68e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#afd825f0c98597cc0459c70e6829be68e">deleteCols</a> (const int numDel, const int *indDel)=0</td></tr>
<tr class="memdesc:afd825f0c98597cc0459c70e6829be68e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the columns whose indices are listed in <code>indDel</code>.  <a href="classClpMatrixBase.html#afd825f0c98597cc0459c70e6829be68e">More...</a><br /></td></tr>
<tr class="separator:afd825f0c98597cc0459c70e6829be68e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f4918af64f9fdcba6e56b18bf970bf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ac1f4918af64f9fdcba6e56b18bf970bf">deleteRows</a> (const int numDel, const int *indDel)=0</td></tr>
<tr class="memdesc:ac1f4918af64f9fdcba6e56b18bf970bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the rows whose indices are listed in <code>indDel</code>.  <a href="classClpMatrixBase.html#ac1f4918af64f9fdcba6e56b18bf970bf">More...</a><br /></td></tr>
<tr class="separator:ac1f4918af64f9fdcba6e56b18bf970bf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aa6b15024e1990fa3e15ac6375aaaa7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a3aa6b15024e1990fa3e15ac6375aaaa7">appendCols</a> (int number, const CoinPackedVectorBase *const *columns)</td></tr>
<tr class="memdesc:a3aa6b15024e1990fa3e15ac6375aaaa7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append Columns.  <a href="classClpMatrixBase.html#a3aa6b15024e1990fa3e15ac6375aaaa7">More...</a><br /></td></tr>
<tr class="separator:a3aa6b15024e1990fa3e15ac6375aaaa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adfa8e1f58108d4dc00e90a7a3261de"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a9adfa8e1f58108d4dc00e90a7a3261de">appendRows</a> (int number, const CoinPackedVectorBase *const *rows)</td></tr>
<tr class="memdesc:a9adfa8e1f58108d4dc00e90a7a3261de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append Rows.  <a href="classClpMatrixBase.html#a9adfa8e1f58108d4dc00e90a7a3261de">More...</a><br /></td></tr>
<tr class="separator:a9adfa8e1f58108d4dc00e90a7a3261de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a921edfc0f79f20c2a078ec45c1d62d61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a921edfc0f79f20c2a078ec45c1d62d61">modifyCoefficient</a> (int row, int column, double newElement, bool keepZero=false)</td></tr>
<tr class="memdesc:a921edfc0f79f20c2a078ec45c1d62d61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Modify one element of packed matrix.  <a href="classClpMatrixBase.html#a921edfc0f79f20c2a078ec45c1d62d61">More...</a><br /></td></tr>
<tr class="separator:a921edfc0f79f20c2a078ec45c1d62d61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adac73d7a2257c7165a18603f82333dae"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#adac73d7a2257c7165a18603f82333dae">appendMatrix</a> (int number, int <a class="el" href="classClpMatrixBase.html#a882fc3dd899de5f6417250abcb883155">type</a>, const CoinBigIndex *starts, const int *index, const double *element, int numberOther=-1)</td></tr>
<tr class="memdesc:adac73d7a2257c7165a18603f82333dae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Append a set of rows/columns to the end of the matrix.  <a href="classClpMatrixBase.html#adac73d7a2257c7165a18603f82333dae">More...</a><br /></td></tr>
<tr class="separator:adac73d7a2257c7165a18603f82333dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4fd0acbb7032cbe7bcdffb499a853b22"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a4fd0acbb7032cbe7bcdffb499a853b22">reverseOrderedCopy</a> () const</td></tr>
<tr class="memdesc:a4fd0acbb7032cbe7bcdffb499a853b22"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new matrix in reverse order without gaps Is allowed to return NULL if doesn't want to have row copy.  <a href="classClpMatrixBase.html#a4fd0acbb7032cbe7bcdffb499a853b22">More...</a><br /></td></tr>
<tr class="separator:a4fd0acbb7032cbe7bcdffb499a853b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8f18b4e3356e5de8073a323cf3776134"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a8f18b4e3356e5de8073a323cf3776134">countBasis</a> (const int *whichColumn, int &amp;numberColumnBasic)=0</td></tr>
<tr class="memdesc:a8f18b4e3356e5de8073a323cf3776134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of elements in column part of basis.  <a href="classClpMatrixBase.html#a8f18b4e3356e5de8073a323cf3776134">More...</a><br /></td></tr>
<tr class="separator:a8f18b4e3356e5de8073a323cf3776134"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8fea2736f9300450312781406183553b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a8fea2736f9300450312781406183553b">fillBasis</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, const int *whichColumn, int &amp;numberColumnBasic, int *row, int *start, int *rowCount, int *columnCount, CoinFactorizationDouble *element)=0</td></tr>
<tr class="memdesc:a8fea2736f9300450312781406183553b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fills in column part of basis.  <a href="classClpMatrixBase.html#a8fea2736f9300450312781406183553b">More...</a><br /></td></tr>
<tr class="separator:a8fea2736f9300450312781406183553b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa642b94e1b87dd39d8d05f2b4626948a"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#aa642b94e1b87dd39d8d05f2b4626948a">scale</a> (<a class="el" href="classClpModel.html">ClpModel</a> *, <a class="el" href="classClpSimplex.html">ClpSimplex</a> *=NULL) const</td></tr>
<tr class="memdesc:aa642b94e1b87dd39d8d05f2b4626948a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates scales for column copy (rowCopy in model may be modified) default does not allow scaling returns non-zero if no scaling done.  <a href="classClpMatrixBase.html#aa642b94e1b87dd39d8d05f2b4626948a">More...</a><br /></td></tr>
<tr class="separator:aa642b94e1b87dd39d8d05f2b4626948a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1ee6860654999be9f976a7479a54b85"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ac1ee6860654999be9f976a7479a54b85">scaleRowCopy</a> (<a class="el" href="classClpModel.html">ClpModel</a> *) const</td></tr>
<tr class="memdesc:ac1ee6860654999be9f976a7479a54b85"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales rowCopy if column copy scaled Only called if scales already exist.  <a href="classClpMatrixBase.html#ac1ee6860654999be9f976a7479a54b85">More...</a><br /></td></tr>
<tr class="separator:ac1ee6860654999be9f976a7479a54b85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebb58a256204dae8daa152c845ac0d82"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#aebb58a256204dae8daa152c845ac0d82">canGetRowCopy</a> () const</td></tr>
<tr class="memdesc:aebb58a256204dae8daa152c845ac0d82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if can create row copy.  <a href="classClpMatrixBase.html#aebb58a256204dae8daa152c845ac0d82">More...</a><br /></td></tr>
<tr class="separator:aebb58a256204dae8daa152c845ac0d82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb17da47c2626ed35eba6934279792b6"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#afb17da47c2626ed35eba6934279792b6">scaledColumnCopy</a> (<a class="el" href="classClpModel.html">ClpModel</a> *) const</td></tr>
<tr class="memdesc:afb17da47c2626ed35eba6934279792b6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Realy really scales column copy Only called if scales already exist.  <a href="classClpMatrixBase.html#afb17da47c2626ed35eba6934279792b6">More...</a><br /></td></tr>
<tr class="separator:afb17da47c2626ed35eba6934279792b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a670d63d24534a4b48549aacad12efafb"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a670d63d24534a4b48549aacad12efafb">allElementsInRange</a> (<a class="el" href="classClpModel.html">ClpModel</a> *, double, double, int=15)</td></tr>
<tr class="memdesc:a670d63d24534a4b48549aacad12efafb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if all elements are in valid range.  <a href="classClpMatrixBase.html#a670d63d24534a4b48549aacad12efafb">More...</a><br /></td></tr>
<tr class="separator:a670d63d24534a4b48549aacad12efafb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12715a2bf3b3b396d08d2f0ed5adffde"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a12715a2bf3b3b396d08d2f0ed5adffde">setDimensions</a> (int numrows, int numcols)</td></tr>
<tr class="memdesc:a12715a2bf3b3b396d08d2f0ed5adffde"><td class="mdescLeft">&#160;</td><td class="mdescRight">Set the dimensions of the matrix.  <a href="classClpMatrixBase.html#a12715a2bf3b3b396d08d2f0ed5adffde">More...</a><br /></td></tr>
<tr class="separator:a12715a2bf3b3b396d08d2f0ed5adffde"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1eb6fa2da292f5348652cf606b0f483"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ab1eb6fa2da292f5348652cf606b0f483">rangeOfElements</a> (double &amp;smallestNegative, double &amp;largestNegative, double &amp;smallestPositive, double &amp;largestPositive)</td></tr>
<tr class="memdesc:ab1eb6fa2da292f5348652cf606b0f483"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns largest and smallest elements of both signs.  <a href="classClpMatrixBase.html#ab1eb6fa2da292f5348652cf606b0f483">More...</a><br /></td></tr>
<tr class="separator:ab1eb6fa2da292f5348652cf606b0f483"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e8af7fd83f0ed81c72e76c9f3d388b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a65e8af7fd83f0ed81c72e76c9f3d388b">unpack</a> (const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, CoinIndexedVector *rowArray, int column) const =0</td></tr>
<tr class="memdesc:a65e8af7fd83f0ed81c72e76c9f3d388b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks a column into an CoinIndexedvector.  <a href="classClpMatrixBase.html#a65e8af7fd83f0ed81c72e76c9f3d388b">More...</a><br /></td></tr>
<tr class="separator:a65e8af7fd83f0ed81c72e76c9f3d388b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01442004ddef377732f6b32425356298"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a01442004ddef377732f6b32425356298">unpackPacked</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, CoinIndexedVector *rowArray, int column) const =0</td></tr>
<tr class="memdesc:a01442004ddef377732f6b32425356298"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unpacks a column into an CoinIndexedvector in packed format Note that model is NOT const.  <a href="classClpMatrixBase.html#a01442004ddef377732f6b32425356298">More...</a><br /></td></tr>
<tr class="separator:a01442004ddef377732f6b32425356298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab37aacdf7f1c6aca7afc69877294d003"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ab37aacdf7f1c6aca7afc69877294d003">refresh</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *)</td></tr>
<tr class="memdesc:ab37aacdf7f1c6aca7afc69877294d003"><td class="mdescLeft">&#160;</td><td class="mdescRight">Purely for column generation and similar ideas.  <a href="classClpMatrixBase.html#ab37aacdf7f1c6aca7afc69877294d003">More...</a><br /></td></tr>
<tr class="separator:ab37aacdf7f1c6aca7afc69877294d003"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42532c012ff3cacfcb64c90b765a0ea"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#aa42532c012ff3cacfcb64c90b765a0ea">reallyScale</a> (const double *rowScale, const double *columnScale)</td></tr>
<tr class="separator:aa42532c012ff3cacfcb64c90b765a0ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad17e36bc57e5c87be420c42afd736b6e"><td class="memItemLeft" align="right" valign="top">virtual CoinBigIndex *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ad17e36bc57e5c87be420c42afd736b6e">dubiousWeights</a> (const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, int *inputWeights) const</td></tr>
<tr class="memdesc:ad17e36bc57e5c87be420c42afd736b6e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Given positive integer weights for each row fills in sum of weights for each column (and slack).  <a href="classClpMatrixBase.html#ad17e36bc57e5c87be420c42afd736b6e">More...</a><br /></td></tr>
<tr class="separator:ad17e36bc57e5c87be420c42afd736b6e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a36b91b9af6d91e4aca5528c0f1c284e7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a36b91b9af6d91e4aca5528c0f1c284e7">add</a> (const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, CoinIndexedVector *rowArray, int column, double multiplier) const =0</td></tr>
<tr class="memdesc:a36b91b9af6d91e4aca5528c0f1c284e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple of a column into an CoinIndexedvector You can use quickAdd to add to vector.  <a href="classClpMatrixBase.html#a36b91b9af6d91e4aca5528c0f1c284e7">More...</a><br /></td></tr>
<tr class="separator:a36b91b9af6d91e4aca5528c0f1c284e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a49acfbbd5efc8208f475a5f2caa81ccd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a49acfbbd5efc8208f475a5f2caa81ccd">add</a> (const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, double *array, int column, double multiplier) const =0</td></tr>
<tr class="memdesc:a49acfbbd5efc8208f475a5f2caa81ccd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds multiple of a column into an array.  <a href="classClpMatrixBase.html#a49acfbbd5efc8208f475a5f2caa81ccd">More...</a><br /></td></tr>
<tr class="separator:a49acfbbd5efc8208f475a5f2caa81ccd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a132916066c3165524e1474d1086206c6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a132916066c3165524e1474d1086206c6">releasePackedMatrix</a> () const =0</td></tr>
<tr class="memdesc:a132916066c3165524e1474d1086206c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allow any parts of a created CoinPackedMatrix to be deleted.  <a href="classClpMatrixBase.html#a132916066c3165524e1474d1086206c6">More...</a><br /></td></tr>
<tr class="separator:a132916066c3165524e1474d1086206c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8e321fc1cde2d3448f797f181449eaa2"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a8e321fc1cde2d3448f797f181449eaa2">canDoPartialPricing</a> () const</td></tr>
<tr class="memdesc:a8e321fc1cde2d3448f797f181449eaa2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Says whether it can do partial pricing.  <a href="classClpMatrixBase.html#a8e321fc1cde2d3448f797f181449eaa2">More...</a><br /></td></tr>
<tr class="separator:a8e321fc1cde2d3448f797f181449eaa2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af80ee9c5d03dec8609367e341a0688ce"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#af80ee9c5d03dec8609367e341a0688ce">hiddenRows</a> () const</td></tr>
<tr class="memdesc:af80ee9c5d03dec8609367e341a0688ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns number of hidden rows e.g. gub.  <a href="classClpMatrixBase.html#af80ee9c5d03dec8609367e341a0688ce">More...</a><br /></td></tr>
<tr class="separator:af80ee9c5d03dec8609367e341a0688ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1b6600d9d699aaad77e4b91f4381e9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#aec1b6600d9d699aaad77e4b91f4381e9">partialPricing</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, double start, double end, int &amp;bestSequence, int &amp;numberWanted)</td></tr>
<tr class="memdesc:aec1b6600d9d699aaad77e4b91f4381e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial pricing.  <a href="classClpMatrixBase.html#aec1b6600d9d699aaad77e4b91f4381e9">More...</a><br /></td></tr>
<tr class="separator:aec1b6600d9d699aaad77e4b91f4381e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e54515ed3d102523a82ad35bda7a13e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a9e54515ed3d102523a82ad35bda7a13e">extendUpdated</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, CoinIndexedVector *update, int mode)</td></tr>
<tr class="memdesc:a9e54515ed3d102523a82ad35bda7a13e"><td class="mdescLeft">&#160;</td><td class="mdescRight">expands an updated column to allow for extra rows which the main solver does not know about and returns number added.  <a href="classClpMatrixBase.html#a9e54515ed3d102523a82ad35bda7a13e">More...</a><br /></td></tr>
<tr class="separator:a9e54515ed3d102523a82ad35bda7a13e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5101be2165e62f9447cbd931ff25ebce"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a5101be2165e62f9447cbd931ff25ebce">primalExpanded</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, int mode)</td></tr>
<tr class="memdesc:a5101be2165e62f9447cbd931ff25ebce"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility primal function for dealing with dynamic constraints mode=0 - Set up before "update" and "times" for primal solution using extended rows mode=1 - Cleanup primal solution after "times" using extended rows.  <a href="classClpMatrixBase.html#a5101be2165e62f9447cbd931ff25ebce">More...</a><br /></td></tr>
<tr class="separator:a5101be2165e62f9447cbd931ff25ebce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60dee2f2426217242ed3b97cac07d55c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a60dee2f2426217242ed3b97cac07d55c">dualExpanded</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, CoinIndexedVector *array, double *other, int mode)</td></tr>
<tr class="memdesc:a60dee2f2426217242ed3b97cac07d55c"><td class="mdescLeft">&#160;</td><td class="mdescRight">utility dual function for dealing with dynamic constraints mode=0 - Set up before "updateTranspose" and "transposeTimes" for duals using extended updates array (and may use other if dual values pass) mode=1 - Update dual solution after "transposeTimes" using extended rows.  <a href="classClpMatrixBase.html#a60dee2f2426217242ed3b97cac07d55c">More...</a><br /></td></tr>
<tr class="separator:a60dee2f2426217242ed3b97cac07d55c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a527d06d4823ce1398bb19046ccd23822"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a527d06d4823ce1398bb19046ccd23822">generalExpanded</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, int mode, int &amp;number)</td></tr>
<tr class="memdesc:a527d06d4823ce1398bb19046ccd23822"><td class="mdescLeft">&#160;</td><td class="mdescRight">general utility function for dealing with dynamic constraints mode=0 - Create list of non-key basics in pivotVariable_ using number as numberBasic in and out mode=1 - Set all key variables as basic mode=2 - return number extra rows needed, number gives maximum number basic mode=3 - before replaceColumn mode=4 - return 1 if can do primal, 2 if dual, 3 if both mode=5 - save any status stuff (when in good state) mode=6 - restore status stuff mode=7 - flag given variable (normally sequenceIn) mode=8 - unflag all variables mode=9 - synchronize costs and bounds mode=10 - return 1 if there may be changing bounds on variable (column generation) mode=11 - make sure set is clean (used when a variable rejected - but not flagged) mode=12 - after factorize but before permute stuff mode=13 - at end of simplex to delete stuff  <a href="classClpMatrixBase.html#a527d06d4823ce1398bb19046ccd23822">More...</a><br /></td></tr>
<tr class="separator:a527d06d4823ce1398bb19046ccd23822"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74941ea6a6cf2b1a52b3d918eee011c6"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a74941ea6a6cf2b1a52b3d918eee011c6">updatePivot</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, double oldInValue, double oldOutValue)</td></tr>
<tr class="memdesc:a74941ea6a6cf2b1a52b3d918eee011c6"><td class="mdescLeft">&#160;</td><td class="mdescRight">update information for a pivot (and effective rhs)  <a href="classClpMatrixBase.html#a74941ea6a6cf2b1a52b3d918eee011c6">More...</a><br /></td></tr>
<tr class="separator:a74941ea6a6cf2b1a52b3d918eee011c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f551cbf44dec95ec7b51259c5c5378"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#aa4f551cbf44dec95ec7b51259c5c5378">createVariable</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, int &amp;bestSequence)</td></tr>
<tr class="memdesc:aa4f551cbf44dec95ec7b51259c5c5378"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a variable.  <a href="classClpMatrixBase.html#aa4f551cbf44dec95ec7b51259c5c5378">More...</a><br /></td></tr>
<tr class="separator:aa4f551cbf44dec95ec7b51259c5c5378"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a263f5d27095dbe19dd0c03511d520d8e"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a263f5d27095dbe19dd0c03511d520d8e">checkFeasible</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, double &amp;sum) const</td></tr>
<tr class="memdesc:a263f5d27095dbe19dd0c03511d520d8e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just for debug if odd type matrix.  <a href="classClpMatrixBase.html#a263f5d27095dbe19dd0c03511d520d8e">More...</a><br /></td></tr>
<tr class="separator:a263f5d27095dbe19dd0c03511d520d8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7882fb623bfd78359caa738a09bdbb31"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a7882fb623bfd78359caa738a09bdbb31">reducedCost</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, int sequence) const</td></tr>
<tr class="memdesc:a7882fb623bfd78359caa738a09bdbb31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns reduced cost of a variable.  <a href="classClpMatrixBase.html#a7882fb623bfd78359caa738a09bdbb31">More...</a><br /></td></tr>
<tr class="separator:a7882fb623bfd78359caa738a09bdbb31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5990595a7cf495607a5364d034c8b2a9"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a5990595a7cf495607a5364d034c8b2a9">correctSequence</a> (const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, int &amp;sequenceIn, int &amp;sequenceOut)</td></tr>
<tr class="memdesc:a5990595a7cf495607a5364d034c8b2a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Correct sequence in and out to give true value (if both -1 maybe do whole matrix)  <a href="classClpMatrixBase.html#a5990595a7cf495607a5364d034c8b2a9">More...</a><br /></td></tr>
<tr class="separator:a5990595a7cf495607a5364d034c8b2a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrix times vector methods</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>They can be faster if scalar is +- 1 Also for simplex I am not using basic/non-basic split </p>
</div></td></tr>
<tr class="memitem:ac709438afef7f211fcc46744669a22ac"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ac709438afef7f211fcc46744669a22ac">times</a> (double scalar, const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> x, double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> y) const =0</td></tr>
<tr class="memdesc:ac709438afef7f211fcc46744669a22ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>y + A * x * scalar</code> in <code>y</code>.  <a href="classClpMatrixBase.html#ac709438afef7f211fcc46744669a22ac">More...</a><br /></td></tr>
<tr class="separator:ac709438afef7f211fcc46744669a22ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d6870bbc8efb55b994367a1c4c42df6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a5d6870bbc8efb55b994367a1c4c42df6">times</a> (double scalar, const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> x, double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> y, const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> rowScale, const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> columnScale) const</td></tr>
<tr class="memdesc:a5d6870bbc8efb55b994367a1c4c42df6"><td class="mdescLeft">&#160;</td><td class="mdescRight">And for scaling - default aborts for when scaling not supported (unless pointers NULL when as normal)  <a href="classClpMatrixBase.html#a5d6870bbc8efb55b994367a1c4c42df6">More...</a><br /></td></tr>
<tr class="separator:a5d6870bbc8efb55b994367a1c4c42df6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80aa6ee57b76db2cc4fefb7d310e6dad"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a80aa6ee57b76db2cc4fefb7d310e6dad">transposeTimes</a> (double scalar, const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> x, double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> y) const =0</td></tr>
<tr class="memdesc:a80aa6ee57b76db2cc4fefb7d310e6dad"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>y + x * scalar * A</code> in <code>y</code>.  <a href="classClpMatrixBase.html#a80aa6ee57b76db2cc4fefb7d310e6dad">More...</a><br /></td></tr>
<tr class="separator:a80aa6ee57b76db2cc4fefb7d310e6dad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b53ead42b8a5b948c1045a9a11717c2"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a0b53ead42b8a5b948c1045a9a11717c2">transposeTimes</a> (double scalar, const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> x, double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> y, const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> rowScale, const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> columnScale, double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a> spare=NULL) const</td></tr>
<tr class="memdesc:a0b53ead42b8a5b948c1045a9a11717c2"><td class="mdescLeft">&#160;</td><td class="mdescRight">And for scaling - default aborts for when scaling not supported (unless pointers NULL when as normal)  <a href="classClpMatrixBase.html#a0b53ead42b8a5b948c1045a9a11717c2">More...</a><br /></td></tr>
<tr class="separator:a0b53ead42b8a5b948c1045a9a11717c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1cb53d592110044b21e74b3c37c0c12"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ab1cb53d592110044b21e74b3c37c0c12">transposeTimes</a> (const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, double scalar, const CoinIndexedVector *x, CoinIndexedVector *y, CoinIndexedVector *z) const =0</td></tr>
<tr class="memdesc:ab1cb53d592110044b21e74b3c37c0c12"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>x * scalar *A + y</code> in <code>z</code>.  <a href="classClpMatrixBase.html#ab1cb53d592110044b21e74b3c37c0c12">More...</a><br /></td></tr>
<tr class="separator:ab1cb53d592110044b21e74b3c37c0c12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeda91d80ef5603113ec55bbcdfcf9f34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#aeda91d80ef5603113ec55bbcdfcf9f34">subsetTransposeTimes</a> (const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, const CoinIndexedVector *x, const CoinIndexedVector *y, CoinIndexedVector *z) const =0</td></tr>
<tr class="memdesc:aeda91d80ef5603113ec55bbcdfcf9f34"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>x *A</code> in <code>z</code> but just for indices in y.  <a href="classClpMatrixBase.html#aeda91d80ef5603113ec55bbcdfcf9f34">More...</a><br /></td></tr>
<tr class="separator:aeda91d80ef5603113ec55bbcdfcf9f34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace0dfda734fcca7928bcd71413d019e8"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ace0dfda734fcca7928bcd71413d019e8">canCombine</a> (const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *, const CoinIndexedVector *) const</td></tr>
<tr class="memdesc:ace0dfda734fcca7928bcd71413d019e8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns true if can combine transposeTimes and subsetTransposeTimes and if it would be faster.  <a href="classClpMatrixBase.html#ace0dfda734fcca7928bcd71413d019e8">More...</a><br /></td></tr>
<tr class="separator:ace0dfda734fcca7928bcd71413d019e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab8e72f5bbb3396d4f0d7ebb2b58a978"><td class="memItemLeft" align="right" valign="top">virtual int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#aab8e72f5bbb3396d4f0d7ebb2b58a978">transposeTimes2</a> (const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, const CoinIndexedVector *pi1, CoinIndexedVector *dj1, const CoinIndexedVector *pi2, CoinIndexedVector *spare, double *infeas, double *<a class="el" href="classClpMatrixBase.html#a7882fb623bfd78359caa738a09bdbb31">reducedCost</a>, double referenceIn, double devex, unsigned int *reference, double *weights, double scaleFactor)</td></tr>
<tr class="memdesc:aab8e72f5bbb3396d4f0d7ebb2b58a978"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates two arrays for steepest and does devex weights (need not be coded) Returns nonzero if updates reduced cost and infeas - new infeas in dj1.  <a href="classClpMatrixBase.html#aab8e72f5bbb3396d4f0d7ebb2b58a978">More...</a><br /></td></tr>
<tr class="separator:aab8e72f5bbb3396d4f0d7ebb2b58a978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a866128fea0f5138de3fc51cce99f4d31"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a866128fea0f5138de3fc51cce99f4d31">subsetTimes2</a> (const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, CoinIndexedVector *dj1, const CoinIndexedVector *pi2, CoinIndexedVector *dj2, double referenceIn, double devex, unsigned int *reference, double *weights, double scaleFactor)</td></tr>
<tr class="memdesc:a866128fea0f5138de3fc51cce99f4d31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Updates second array for steepest and does devex weights (need not be coded)  <a href="classClpMatrixBase.html#a866128fea0f5138de3fc51cce99f4d31">More...</a><br /></td></tr>
<tr class="separator:a866128fea0f5138de3fc51cce99f4d31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7e53a81ffc47976ef9cdb3547ef575a5"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a7e53a81ffc47976ef9cdb3547ef575a5">listTransposeTimes</a> (const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, double *x, int *y, int number, double *z) const</td></tr>
<tr class="memdesc:a7e53a81ffc47976ef9cdb3547ef575a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return <code>x *A</code> in <code>z</code> but just for number indices in y.  <a href="classClpMatrixBase.html#a7e53a81ffc47976ef9cdb3547ef575a5">More...</a><br /></td></tr>
<tr class="separator:a7e53a81ffc47976ef9cdb3547ef575a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Other</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>Clone </p>
</div></td></tr>
<tr class="memitem:ae5a41e96610958bc8d4a08d889ecf7a3"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ae5a41e96610958bc8d4a08d889ecf7a3">clone</a> () const =0</td></tr>
<tr class="separator:ae5a41e96610958bc8d4a08d889ecf7a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5a0e1e9011be8ebcfb4ab4761342d95f"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a5a0e1e9011be8ebcfb4ab4761342d95f">subsetClone</a> (int numberRows, const int *whichRows, int numberColumns, const int *whichColumns) const</td></tr>
<tr class="memdesc:a5a0e1e9011be8ebcfb4ab4761342d95f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Subset clone (without gaps).  <a href="classClpMatrixBase.html#a5a0e1e9011be8ebcfb4ab4761342d95f">More...</a><br /></td></tr>
<tr class="separator:a5a0e1e9011be8ebcfb4ab4761342d95f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4390c386ae11d2b412645ab8ae15e589"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a4390c386ae11d2b412645ab8ae15e589">backToBasics</a> ()</td></tr>
<tr class="memdesc:a4390c386ae11d2b412645ab8ae15e589"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets rid of any mutable by products.  <a href="classClpMatrixBase.html#a4390c386ae11d2b412645ab8ae15e589">More...</a><br /></td></tr>
<tr class="separator:a4390c386ae11d2b412645ab8ae15e589"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a882fc3dd899de5f6417250abcb883155"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a882fc3dd899de5f6417250abcb883155">type</a> () const</td></tr>
<tr class="memdesc:a882fc3dd899de5f6417250abcb883155"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns type.  <a href="classClpMatrixBase.html#a882fc3dd899de5f6417250abcb883155">More...</a><br /></td></tr>
<tr class="separator:a882fc3dd899de5f6417250abcb883155"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac46dc89dd1d994a15df49eadd57cf1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a7ac46dc89dd1d994a15df49eadd57cf1">setType</a> (int newtype)</td></tr>
<tr class="memdesc:a7ac46dc89dd1d994a15df49eadd57cf1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets type.  <a href="classClpMatrixBase.html#a7ac46dc89dd1d994a15df49eadd57cf1">More...</a><br /></td></tr>
<tr class="separator:a7ac46dc89dd1d994a15df49eadd57cf1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e419cd897e42ceca91c3f7922ead777"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a9e419cd897e42ceca91c3f7922ead777">useEffectiveRhs</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model)</td></tr>
<tr class="memdesc:a9e419cd897e42ceca91c3f7922ead777"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets up an effective RHS.  <a href="classClpMatrixBase.html#a9e419cd897e42ceca91c3f7922ead777">More...</a><br /></td></tr>
<tr class="separator:a9e419cd897e42ceca91c3f7922ead777"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd89cc8633dd027426ef6b1358a6c1b4"><td class="memItemLeft" align="right" valign="top">virtual double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#afd89cc8633dd027426ef6b1358a6c1b4">rhsOffset</a> (<a class="el" href="classClpSimplex.html">ClpSimplex</a> *model, bool forceRefresh=false, bool check=false)</td></tr>
<tr class="memdesc:afd89cc8633dd027426ef6b1358a6c1b4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns effective RHS offset if it is being used.  <a href="classClpMatrixBase.html#afd89cc8633dd027426ef6b1358a6c1b4">More...</a><br /></td></tr>
<tr class="separator:afd89cc8633dd027426ef6b1358a6c1b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ccbafdeab34c141d4fe51bead3a0799"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a0ccbafdeab34c141d4fe51bead3a0799">lastRefresh</a> () const</td></tr>
<tr class="memdesc:a0ccbafdeab34c141d4fe51bead3a0799"><td class="mdescLeft">&#160;</td><td class="mdescRight">If rhsOffset used this is iteration last refreshed.  <a href="classClpMatrixBase.html#a0ccbafdeab34c141d4fe51bead3a0799">More...</a><br /></td></tr>
<tr class="separator:a0ccbafdeab34c141d4fe51bead3a0799"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9211d38c32ed96c2fb6e8a4142255b40"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a9211d38c32ed96c2fb6e8a4142255b40">refreshFrequency</a> () const</td></tr>
<tr class="memdesc:a9211d38c32ed96c2fb6e8a4142255b40"><td class="mdescLeft">&#160;</td><td class="mdescRight">If rhsOffset used this is refresh frequency (0==off)  <a href="classClpMatrixBase.html#a9211d38c32ed96c2fb6e8a4142255b40">More...</a><br /></td></tr>
<tr class="separator:a9211d38c32ed96c2fb6e8a4142255b40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab249ed1da09f4165aeeb4d20e07af869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ab249ed1da09f4165aeeb4d20e07af869">setRefreshFrequency</a> (int value)</td></tr>
<tr class="separator:ab249ed1da09f4165aeeb4d20e07af869"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdf5ce75f487619543e2dc177bc61e83"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#abdf5ce75f487619543e2dc177bc61e83">skipDualCheck</a> () const</td></tr>
<tr class="memdesc:abdf5ce75f487619543e2dc177bc61e83"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to skip dual checks most of time  <a href="classClpMatrixBase.html#abdf5ce75f487619543e2dc177bc61e83">More...</a><br /></td></tr>
<tr class="separator:abdf5ce75f487619543e2dc177bc61e83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0ada77e75e2c536fb88f8968d1ad038"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#af0ada77e75e2c536fb88f8968d1ad038">setSkipDualCheck</a> (bool yes)</td></tr>
<tr class="separator:af0ada77e75e2c536fb88f8968d1ad038"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8e01a701e42bcbd91e96e42611dfab0"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ab8e01a701e42bcbd91e96e42611dfab0">minimumObjectsScan</a> () const</td></tr>
<tr class="memdesc:ab8e01a701e42bcbd91e96e42611dfab0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial pricing tuning parameter - minimum number of "objects" to scan.  <a href="classClpMatrixBase.html#ab8e01a701e42bcbd91e96e42611dfab0">More...</a><br /></td></tr>
<tr class="separator:ab8e01a701e42bcbd91e96e42611dfab0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9579c957a9bee36a096f219db5a03f31"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a9579c957a9bee36a096f219db5a03f31">setMinimumObjectsScan</a> (int value)</td></tr>
<tr class="separator:a9579c957a9bee36a096f219db5a03f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d819e4dabe5ac194f9c3a7f6dd0eaed"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a8d819e4dabe5ac194f9c3a7f6dd0eaed">minimumGoodReducedCosts</a> () const</td></tr>
<tr class="memdesc:a8d819e4dabe5ac194f9c3a7f6dd0eaed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial pricing tuning parameter - minimum number of negative reduced costs to get.  <a href="classClpMatrixBase.html#a8d819e4dabe5ac194f9c3a7f6dd0eaed">More...</a><br /></td></tr>
<tr class="separator:a8d819e4dabe5ac194f9c3a7f6dd0eaed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39ddb8e467341bb9c6267dde454669e3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a39ddb8e467341bb9c6267dde454669e3">setMinimumGoodReducedCosts</a> (int value)</td></tr>
<tr class="separator:a39ddb8e467341bb9c6267dde454669e3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a465d58b66aef67e9e1e99d702e3dcc5c"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a465d58b66aef67e9e1e99d702e3dcc5c">startFraction</a> () const</td></tr>
<tr class="memdesc:a465d58b66aef67e9e1e99d702e3dcc5c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current start of search space in matrix (as fraction)  <a href="classClpMatrixBase.html#a465d58b66aef67e9e1e99d702e3dcc5c">More...</a><br /></td></tr>
<tr class="separator:a465d58b66aef67e9e1e99d702e3dcc5c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac421bf0475ca6728b4970ee9d659030b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ac421bf0475ca6728b4970ee9d659030b">setStartFraction</a> (double value)</td></tr>
<tr class="separator:ac421bf0475ca6728b4970ee9d659030b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e7f4a60e1628984bd074c609fe660be"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a9e7f4a60e1628984bd074c609fe660be">endFraction</a> () const</td></tr>
<tr class="memdesc:a9e7f4a60e1628984bd074c609fe660be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current end of search space in matrix (as fraction)  <a href="classClpMatrixBase.html#a9e7f4a60e1628984bd074c609fe660be">More...</a><br /></td></tr>
<tr class="separator:a9e7f4a60e1628984bd074c609fe660be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a31432e7c0fd75563c9772d1089bf6467"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a31432e7c0fd75563c9772d1089bf6467">setEndFraction</a> (double value)</td></tr>
<tr class="separator:a31432e7c0fd75563c9772d1089bf6467"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6647956268691a0096e86ddde8e904d"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ac6647956268691a0096e86ddde8e904d">savedBestDj</a> () const</td></tr>
<tr class="memdesc:ac6647956268691a0096e86ddde8e904d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current best reduced cost.  <a href="classClpMatrixBase.html#ac6647956268691a0096e86ddde8e904d">More...</a><br /></td></tr>
<tr class="separator:ac6647956268691a0096e86ddde8e904d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65fb5543f3e35709f8e1c7922b15c407"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a65fb5543f3e35709f8e1c7922b15c407">setSavedBestDj</a> (double value)</td></tr>
<tr class="separator:a65fb5543f3e35709f8e1c7922b15c407"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fdd9962657f53b782eae9a8f267e3ac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a9fdd9962657f53b782eae9a8f267e3ac">originalWanted</a> () const</td></tr>
<tr class="memdesc:a9fdd9962657f53b782eae9a8f267e3ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial number of negative reduced costs wanted.  <a href="classClpMatrixBase.html#a9fdd9962657f53b782eae9a8f267e3ac">More...</a><br /></td></tr>
<tr class="separator:a9fdd9962657f53b782eae9a8f267e3ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545e08cf1be9fa216cdad8ae7db86947"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a545e08cf1be9fa216cdad8ae7db86947">setOriginalWanted</a> (int value)</td></tr>
<tr class="separator:a545e08cf1be9fa216cdad8ae7db86947"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af0558c228415c614205c841750084c1c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#af0558c228415c614205c841750084c1c">currentWanted</a> () const</td></tr>
<tr class="memdesc:af0558c228415c614205c841750084c1c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current number of negative reduced costs which we still need.  <a href="classClpMatrixBase.html#af0558c228415c614205c841750084c1c">More...</a><br /></td></tr>
<tr class="separator:af0558c228415c614205c841750084c1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd6e1d2a3b23bb8929be77c2ca923e9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a6dd6e1d2a3b23bb8929be77c2ca923e9">setCurrentWanted</a> (int value)</td></tr>
<tr class="separator:a6dd6e1d2a3b23bb8929be77c2ca923e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c6d2937e73278ae4eaa4798b7ed22fe"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a5c6d2937e73278ae4eaa4798b7ed22fe">savedBestSequence</a> () const</td></tr>
<tr class="memdesc:a5c6d2937e73278ae4eaa4798b7ed22fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current best sequence.  <a href="classClpMatrixBase.html#a5c6d2937e73278ae4eaa4798b7ed22fe">More...</a><br /></td></tr>
<tr class="separator:a5c6d2937e73278ae4eaa4798b7ed22fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ac4f21dfbc09ed7b33b0fb4e5b23869"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a4ac4f21dfbc09ed7b33b0fb4e5b23869">setSavedBestSequence</a> (int value)</td></tr>
<tr class="separator:a4ac4f21dfbc09ed7b33b0fb4e5b23869"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pro-attribs"></a>
Protected Attributes</h2></td></tr>
<tr><td colspan="2"><div class="groupHeader">Data members</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>The data members are protected to allow access for derived classes. </p>
</div></td></tr>
<tr class="memitem:ad5ec28bf0f0da85271563db3ac842400"><td class="memItemLeft" align="right" valign="top">double *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ad5ec28bf0f0da85271563db3ac842400">rhsOffset_</a></td></tr>
<tr class="memdesc:ad5ec28bf0f0da85271563db3ac842400"><td class="mdescLeft">&#160;</td><td class="mdescRight">Effective RHS offset if it is being used.  <a href="classClpMatrixBase.html#ad5ec28bf0f0da85271563db3ac842400">More...</a><br /></td></tr>
<tr class="separator:ad5ec28bf0f0da85271563db3ac842400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abec7398c2534045b5f35dc15225a4ece"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#abec7398c2534045b5f35dc15225a4ece">startFraction_</a></td></tr>
<tr class="memdesc:abec7398c2534045b5f35dc15225a4ece"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current start of search space in matrix (as fraction)  <a href="classClpMatrixBase.html#abec7398c2534045b5f35dc15225a4ece">More...</a><br /></td></tr>
<tr class="separator:abec7398c2534045b5f35dc15225a4ece"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae786f1c9247f4cb1048cb17e68bade89"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ae786f1c9247f4cb1048cb17e68bade89">endFraction_</a></td></tr>
<tr class="memdesc:ae786f1c9247f4cb1048cb17e68bade89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current end of search space in matrix (as fraction)  <a href="classClpMatrixBase.html#ae786f1c9247f4cb1048cb17e68bade89">More...</a><br /></td></tr>
<tr class="separator:ae786f1c9247f4cb1048cb17e68bade89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27ba2356a51f97ab52927d9664bc02d0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a27ba2356a51f97ab52927d9664bc02d0">savedBestDj_</a></td></tr>
<tr class="memdesc:a27ba2356a51f97ab52927d9664bc02d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Best reduced cost so far.  <a href="classClpMatrixBase.html#a27ba2356a51f97ab52927d9664bc02d0">More...</a><br /></td></tr>
<tr class="separator:a27ba2356a51f97ab52927d9664bc02d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb081dba0051e7e973832c7cea86bb54"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#afb081dba0051e7e973832c7cea86bb54">originalWanted_</a></td></tr>
<tr class="memdesc:afb081dba0051e7e973832c7cea86bb54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initial number of negative reduced costs wanted.  <a href="classClpMatrixBase.html#afb081dba0051e7e973832c7cea86bb54">More...</a><br /></td></tr>
<tr class="separator:afb081dba0051e7e973832c7cea86bb54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a691cbfa984c3ddfd4387833d27f6c16d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a691cbfa984c3ddfd4387833d27f6c16d">currentWanted_</a></td></tr>
<tr class="memdesc:a691cbfa984c3ddfd4387833d27f6c16d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Current number of negative reduced costs which we still need.  <a href="classClpMatrixBase.html#a691cbfa984c3ddfd4387833d27f6c16d">More...</a><br /></td></tr>
<tr class="separator:a691cbfa984c3ddfd4387833d27f6c16d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3bea489a8066c74ae251e375861a965d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a3bea489a8066c74ae251e375861a965d">savedBestSequence_</a></td></tr>
<tr class="memdesc:a3bea489a8066c74ae251e375861a965d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Saved best sequence in pricing.  <a href="classClpMatrixBase.html#a3bea489a8066c74ae251e375861a965d">More...</a><br /></td></tr>
<tr class="separator:a3bea489a8066c74ae251e375861a965d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a908d645bfb8c7bca32dc80a8985407d9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a908d645bfb8c7bca32dc80a8985407d9">type_</a></td></tr>
<tr class="memdesc:a908d645bfb8c7bca32dc80a8985407d9"><td class="mdescLeft">&#160;</td><td class="mdescRight">type (may be useful)  <a href="classClpMatrixBase.html#a908d645bfb8c7bca32dc80a8985407d9">More...</a><br /></td></tr>
<tr class="separator:a908d645bfb8c7bca32dc80a8985407d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90f8704c47bc37225648efdb6bb06816"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a90f8704c47bc37225648efdb6bb06816">lastRefresh_</a></td></tr>
<tr class="memdesc:a90f8704c47bc37225648efdb6bb06816"><td class="mdescLeft">&#160;</td><td class="mdescRight">If rhsOffset used this is iteration last refreshed.  <a href="classClpMatrixBase.html#a90f8704c47bc37225648efdb6bb06816">More...</a><br /></td></tr>
<tr class="separator:a90f8704c47bc37225648efdb6bb06816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeb258646d90b3e1b7c88ad2ccbd2b2c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#abeb258646d90b3e1b7c88ad2ccbd2b2c">refreshFrequency_</a></td></tr>
<tr class="memdesc:abeb258646d90b3e1b7c88ad2ccbd2b2c"><td class="mdescLeft">&#160;</td><td class="mdescRight">If rhsOffset used this is refresh frequency (0==off)  <a href="classClpMatrixBase.html#abeb258646d90b3e1b7c88ad2ccbd2b2c">More...</a><br /></td></tr>
<tr class="separator:abeb258646d90b3e1b7c88ad2ccbd2b2c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79b0ebc260090b33d23f10b88da30d1e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a79b0ebc260090b33d23f10b88da30d1e">minimumObjectsScan_</a></td></tr>
<tr class="memdesc:a79b0ebc260090b33d23f10b88da30d1e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial pricing tuning parameter - minimum number of "objects" to scan.  <a href="classClpMatrixBase.html#a79b0ebc260090b33d23f10b88da30d1e">More...</a><br /></td></tr>
<tr class="separator:a79b0ebc260090b33d23f10b88da30d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356e774b167d00378d1352f42effef46"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a356e774b167d00378d1352f42effef46">minimumGoodReducedCosts_</a></td></tr>
<tr class="memdesc:a356e774b167d00378d1352f42effef46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Partial pricing tuning parameter - minimum number of negative reduced costs to get.  <a href="classClpMatrixBase.html#a356e774b167d00378d1352f42effef46">More...</a><br /></td></tr>
<tr class="separator:a356e774b167d00378d1352f42effef46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1bd1b94a4aa10986177352f807e115ff"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a1bd1b94a4aa10986177352f807e115ff">trueSequenceIn_</a></td></tr>
<tr class="memdesc:a1bd1b94a4aa10986177352f807e115ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">True sequence in (i.e. from larger problem)  <a href="classClpMatrixBase.html#a1bd1b94a4aa10986177352f807e115ff">More...</a><br /></td></tr>
<tr class="separator:a1bd1b94a4aa10986177352f807e115ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd6b009fc0b1fc73cb79403aa67aed25"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#acd6b009fc0b1fc73cb79403aa67aed25">trueSequenceOut_</a></td></tr>
<tr class="memdesc:acd6b009fc0b1fc73cb79403aa67aed25"><td class="mdescLeft">&#160;</td><td class="mdescRight">True sequence out (i.e. from larger problem)  <a href="classClpMatrixBase.html#acd6b009fc0b1fc73cb79403aa67aed25">More...</a><br /></td></tr>
<tr class="separator:acd6b009fc0b1fc73cb79403aa67aed25"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b2bae64f8cd712b29f14adcd457d124"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a6b2bae64f8cd712b29f14adcd457d124">skipDualCheck_</a></td></tr>
<tr class="memdesc:a6b2bae64f8cd712b29f14adcd457d124"><td class="mdescLeft">&#160;</td><td class="mdescRight">whether to skip dual checks most of time  <a href="classClpMatrixBase.html#a6b2bae64f8cd712b29f14adcd457d124">More...</a><br /></td></tr>
<tr class="separator:a6b2bae64f8cd712b29f14adcd457d124"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="member-group"></a>
Constructors, destructor&lt;br&gt;</h2></td></tr>
<tr><td class="ititle" colspan="2"><p><a class="anchor" id="amgrp8370017f4e18c6316f58df1c1810ddc5"></a><b>NOTE</b>: All constructors are protected.</p>
<p>There's no need to expose them, after all, this is an abstract class. </p>
</td></tr>
<tr class="memitem:addc881d697d07c5cf875e97a05323339"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#addc881d697d07c5cf875e97a05323339">~ClpMatrixBase</a> ()</td></tr>
<tr class="memdesc:addc881d697d07c5cf875e97a05323339"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor (has to be public)  <a href="classClpMatrixBase.html#addc881d697d07c5cf875e97a05323339">More...</a><br /></td></tr>
<tr class="separator:addc881d697d07c5cf875e97a05323339"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78e1ae3067863f3c114d203ac1725227"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a78e1ae3067863f3c114d203ac1725227">ClpMatrixBase</a> ()</td></tr>
<tr class="memdesc:a78e1ae3067863f3c114d203ac1725227"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default constructor.  <a href="classClpMatrixBase.html#a78e1ae3067863f3c114d203ac1725227">More...</a><br /></td></tr>
<tr class="separator:a78e1ae3067863f3c114d203ac1725227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac28d6d537bccf8a5d7caf64354f5042b"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#ac28d6d537bccf8a5d7caf64354f5042b">ClpMatrixBase</a> (const <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a> &amp;)</td></tr>
<tr class="separator:ac28d6d537bccf8a5d7caf64354f5042b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a1ea38e5e680de5a38b4f65ce4d275f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classClpMatrixBase.html#a4a1ea38e5e680de5a38b4f65ce4d275f">operator=</a> (const <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a> &amp;)</td></tr>
<tr class="separator:a4a1ea38e5e680de5a38b4f65ce4d275f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Abstract base class for Clp Matrices. </p>
<p>Since this class is abstract, no object of this type can be created.</p>
<p>If a derived class provides all methods then all Clp algorithms should work. Some can be very inefficient e.g. getElements etc is only used for tightening bounds for dual and the copies are deleted. Many methods can just be dummy i.e. abort(); if not all features are being used. So if column generation was being done then it makes no sense to do steepest edge so there would be no point providing subsetTransposeTimes. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00038">38</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a78e1ae3067863f3c114d203ac1725227"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a78e1ae3067863f3c114d203ac1725227">&#9670;&nbsp;</a></span>ClpMatrixBase() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ClpMatrixBase::ClpMatrixBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Default constructor. </p>

</div>
</div>
<a id="addc881d697d07c5cf875e97a05323339"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addc881d697d07c5cf875e97a05323339">&#9670;&nbsp;</a></span>~ClpMatrixBase()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual ClpMatrixBase::~ClpMatrixBase </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Destructor (has to be public) </p>

</div>
</div>
<a id="ac28d6d537bccf8a5d7caf64354f5042b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac28d6d537bccf8a5d7caf64354f5042b">&#9670;&nbsp;</a></span>ClpMatrixBase() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">ClpMatrixBase::ClpMatrixBase </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a7eb12e49df620c3edbc0e81bb66ea450"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb12e49df620c3edbc0e81bb66ea450">&#9670;&nbsp;</a></span>getPackedMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CoinPackedMatrix* ClpMatrixBase::getPackedMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return a complete CoinPackedMatrix. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#a0b74f264296808b38401eccbf23e0249">ClpPackedMatrix</a>, <a class="el" href="classClpDummyMatrix.html#aa0a0e4a8468262069b6146e95a3028cf">ClpDummyMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#add04a4517690a743d0654ff4bfd1cdcd">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#a279ec9c99b89af91c04f2d0924239469">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a088831eed7341859efc7a1b5b7232008"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a088831eed7341859efc7a1b5b7232008">&#9670;&nbsp;</a></span>isColOrdered()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ClpMatrixBase::isColOrdered </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Whether the packed matrix is column major ordered or not. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#a2be812c289fd11e9441de5d5b994cca5">ClpPackedMatrix</a>, <a class="el" href="classClpDummyMatrix.html#a1f985564f4fc9be77dd4549fb8f06c54">ClpDummyMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a447fd806f219be6fc4fe7dc9de666651">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#aef921003ed2b93e5b1ad42b2935d2b02">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="adefaf54f23059c4b1047969659fdffbb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adefaf54f23059c4b1047969659fdffbb">&#9670;&nbsp;</a></span>getNumElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CoinBigIndex ClpMatrixBase::getNumElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of entries in the packed matrix. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#a11ed89165e2d780f21d680669bd7e4ed">ClpPackedMatrix</a>, <a class="el" href="classClpDummyMatrix.html#a7e0cced588c03564dbeba480647989b2">ClpDummyMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#aba81768aab6e5e4acfc24110fb32dee6">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#ae034177a65a6b565ad93c196c9c19501">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a589d4c8e29abb80e291e6cfd118b4b0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a589d4c8e29abb80e291e6cfd118b4b0c">&#9670;&nbsp;</a></span>getNumCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::getNumCols </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of columns. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#ae64970226d82ec60f4d2fcb93af524d3">ClpPackedMatrix</a>, <a class="el" href="classClpDummyMatrix.html#aec6c6ac62314a3ce054f2f40cd8e9bee">ClpDummyMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#aadbf598222c71b3405e51a1c634d6fd2">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#a1fe94f6ff74b52b40edf179a489e97a3">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a762b6a8bb910b9eb96302b5b0f488ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a762b6a8bb910b9eb96302b5b0f488ca9">&#9670;&nbsp;</a></span>getNumRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::getNumRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Number of rows. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#abdc97c744fd07974e035bdf0ed34c885">ClpPackedMatrix</a>, <a class="el" href="classClpDummyMatrix.html#a3db6733bcc2fd0b5ae05f21726bad063">ClpDummyMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#ab27f74a1ff7b74bb9ebc7c9421c74b82">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#ad2d09f2b4624a874318b2b4bb477e5f3">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a5ba58cedc63a044d5bbd6c4ec18455e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5ba58cedc63a044d5bbd6c4ec18455e3">&#9670;&nbsp;</a></span>getElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const double* ClpMatrixBase::getElements </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A vector containing the elements in the packed matrix. </p>
<p>Note that there might be gaps in this list, entries that do not belong to any major-dimension vector. To get the actual elements one should look at this vector together with vectorStarts and vectorLengths. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#afce4dd1ac4971fd9436bef1b8e168940">ClpPackedMatrix</a>, <a class="el" href="classClpDummyMatrix.html#a80963fd62d4d520f0dc04bc5df4832ce">ClpDummyMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a59eda33af140a82b84b5a740a03eb10c">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#a48aadc24894dedb5e4ab1fc147b1814b">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a3e1b52ec1ec8c783e9cf23296bcafbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e1b52ec1ec8c783e9cf23296bcafbc3">&#9670;&nbsp;</a></span>getIndices()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const int* ClpMatrixBase::getIndices </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>A vector containing the minor indices of the elements in the packed matrix. </p>
<p>Note that there might be gaps in this list, entries that do not belong to any major-dimension vector. To get the actual elements one should look at this vector together with vectorStarts and vectorLengths. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#a09323355ef427422416449d393f496a8">ClpPackedMatrix</a>, <a class="el" href="classClpDummyMatrix.html#aa7f06922c7cc1768254a2670753b2e2a">ClpDummyMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#aa10374f5966f74a8cbf947be1dd0ddb4">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#a338a4235fe0ae7eb69e8b312928ae80d">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="ac7f3fa1d27854d956a0bc0066d3ec14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac7f3fa1d27854d956a0bc0066d3ec14f">&#9670;&nbsp;</a></span>getVectorStarts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const CoinBigIndex* ClpMatrixBase::getVectorStarts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#a773898f60496a6e75f491bbd763dc02f">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#afb46647912c8c478f201864fc1f993b4">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#ae73fbeb56caeccf2a71e02bf4fd53b52">ClpPlusMinusOneMatrix</a>, and <a class="el" href="classClpDummyMatrix.html#a57edfc926af3c58e3b674b0385d7d9f7">ClpDummyMatrix</a>.</p>

</div>
</div>
<a id="a226ded31086afc0d1389983c5f4b80ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a226ded31086afc0d1389983c5f4b80ba">&#9670;&nbsp;</a></span>getVectorLengths()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual const int* ClpMatrixBase::getVectorLengths </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The lengths of the major-dimension vectors. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#aa53b3ac646634c3aee65171bab7e57aa">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#ab575533047139ac090dfb4668af6e16a">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#a432c68fff9fc45c7357edc68aae77c7c">ClpPlusMinusOneMatrix</a>, and <a class="el" href="classClpDummyMatrix.html#a2f041b5ec7c28d17dbc3b119cb4e1151">ClpDummyMatrix</a>.</p>

</div>
</div>
<a id="aeb0f30bce468c4b831c3cee13eb166be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeb0f30bce468c4b831c3cee13eb166be">&#9670;&nbsp;</a></span>getVectorLength()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::getVectorLength </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>index</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The length of a single major-dimension vector. </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a3a28aea134b853d357984805829c5d6c">ClpPackedMatrix</a>.</p>

</div>
</div>
<a id="afd825f0c98597cc0459c70e6829be68e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd825f0c98597cc0459c70e6829be68e">&#9670;&nbsp;</a></span>deleteCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::deleteCols </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numDel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indDel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the columns whose indices are listed in <code>indDel</code>. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#a8918de3aa5db479cf0b060ad22043d3e">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a11a4a8b42fb775c6b54e5d2b3f4c2340">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#a3b74485668dc51bc1a9c0791505e6a4f">ClpPlusMinusOneMatrix</a>, and <a class="el" href="classClpDummyMatrix.html#ac050dce1619f5196da05109265a67d0d">ClpDummyMatrix</a>.</p>

</div>
</div>
<a id="ac1f4918af64f9fdcba6e56b18bf970bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f4918af64f9fdcba6e56b18bf970bf">&#9670;&nbsp;</a></span>deleteRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::deleteRows </td>
          <td>(</td>
          <td class="paramtype">const int&#160;</td>
          <td class="paramname"><em>numDel</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>indDel</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Delete the rows whose indices are listed in <code>indDel</code>. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#af184211a044e5865591382d3d68fed76">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#ac6068034c142a91f707c76ce8de0a41d">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#a3f81bfa39f6341c743363db151d95e51">ClpPlusMinusOneMatrix</a>, and <a class="el" href="classClpDummyMatrix.html#aef93202afddc3d43d0360525bd62f4ec">ClpDummyMatrix</a>.</p>

</div>
</div>
<a id="a3aa6b15024e1990fa3e15ac6375aaaa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aa6b15024e1990fa3e15ac6375aaaa7">&#9670;&nbsp;</a></span>appendCols()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::appendCols </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinPackedVectorBase *const *&#160;</td>
          <td class="paramname"><em>columns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append Columns. </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a15a24d10f2c8d624f2e1b0bd79ed6782">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a1d68fb5e2fdcc52bf8310eaa63bb07cd">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#a8485b82b9f387bf89d4a31b21d9a42a1">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a9adfa8e1f58108d4dc00e90a7a3261de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adfa8e1f58108d4dc00e90a7a3261de">&#9670;&nbsp;</a></span>appendRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::appendRows </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinPackedVectorBase *const *&#160;</td>
          <td class="paramname"><em>rows</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append Rows. </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a18b51bda07eac4dd568e0f9265334d77">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#ab38306319bfe04353792bf61deef939b">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#a8e06373e84aafa89a7374e1768bc2eec">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a921edfc0f79f20c2a078ec45c1d62d61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a921edfc0f79f20c2a078ec45c1d62d61">&#9670;&nbsp;</a></span>modifyCoefficient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::modifyCoefficient </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>newElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>keepZero</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Modify one element of packed matrix. </p>
<p>An element may be added. This works for either ordering If the new element is zero it will be deleted unless keepZero true </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#aa41a79939c9f7e78f115520b20e4427a">ClpPackedMatrix</a>.</p>

</div>
</div>
<a id="adac73d7a2257c7165a18603f82333dae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adac73d7a2257c7165a18603f82333dae">&#9670;&nbsp;</a></span>appendMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::appendMatrix </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinBigIndex *&#160;</td>
          <td class="paramname"><em>starts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>index</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>element</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberOther</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Append a set of rows/columns to the end of the matrix. </p>
<p>Returns number of errors i.e. if any of the new rows/columns contain an index that's larger than the number of columns-1/rows-1 (if numberOther&gt;0) or duplicates If 0 then rows, 1 if columns </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a5f6222e869a0b7d96e772efe7422013f">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#ad90e0b613f3b008f1dc6bba5cf36551c">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#abec13ce28dea6f2faef772ee1e3b1849">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a4fd0acbb7032cbe7bcdffb499a853b22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4fd0acbb7032cbe7bcdffb499a853b22">&#9670;&nbsp;</a></span>reverseOrderedCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a>* ClpMatrixBase::reverseOrderedCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns a new matrix in reverse order without gaps Is allowed to return NULL if doesn't want to have row copy. </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a181dde0a75ca5bc62db039e3f7d03bba">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a044e2695779c25e068fadae98d3039a4">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#a63f4bef738359e99186d45869eef821a">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpDummyMatrix.html#a8d5b9c7fed2778279eaa2e3dec28e163">ClpDummyMatrix</a>, and <a class="el" href="classClpGubMatrix.html#a1cccbf767b9584d510321053ba5cc7a8">ClpGubMatrix</a>.</p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00096">96</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a8f18b4e3356e5de8073a323cf3776134"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8f18b4e3356e5de8073a323cf3776134">&#9670;&nbsp;</a></span>countBasis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::countBasis </td>
          <td>(</td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>whichColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberColumnBasic</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of elements in column part of basis. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#a0d95bc691348179d7513a6f51a68f80e">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#aa2dc78befbc5c911dd65d44dca5f54de">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#a3baea643c3c521f089aeb2b62dbac9a7">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpDummyMatrix.html#ab9ef58f0bf64cb3cad4a25aa76c28eb4">ClpDummyMatrix</a>, and <a class="el" href="classClpGubMatrix.html#a3b062bc61e2df3f14ef4b9757145b918">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="a8fea2736f9300450312781406183553b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8fea2736f9300450312781406183553b">&#9670;&nbsp;</a></span>fillBasis()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::fillBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>whichColumn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberColumnBasic</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>row</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>rowCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>columnCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinFactorizationDouble *&#160;</td>
          <td class="paramname"><em>element</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Fills in column part of basis. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#a426be6988b8fb11c1d5f0a11e059b109">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a72c81c8ef7bf4bc52ba16dccc0a1dc68">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#a93da383d5581405ef189520db02606c5">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpDummyMatrix.html#a46b1af1330f9dd66fccb8c75aa0222e1">ClpDummyMatrix</a>, and <a class="el" href="classClpGubMatrix.html#ae046d97b1eaa6c10d2042e9ab5725099">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="aa642b94e1b87dd39d8d05f2b4626948a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa642b94e1b87dd39d8d05f2b4626948a">&#9670;&nbsp;</a></span>scale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::scale </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpModel.html">ClpModel</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates scales for column copy (rowCopy in model may be modified) default does not allow scaling returns non-zero if no scaling done. </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a1eb14720ad7724d1c63cc882c9f81b89">ClpPackedMatrix</a>.</p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00116">116</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="ac1ee6860654999be9f976a7479a54b85"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1ee6860654999be9f976a7479a54b85">&#9670;&nbsp;</a></span>scaleRowCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::scaleRowCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpModel.html">ClpModel</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales rowCopy if column copy scaled Only called if scales already exist. </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a75ef832f4d79fc98b6326a8f36a56cd9">ClpPackedMatrix</a>.</p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00122">122</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="aebb58a256204dae8daa152c845ac0d82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebb58a256204dae8daa152c845ac0d82">&#9670;&nbsp;</a></span>canGetRowCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ClpMatrixBase::canGetRowCopy </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if can create row copy. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00124">124</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="afb17da47c2626ed35eba6934279792b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb17da47c2626ed35eba6934279792b6">&#9670;&nbsp;</a></span>scaledColumnCopy()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a>* ClpMatrixBase::scaledColumnCopy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpModel.html">ClpModel</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Realy really scales column copy Only called if scales already exist. </p>
<p>Up to user to delete </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a47f85eb42ec7ff339b618f7b886acc37">ClpPackedMatrix</a>.</p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00131">131</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a670d63d24534a4b48549aacad12efafb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a670d63d24534a4b48549aacad12efafb">&#9670;&nbsp;</a></span>allElementsInRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ClpMatrixBase::allElementsInRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpModel.html">ClpModel</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"> = <code>15</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Checks if all elements are in valid range. </p>
<p>Can just return true if you are not paranoid. For Clp I will probably expect no zeros. Code can modify matrix to get rid of small elements. check bits (can be turned off to save time) : 1 - check if matrix has gaps 2 - check if zero elements 4 - check and compress duplicates 8 - report on large and small </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a2b47838e9c39eb3be867ee6f338c571a">ClpPackedMatrix</a>.</p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00146">146</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a12715a2bf3b3b396d08d2f0ed5adffde"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12715a2bf3b3b396d08d2f0ed5adffde">&#9670;&nbsp;</a></span>setDimensions()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::setDimensions </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numrows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numcols</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Set the dimensions of the matrix. </p>
<p>In effect, append new empty columns/rows to the matrix. A negative number for either dimension means that that dimension doesn't change. Otherwise the new dimensions MUST be at least as large as the current ones otherwise an exception is thrown. </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#ad68a658833a3317e186f32c49a1107c7">ClpPackedMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#a2666e871447c74cbb6f100fb5afd31e5">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="ab1eb6fa2da292f5348652cf606b0f483"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1eb6fa2da292f5348652cf606b0f483">&#9670;&nbsp;</a></span>rangeOfElements()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::rangeOfElements </td>
          <td>(</td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>smallestNegative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>largestNegative</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>smallestPositive</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>largestPositive</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns largest and smallest elements of both signs. </p>
<p>Largest refers to largest absolute value. If returns zeros then can't tell anything </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#aa6412f55308b78367974c0fea652a3e4">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a3febd71df68f255ada55226721ee91ac">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#a5ddee228d7f607398ae0e02bf5509de3">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a65e8af7fd83f0ed81c72e76c9f3d388b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65e8af7fd83f0ed81c72e76c9f3d388b">&#9670;&nbsp;</a></span>unpack()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::unpack </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>rowArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks a column into an CoinIndexedvector. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#a806383929305b72ab0e3c65ebc78fb4c">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a9fa70b0f1fe494d72be73a7f99116b60">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#abbf45a0e05babdb52129dd32579a3ad4">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpDummyMatrix.html#a29b3ab52e70f5a33e15b483150ab7b21">ClpDummyMatrix</a>, and <a class="el" href="classClpGubMatrix.html#a2eb683f5aa238159381ecd867faa604a">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="a01442004ddef377732f6b32425356298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01442004ddef377732f6b32425356298">&#9670;&nbsp;</a></span>unpackPacked()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::unpackPacked </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>rowArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unpacks a column into an CoinIndexedvector in packed format Note that model is NOT const. </p>
<p>Bounds and objective could be modified if doing column generation (just for this variable) </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#aa5cf1bc110e14520f6c27ae198fe99df">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a2a86e5cac81512a3c2754465b3d51a95">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#a53758d372411ddc8f3860c031a5ae11f">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpDummyMatrix.html#ac57b17fdb524edc001fc700d94cf12eb">ClpDummyMatrix</a>, and <a class="el" href="classClpGubMatrix.html#a5ab72b55477c75d73ec020bbf781a1d1">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="ab37aacdf7f1c6aca7afc69877294d003"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab37aacdf7f1c6aca7afc69877294d003">&#9670;&nbsp;</a></span>refresh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::refresh </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Purely for column generation and similar ideas. </p>
<p>Allows matrix and any bounds or costs to be updated (sensibly). Returns non-zero if any changes. </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a87ca0e6fe4e8edb80d650a5dd9a16582">ClpPackedMatrix</a>, and <a class="el" href="classClpDynamicMatrix.html#a11ab44c75d72296d3f92cad5d66f1901">ClpDynamicMatrix</a>.</p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00179">179</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="aa42532c012ff3cacfcb64c90b765a0ea"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42532c012ff3cacfcb64c90b765a0ea">&#9670;&nbsp;</a></span>reallyScale()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::reallyScale </td>
          <td>(</td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>rowScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *&#160;</td>
          <td class="paramname"><em>columnScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a240aed077124704dd5d271de3aa0173c">ClpPackedMatrix</a>.</p>

</div>
</div>
<a id="ad17e36bc57e5c87be420c42afd736b6e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad17e36bc57e5c87be420c42afd736b6e">&#9670;&nbsp;</a></span>dubiousWeights()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual CoinBigIndex* ClpMatrixBase::dubiousWeights </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>inputWeights</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Given positive integer weights for each row fills in sum of weights for each column (and slack). </p>
<p>Returns weights vector Default returns vector of ones </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#ae05f137a266e3dc6a98d7aa122f71be1">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a33264619e8883ca0081d660450e56c7f">ClpNetworkMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#acf3854b41a6ed2bce72ec4061f107d5b">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a36b91b9af6d91e4aca5528c0f1c284e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a36b91b9af6d91e4aca5528c0f1c284e7">&#9670;&nbsp;</a></span>add() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>rowArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds multiple of a column into an CoinIndexedvector You can use quickAdd to add to vector. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#aac5bf5f8d714a63c009315e8572c6d17">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a7870ef3737e42b046c53dfc8ac0df866">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#ad2fe4108ce498fd5e9ab94e7dff910d6">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpDummyMatrix.html#a69dac95e27784b8b922ddee7ad84a78e">ClpDummyMatrix</a>, and <a class="el" href="classClpGubMatrix.html#adf01b9b5e67b58fc340521689faa4a24">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="a49acfbbd5efc8208f475a5f2caa81ccd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a49acfbbd5efc8208f475a5f2caa81ccd">&#9670;&nbsp;</a></span>add() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::add </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>column</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>multiplier</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds multiple of a column into an array. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#ab5522b6b152f5e885bbc22baeae255e7">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a48c58d4bd5763a94c2cec8890e2215fa">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#a0c209616a073ca8ed8fbaffb0bdccd38">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpDummyMatrix.html#a0ca9242f33115c88da7d19ad833ae68b">ClpDummyMatrix</a>, and <a class="el" href="classClpGubMatrix.html#a9dc4f3267111d04380eecbca930f1380">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="a132916066c3165524e1474d1086206c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a132916066c3165524e1474d1086206c6">&#9670;&nbsp;</a></span>releasePackedMatrix()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::releasePackedMatrix </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allow any parts of a created CoinPackedMatrix to be deleted. </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#a5e15ef764f07159162ff58e9525b35c2">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a88dbcc7fcb41f7daf6dae46bb401348a">ClpNetworkMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#aa569124f3bb974e39c1d11545693fe5d">ClpPlusMinusOneMatrix</a>, and <a class="el" href="classClpDummyMatrix.html#a508851cf6d0c5c01c512c0b9d85be7ee">ClpDummyMatrix</a>.</p>

</div>
</div>
<a id="a8e321fc1cde2d3448f797f181449eaa2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8e321fc1cde2d3448f797f181449eaa2">&#9670;&nbsp;</a></span>canDoPartialPricing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ClpMatrixBase::canDoPartialPricing </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Says whether it can do partial pricing. </p>

<p>Reimplemented in <a class="el" href="classClpPlusMinusOneMatrix.html#a1fcc1c88cacde796761bdf00f9756245">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpPackedMatrix.html#a11fa61dd90958c4cdc8a1310f0fd4b21">ClpPackedMatrix</a>, and <a class="el" href="classClpNetworkMatrix.html#a479062accf2f54e212998089e709b4d6">ClpNetworkMatrix</a>.</p>

</div>
</div>
<a id="af80ee9c5d03dec8609367e341a0688ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af80ee9c5d03dec8609367e341a0688ce">&#9670;&nbsp;</a></span>hiddenRows()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::hiddenRows </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns number of hidden rows e.g. gub. </p>

<p>Reimplemented in <a class="el" href="classClpGubMatrix.html#a31ebac4adc91830a7fd60d77e750d89a">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="aec1b6600d9d699aaad77e4b91f4381e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1b6600d9d699aaad77e4b91f4381e9">&#9670;&nbsp;</a></span>partialPricing()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::partialPricing </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>start</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>end</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>bestSequence</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>numberWanted</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial pricing. </p>

<p>Reimplemented in <a class="el" href="classClpPlusMinusOneMatrix.html#a4a5d44fb5f776c8b41f0d8b7a6948e25">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpPackedMatrix.html#a7720f712d32e68d73e3d486de4dd610f">ClpPackedMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a9d6b22ff935e31a1266f05a3a3f83085">ClpNetworkMatrix</a>, <a class="el" href="classClpGubMatrix.html#a425dda5df699a29ec4fc9073329b6d1c">ClpGubMatrix</a>, <a class="el" href="classClpDynamicExampleMatrix.html#ad92a0fe60207d33439be3a34bebe3578">ClpDynamicExampleMatrix</a>, <a class="el" href="classClpDynamicMatrix.html#a50be1f7834a9e187105d5123bdfcd610">ClpDynamicMatrix</a>, and <a class="el" href="classClpGubDynamicMatrix.html#a4718f96eda903c793b71a5526eafb9c1">ClpGubDynamicMatrix</a>.</p>

</div>
</div>
<a id="a9e54515ed3d102523a82ad35bda7a13e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e54515ed3d102523a82ad35bda7a13e">&#9670;&nbsp;</a></span>extendUpdated()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::extendUpdated </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>update</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>expands an updated column to allow for extra rows which the main solver does not know about and returns number added. </p>
<p>This will normally be a no-op - it is in for GUB but may get extended to general non-overlapping and embedded networks.</p>
<p>mode 0 - extend mode 1 - delete etc </p>

<p>Reimplemented in <a class="el" href="classClpGubMatrix.html#ac86ba73bf06a3768b63038ccaed8e890">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="a5101be2165e62f9447cbd931ff25ebce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5101be2165e62f9447cbd931ff25ebce">&#9670;&nbsp;</a></span>primalExpanded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::primalExpanded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility primal function for dealing with dynamic constraints mode=0 - Set up before "update" and "times" for primal solution using extended rows mode=1 - Cleanup primal solution after "times" using extended rows. </p>
<p>mode=2 - Check (or report on) primal infeasibilities </p>

<p>Reimplemented in <a class="el" href="classClpGubMatrix.html#aad2d4e9eac2dc0eacb485433c51c4e6f">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="a60dee2f2426217242ed3b97cac07d55c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60dee2f2426217242ed3b97cac07d55c">&#9670;&nbsp;</a></span>dualExpanded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::dualExpanded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>array</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>other</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>utility dual function for dealing with dynamic constraints mode=0 - Set up before "updateTranspose" and "transposeTimes" for duals using extended updates array (and may use other if dual values pass) mode=1 - Update dual solution after "transposeTimes" using extended rows. </p>
<p>mode=2 - Compute all djs and compute key dual infeasibilities mode=3 - Report on key dual infeasibilities mode=4 - Modify before updateTranspose in partial pricing </p>

<p>Reimplemented in <a class="el" href="classClpGubMatrix.html#a017e973fadd9a9ec35caba1f04fde949">ClpGubMatrix</a>, and <a class="el" href="classClpDynamicMatrix.html#a2e6fd6433697da87fa0bb42838f5628e">ClpDynamicMatrix</a>.</p>

</div>
</div>
<a id="a527d06d4823ce1398bb19046ccd23822"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a527d06d4823ce1398bb19046ccd23822">&#9670;&nbsp;</a></span>generalExpanded()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::generalExpanded </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>mode</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>number</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>general utility function for dealing with dynamic constraints mode=0 - Create list of non-key basics in pivotVariable_ using number as numberBasic in and out mode=1 - Set all key variables as basic mode=2 - return number extra rows needed, number gives maximum number basic mode=3 - before replaceColumn mode=4 - return 1 if can do primal, 2 if dual, 3 if both mode=5 - save any status stuff (when in good state) mode=6 - restore status stuff mode=7 - flag given variable (normally sequenceIn) mode=8 - unflag all variables mode=9 - synchronize costs and bounds mode=10 - return 1 if there may be changing bounds on variable (column generation) mode=11 - make sure set is clean (used when a variable rejected - but not flagged) mode=12 - after factorize but before permute stuff mode=13 - at end of simplex to delete stuff </p>

<p>Reimplemented in <a class="el" href="classClpGubMatrix.html#a6230567e0eab5e704cef52141b43c75d">ClpGubMatrix</a>, and <a class="el" href="classClpDynamicMatrix.html#aeab8e7ddecee3b526e3631c0f9b9cffd">ClpDynamicMatrix</a>.</p>

</div>
</div>
<a id="a74941ea6a6cf2b1a52b3d918eee011c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74941ea6a6cf2b1a52b3d918eee011c6">&#9670;&nbsp;</a></span>updatePivot()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::updatePivot </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>oldInValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>oldOutValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>update information for a pivot (and effective rhs) </p>

<p>Reimplemented in <a class="el" href="classClpGubMatrix.html#acc5e3b219ff08a401542e6cdee4cefbd">ClpGubMatrix</a>, <a class="el" href="classClpGubDynamicMatrix.html#ac6d793fd496351afc39eb59221655bad">ClpGubDynamicMatrix</a>, and <a class="el" href="classClpDynamicMatrix.html#a82da38b767030d2aff4f05d94b84041b">ClpDynamicMatrix</a>.</p>

</div>
</div>
<a id="aa4f551cbf44dec95ec7b51259c5c5378"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4f551cbf44dec95ec7b51259c5c5378">&#9670;&nbsp;</a></span>createVariable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::createVariable </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>bestSequence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a variable. </p>
<p>This is called after partial pricing and may modify matrix. May update bestSequence. </p>

<p>Reimplemented in <a class="el" href="classClpDynamicMatrix.html#a9ff51f6ebecb6a1afab31556118095c9">ClpDynamicMatrix</a>, and <a class="el" href="classClpDynamicExampleMatrix.html#af78cc932dfc5c5eeff3f3236f74a9753">ClpDynamicExampleMatrix</a>.</p>

</div>
</div>
<a id="a263f5d27095dbe19dd0c03511d520d8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a263f5d27095dbe19dd0c03511d520d8e">&#9670;&nbsp;</a></span>checkFeasible()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::checkFeasible </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double &amp;&#160;</td>
          <td class="paramname"><em>sum</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Just for debug if odd type matrix. </p>
<p>Returns number of primal infeasibilities. </p>

<p>Reimplemented in <a class="el" href="classClpGubDynamicMatrix.html#a064544a10b6189658294c5a71d949cb9">ClpGubDynamicMatrix</a>.</p>

</div>
</div>
<a id="a7882fb623bfd78359caa738a09bdbb31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7882fb623bfd78359caa738a09bdbb31">&#9670;&nbsp;</a></span>reducedCost()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double ClpMatrixBase::reducedCost </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sequence</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns reduced cost of a variable. </p>

</div>
</div>
<a id="a5990595a7cf495607a5364d034c8b2a9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5990595a7cf495607a5364d034c8b2a9">&#9670;&nbsp;</a></span>correctSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::correctSequence </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sequenceIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int &amp;&#160;</td>
          <td class="paramname"><em>sequenceOut</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Correct sequence in and out to give true value (if both -1 maybe do whole matrix) </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a962241369302dc18a343810534c5d65e">ClpPackedMatrix</a>, and <a class="el" href="classClpGubMatrix.html#a58e278c0f2cbbed59b8c0270495eca26">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="ac709438afef7f211fcc46744669a22ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac709438afef7f211fcc46744669a22ac">&#9670;&nbsp;</a></span>times() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::times </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>y + A * x * scalar</code> in <code>y</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>x</code> must be of size <code>numColumns()</code> </dd>
<dd>
<code>y</code> must be of size <code>numRows()</code> </dd></dl>

</div>
</div>
<a id="a5d6870bbc8efb55b994367a1c4c42df6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d6870bbc8efb55b994367a1c4c42df6">&#9670;&nbsp;</a></span>times() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::times </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>rowScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>columnScale</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>And for scaling - default aborts for when scaling not supported (unless pointers NULL when as normal) </p>

</div>
</div>
<a id="a80aa6ee57b76db2cc4fefb7d310e6dad"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80aa6ee57b76db2cc4fefb7d310e6dad">&#9670;&nbsp;</a></span>transposeTimes() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::transposeTimes </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>y</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>y + x * scalar * A</code> in <code>y</code>. </p>
<dl class="section pre"><dt>Precondition</dt><dd><code>x</code> must be of size <code>numRows()</code> </dd>
<dd>
<code>y</code> must be of size <code>numColumns()</code> </dd></dl>

</div>
</div>
<a id="a0b53ead42b8a5b948c1045a9a11717c2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0b53ead42b8a5b948c1045a9a11717c2">&#9670;&nbsp;</a></span>transposeTimes() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::transposeTimes </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>rowScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>columnScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *<a class="el" href="ClpMatrixBase_8hpp.html#aea9d49cf32f1f69616fbf0d218a18048">COIN_RESTRICT</a>&#160;</td>
          <td class="paramname"><em>spare</em> = <code>NULL</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>And for scaling - default aborts for when scaling not supported (unless pointers NULL when as normal) </p>

</div>
</div>
<a id="ab1cb53d592110044b21e74b3c37c0c12"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1cb53d592110044b21e74b3c37c0c12">&#9670;&nbsp;</a></span>transposeTimes() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::transposeTimes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scalar</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>x * scalar *A + y</code> in <code>z</code>. </p>
<p>Can use y as temporary array (will be empty at end) Note - If x packed mode - then z packed mode Squashes small elements and knows about <a class="el" href="classClpSimplex.html" title="This solves LPs using the simplex method.">ClpSimplex</a> </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#ae4e13e4eef2338f15d83732b52a4b1bf">ClpPackedMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#aa70bc0ef8d0929f9abd52a80cae68905">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#af1c06258f25d7447c64b23fc637d0fce">ClpNetworkMatrix</a>, <a class="el" href="classClpDummyMatrix.html#a03dc202362ce67a6f15c651f73b1207f">ClpDummyMatrix</a>, and <a class="el" href="classClpGubMatrix.html#abd2f36575835c11e0e7b4a00053be4cf">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="aeda91d80ef5603113ec55bbcdfcf9f34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeda91d80ef5603113ec55bbcdfcf9f34">&#9670;&nbsp;</a></span>subsetTransposeTimes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::subsetTransposeTimes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>x *A</code> in <code>z</code> but just for indices in y. </p>
<p>This is only needed for primal steepest edge. Note - z always packed mode </p>

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#ace6f5f605a69790515c013de8a07fa5a">ClpPackedMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#a10141b04ab5acbfc28f56c1594731d2f">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#ada49dc08a6d8f7fd021465874d75a775">ClpNetworkMatrix</a>, <a class="el" href="classClpDummyMatrix.html#acc97d1383e50c4c369a76cf794f2dc8a">ClpDummyMatrix</a>, and <a class="el" href="classClpGubMatrix.html#a4f924108ca38b7f3b00cb3024995dc03">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="ace0dfda734fcca7928bcd71413d019e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace0dfda734fcca7928bcd71413d019e8">&#9670;&nbsp;</a></span>canCombine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool ClpMatrixBase::canCombine </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinIndexedVector *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns true if can combine transposeTimes and subsetTransposeTimes and if it would be faster. </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a740cd78626c8bcbcefc550a839da63ad">ClpPackedMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#aa69a7dd8f4825772e676557ee54946b1">ClpPlusMinusOneMatrix</a>.</p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00328">328</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="aab8e72f5bbb3396d4f0d7ebb2b58a978"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab8e72f5bbb3396d4f0d7ebb2b58a978">&#9670;&nbsp;</a></span>transposeTimes2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual int ClpMatrixBase::transposeTimes2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>pi1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>dj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>pi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>spare</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>infeas</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>reducedCost</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>referenceIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>devex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaleFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates two arrays for steepest and does devex weights (need not be coded) Returns nonzero if updates reduced cost and infeas - new infeas in dj1. </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a6702a2ea50309c4592ed07da5311f9b7">ClpPackedMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#ac8132ed515c72158958ac42d1e58e736">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a866128fea0f5138de3fc51cce99f4d31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a866128fea0f5138de3fc51cce99f4d31">&#9670;&nbsp;</a></span>subsetTimes2()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::subsetTimes2 </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>dj1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>pi2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CoinIndexedVector *&#160;</td>
          <td class="paramname"><em>dj2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>referenceIn</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>devex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>reference</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>weights</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>scaleFactor</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Updates second array for steepest and does devex weights (need not be coded) </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#ad9e40f27616b91717f99b01d9548c55c">ClpPackedMatrix</a>, and <a class="el" href="classClpPlusMinusOneMatrix.html#a3e82e5cb291503b9ffe08d32ca34feee">ClpPlusMinusOneMatrix</a>.</p>

</div>
</div>
<a id="a7e53a81ffc47976ef9cdb3547ef575a5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7e53a81ffc47976ef9cdb3547ef575a5">&#9670;&nbsp;</a></span>listTransposeTimes()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::listTransposeTimes </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>number</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double *&#160;</td>
          <td class="paramname"><em>z</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Return <code>x *A</code> in <code>z</code> but just for number indices in y. </p>
<p>Default cheats with fake CoinIndexedVector and then calls subsetTransposeTimes </p>

</div>
</div>
<a id="ae5a41e96610958bc8d4a08d889ecf7a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5a41e96610958bc8d4a08d889ecf7a3">&#9670;&nbsp;</a></span>clone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a>* ClpMatrixBase::clone </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Implemented in <a class="el" href="classClpPackedMatrix.html#ab4177cdcc852e88c41012c72eb724d73">ClpPackedMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#a388689715397d271e36d1599823d14dc">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a8e82ac9f2c87c57bb3f4aad1359bbfc8">ClpNetworkMatrix</a>, <a class="el" href="classClpGubMatrix.html#a1d8721366ab870cc803d86754999de85">ClpGubMatrix</a>, <a class="el" href="classClpDummyMatrix.html#a632639f2d8dcfbe752dd68d2a29238dd">ClpDummyMatrix</a>, <a class="el" href="classClpDynamicMatrix.html#acdf6c4cc93a3e039198b4d39d101d1bb">ClpDynamicMatrix</a>, <a class="el" href="classClpDynamicExampleMatrix.html#a553ad8aa788b5161404f7bdb3cdb1785">ClpDynamicExampleMatrix</a>, and <a class="el" href="classClpGubDynamicMatrix.html#a157f33973fc4945b760fe4fefa78809d">ClpGubDynamicMatrix</a>.</p>

</div>
</div>
<a id="a5a0e1e9011be8ebcfb4ab4761342d95f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5a0e1e9011be8ebcfb4ab4761342d95f">&#9670;&nbsp;</a></span>subsetClone()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a>* ClpMatrixBase::subsetClone </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>whichRows</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>numberColumns</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const int *&#160;</td>
          <td class="paramname"><em>whichColumns</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Subset clone (without gaps). </p>
<p>Duplicates are allowed and order is as given. Derived classes need not provide this as it may not always make sense </p>

<p>Reimplemented in <a class="el" href="classClpPackedMatrix.html#a2e84482bdf9a64408ad63c7a53c5b4e7">ClpPackedMatrix</a>, <a class="el" href="classClpPlusMinusOneMatrix.html#ad518eb24bd6aeda4c2d78347e88c464e">ClpPlusMinusOneMatrix</a>, <a class="el" href="classClpNetworkMatrix.html#a12f977987b617f52b3739c9081060397">ClpNetworkMatrix</a>, and <a class="el" href="classClpGubMatrix.html#aa9e8e57fc4015fc0276c678dccb98d52">ClpGubMatrix</a>.</p>

</div>
</div>
<a id="a4390c386ae11d2b412645ab8ae15e589"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4390c386ae11d2b412645ab8ae15e589">&#9670;&nbsp;</a></span>backToBasics()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void ClpMatrixBase::backToBasics </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets rid of any mutable by products. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00376">376</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a882fc3dd899de5f6417250abcb883155"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a882fc3dd899de5f6417250abcb883155">&#9670;&nbsp;</a></span>type()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::type </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns type. </p>
<p>The types which code may need to know about are: 1 - <a class="el" href="classClpPackedMatrix.html">ClpPackedMatrix</a> 11 - <a class="el" href="classClpNetworkMatrix.html" title="This implements a simple network matrix as derived from ClpMatrixBase.">ClpNetworkMatrix</a> 12 - <a class="el" href="classClpPlusMinusOneMatrix.html" title="This implements a simple +- one matrix as derived from ClpMatrixBase.">ClpPlusMinusOneMatrix</a> </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00383">383</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a7ac46dc89dd1d994a15df49eadd57cf1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac46dc89dd1d994a15df49eadd57cf1">&#9670;&nbsp;</a></span>setType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::setType </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>newtype</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets type. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00388">388</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a9e419cd897e42ceca91c3f7922ead777"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e419cd897e42ceca91c3f7922ead777">&#9670;&nbsp;</a></span>useEffectiveRhs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::useEffectiveRhs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets up an effective RHS. </p>

</div>
</div>
<a id="afd89cc8633dd027426ef6b1358a6c1b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd89cc8633dd027426ef6b1358a6c1b4">&#9670;&nbsp;</a></span>rhsOffset()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual double* ClpMatrixBase::rhsOffset </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classClpSimplex.html">ClpSimplex</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>forceRefresh</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>check</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns effective RHS offset if it is being used. </p>
<p>This is used for long problems or big gub or anywhere where going through full columns is expensive. This may re-compute </p>

<p>Reimplemented in <a class="el" href="classClpGubMatrix.html#a63bf5a8954b2d8fadef2ce56e2bca7d4">ClpGubMatrix</a>, <a class="el" href="classClpGubDynamicMatrix.html#afd503c4480df17307503f43ead015d1a">ClpGubDynamicMatrix</a>, and <a class="el" href="classClpDynamicMatrix.html#abf56ec1af330d1d53b0f4bbf22a6f75c">ClpDynamicMatrix</a>.</p>

</div>
</div>
<a id="a0ccbafdeab34c141d4fe51bead3a0799"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ccbafdeab34c141d4fe51bead3a0799">&#9670;&nbsp;</a></span>lastRefresh()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::lastRefresh </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If rhsOffset used this is iteration last refreshed. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00400">400</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a9211d38c32ed96c2fb6e8a4142255b40"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9211d38c32ed96c2fb6e8a4142255b40">&#9670;&nbsp;</a></span>refreshFrequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::refreshFrequency </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If rhsOffset used this is refresh frequency (0==off) </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00405">405</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="ab249ed1da09f4165aeeb4d20e07af869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab249ed1da09f4165aeeb4d20e07af869">&#9670;&nbsp;</a></span>setRefreshFrequency()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::setRefreshFrequency </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00409">409</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="abdf5ce75f487619543e2dc177bc61e83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdf5ce75f487619543e2dc177bc61e83">&#9670;&nbsp;</a></span>skipDualCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ClpMatrixBase::skipDualCheck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether to skip dual checks most of time </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00414">414</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="af0ada77e75e2c536fb88f8968d1ad038"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0ada77e75e2c536fb88f8968d1ad038">&#9670;&nbsp;</a></span>setSkipDualCheck()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::setSkipDualCheck </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>yes</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00418">418</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="ab8e01a701e42bcbd91e96e42611dfab0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8e01a701e42bcbd91e96e42611dfab0">&#9670;&nbsp;</a></span>minimumObjectsScan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::minimumObjectsScan </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial pricing tuning parameter - minimum number of "objects" to scan. </p>
<p>e.g. number of Gub sets but could be number of variables </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00424">424</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a9579c957a9bee36a096f219db5a03f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9579c957a9bee36a096f219db5a03f31">&#9670;&nbsp;</a></span>setMinimumObjectsScan()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::setMinimumObjectsScan </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00428">428</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a8d819e4dabe5ac194f9c3a7f6dd0eaed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8d819e4dabe5ac194f9c3a7f6dd0eaed">&#9670;&nbsp;</a></span>minimumGoodReducedCosts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::minimumGoodReducedCosts </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial pricing tuning parameter - minimum number of negative reduced costs to get. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00433">433</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a39ddb8e467341bb9c6267dde454669e3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a39ddb8e467341bb9c6267dde454669e3">&#9670;&nbsp;</a></span>setMinimumGoodReducedCosts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::setMinimumGoodReducedCosts </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00437">437</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a465d58b66aef67e9e1e99d702e3dcc5c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a465d58b66aef67e9e1e99d702e3dcc5c">&#9670;&nbsp;</a></span>startFraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ClpMatrixBase::startFraction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current start of search space in matrix (as fraction) </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00442">442</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="ac421bf0475ca6728b4970ee9d659030b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac421bf0475ca6728b4970ee9d659030b">&#9670;&nbsp;</a></span>setStartFraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::setStartFraction </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00446">446</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a9e7f4a60e1628984bd074c609fe660be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9e7f4a60e1628984bd074c609fe660be">&#9670;&nbsp;</a></span>endFraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ClpMatrixBase::endFraction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current end of search space in matrix (as fraction) </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00451">451</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a31432e7c0fd75563c9772d1089bf6467"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a31432e7c0fd75563c9772d1089bf6467">&#9670;&nbsp;</a></span>setEndFraction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::setEndFraction </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00455">455</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="ac6647956268691a0096e86ddde8e904d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6647956268691a0096e86ddde8e904d">&#9670;&nbsp;</a></span>savedBestDj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ClpMatrixBase::savedBestDj </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current best reduced cost. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00460">460</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a65fb5543f3e35709f8e1c7922b15c407"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a65fb5543f3e35709f8e1c7922b15c407">&#9670;&nbsp;</a></span>setSavedBestDj()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::setSavedBestDj </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00464">464</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a9fdd9962657f53b782eae9a8f267e3ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9fdd9962657f53b782eae9a8f267e3ac">&#9670;&nbsp;</a></span>originalWanted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::originalWanted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initial number of negative reduced costs wanted. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00469">469</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a545e08cf1be9fa216cdad8ae7db86947"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545e08cf1be9fa216cdad8ae7db86947">&#9670;&nbsp;</a></span>setOriginalWanted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::setOriginalWanted </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00473">473</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="af0558c228415c614205c841750084c1c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0558c228415c614205c841750084c1c">&#9670;&nbsp;</a></span>currentWanted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::currentWanted </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current number of negative reduced costs which we still need. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00478">478</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a6dd6e1d2a3b23bb8929be77c2ca923e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd6e1d2a3b23bb8929be77c2ca923e9">&#9670;&nbsp;</a></span>setCurrentWanted()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::setCurrentWanted </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00482">482</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a5c6d2937e73278ae4eaa4798b7ed22fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c6d2937e73278ae4eaa4798b7ed22fe">&#9670;&nbsp;</a></span>savedBestSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::savedBestSequence </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current best sequence. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00487">487</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a4ac4f21dfbc09ed7b33b0fb4e5b23869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4ac4f21dfbc09ed7b33b0fb4e5b23869">&#9670;&nbsp;</a></span>setSavedBestSequence()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void ClpMatrixBase::setSavedBestSequence </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>value</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00491">491</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a4a1ea38e5e680de5a38b4f65ce4d275f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a1ea38e5e680de5a38b4f65ce4d275f">&#9670;&nbsp;</a></span>operator=()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a>&amp; ClpMatrixBase::operator= </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classClpMatrixBase.html">ClpMatrixBase</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Data Documentation</h2>
<a id="ad5ec28bf0f0da85271563db3ac842400"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5ec28bf0f0da85271563db3ac842400">&#9670;&nbsp;</a></span>rhsOffset_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double* ClpMatrixBase::rhsOffset_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Effective RHS offset if it is being used. </p>
<p>This is used for long problems or big gub or anywhere where going through full columns is expensive </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00522">522</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="abec7398c2534045b5f35dc15225a4ece"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abec7398c2534045b5f35dc15225a4ece">&#9670;&nbsp;</a></span>startFraction_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ClpMatrixBase::startFraction_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current start of search space in matrix (as fraction) </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00524">524</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="ae786f1c9247f4cb1048cb17e68bade89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae786f1c9247f4cb1048cb17e68bade89">&#9670;&nbsp;</a></span>endFraction_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ClpMatrixBase::endFraction_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current end of search space in matrix (as fraction) </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00526">526</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a27ba2356a51f97ab52927d9664bc02d0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a27ba2356a51f97ab52927d9664bc02d0">&#9670;&nbsp;</a></span>savedBestDj_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double ClpMatrixBase::savedBestDj_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Best reduced cost so far. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00528">528</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="afb081dba0051e7e973832c7cea86bb54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb081dba0051e7e973832c7cea86bb54">&#9670;&nbsp;</a></span>originalWanted_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::originalWanted_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Initial number of negative reduced costs wanted. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00530">530</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a691cbfa984c3ddfd4387833d27f6c16d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a691cbfa984c3ddfd4387833d27f6c16d">&#9670;&nbsp;</a></span>currentWanted_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::currentWanted_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Current number of negative reduced costs which we still need. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00532">532</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a3bea489a8066c74ae251e375861a965d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3bea489a8066c74ae251e375861a965d">&#9670;&nbsp;</a></span>savedBestSequence_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::savedBestSequence_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Saved best sequence in pricing. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00534">534</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a908d645bfb8c7bca32dc80a8985407d9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a908d645bfb8c7bca32dc80a8985407d9">&#9670;&nbsp;</a></span>type_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::type_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>type (may be useful) </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00536">536</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a90f8704c47bc37225648efdb6bb06816"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90f8704c47bc37225648efdb6bb06816">&#9670;&nbsp;</a></span>lastRefresh_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::lastRefresh_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If rhsOffset used this is iteration last refreshed. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00538">538</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="abeb258646d90b3e1b7c88ad2ccbd2b2c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abeb258646d90b3e1b7c88ad2ccbd2b2c">&#9670;&nbsp;</a></span>refreshFrequency_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::refreshFrequency_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>If rhsOffset used this is refresh frequency (0==off) </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00540">540</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a79b0ebc260090b33d23f10b88da30d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79b0ebc260090b33d23f10b88da30d1e">&#9670;&nbsp;</a></span>minimumObjectsScan_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::minimumObjectsScan_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial pricing tuning parameter - minimum number of "objects" to scan. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00542">542</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a356e774b167d00378d1352f42effef46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356e774b167d00378d1352f42effef46">&#9670;&nbsp;</a></span>minimumGoodReducedCosts_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::minimumGoodReducedCosts_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Partial pricing tuning parameter - minimum number of negative reduced costs to get. </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00544">544</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a1bd1b94a4aa10986177352f807e115ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1bd1b94a4aa10986177352f807e115ff">&#9670;&nbsp;</a></span>trueSequenceIn_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::trueSequenceIn_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True sequence in (i.e. from larger problem) </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00546">546</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="acd6b009fc0b1fc73cb79403aa67aed25"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd6b009fc0b1fc73cb79403aa67aed25">&#9670;&nbsp;</a></span>trueSequenceOut_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int ClpMatrixBase::trueSequenceOut_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>True sequence out (i.e. from larger problem) </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00548">548</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<a id="a6b2bae64f8cd712b29f14adcd457d124"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b2bae64f8cd712b29f14adcd457d124">&#9670;&nbsp;</a></span>skipDualCheck_</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">bool ClpMatrixBase::skipDualCheck_</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">protected</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>whether to skip dual checks most of time </p>

<p class="definition">Definition at line <a class="el" href="ClpMatrixBase_8hpp_source.html#l00550">550</a> of file <a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>/home/ted/Projects/Clp/Clp/src/<a class="el" href="ClpMatrixBase_8hpp_source.html">ClpMatrixBase.hpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
